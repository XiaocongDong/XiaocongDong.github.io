---
title: 窥探现代浏览器架构-三
thumbnail: /gallery/thumbnails/chrome.png
tags:
  - Chrome
  - 浏览器
categories:
  - 前端
---
## 前言
本文是笔者对[Mario Kosaka](https://developers.google.com/web/resources/contributors/kosamari)写的[inside look at modern web browser](https://developers.google.com/web/updates/2018/09/inside-browser-part3)系列文章的翻译。这里的翻译不是指直译，而是结合个人的理解将作者想表达的意思表达出来，而且会尽量补充一些相关的内容来帮助大家更好地理解。

## 渲染进程里面发生的事
这篇文章是探究Chrome内部工作原理的**四集系列文章**中的第三篇。之前我们分别探讨了[Chrome的多进程架构](prev_1)以及[导航的过程都发生了什么](prev_2)。在本篇文章中，我们将要窥探一下渲染进程在渲染网站的时候都发生了什么事情。

渲染进程涉及到Web性能的很多方面。因为渲染的时候发生的东西实在太多了，所以本篇文章只能作一个大体的介绍。如果你想要了解得更多，[Web Fundamentals的Performance栏目](https://developers.google.com/web/fundamentals/performance/why-performance-matters/)有很多相关的资源。

## 渲染进程处理web内容
渲染进程负责在标签（tab）里面发生的所有事情。在渲染进程里面，主进程（main thread）处理了绝大多数你发送给用户的代码。如果你使用了web worker或者service worker的话，你那些部分的代码将会由渲染进程的工作线程（worker thread）处理。合成（compositor）以及光栅化（raster）进程也是运行在渲染进程里面的，他们用来高效流畅地渲染出页面内容。

**渲染进程的主要任务是将HTML，CSS，以及JavaScript转变为我们可以进程交互的网页内容**。
![](/images/chrome/renderer.png)
<p align="center">渲染进程里面有：一个主线程（main thread），一些列的工作线程（worker threads），一个合成线程（compositor thread）以及一个光栅化线程（raster thread）</p>

## 解析
### 构建DOM
前面文章提到，渲染进程在导航结束的时候会收到来自浏览器进程的commit导航消息，收到消息后渲染进程就会开始接收HTML数据，同时主线程也会开始解析接收到的文本数据（text string）并把它转化为一个DOM（**D**ocument **O**bject **M**odel）对象

DOM对象既是浏览器对页面的内部表示，同时也是Web开发人员可以通过JavaScript与之交互的数据结构以及API。

如何将HTML文档解析为一个DOM对象是由[HTML标准](https://html.spec.whatwg.org/)定义的。可能在你的web开发生涯里面，你从来没有遇到过浏览器在解析HTML的时候发生错误的情况。这是因为浏览器对HTML的错误容忍度很大。举些例子：确实了闭合p标签（</p>）的页面还是个有效的HTML；Hi! <b>I'm <i>Chrome</b>!</i> (b标签虽然已经闭合，可是它在闭合i标签的前面) 会被浏览器处理为Hi! <b>I'm <i>Chrome</i></b><i>!</i>。如果你想知道浏览器是如何对这些错误的HTML情景进行容错处理的，可以参考HTML规范里面的[An introduction to error handling and strange cases in the parser](https://html.spec.whatwg.org/multipage/parsing.html#an-introduction-to-error-handling-and-strange-cases-in-the-parser)部分内容。

### 子资源加载
一个网站除了HTML文件，同时还会使用到另外的一些诸如图片，CSS样式以及JavaScript脚本等子资源。这些文件会被从缓存或者网络上获取。主线程会按照在构建DOM树时遇到各个资源的循序一个接着一个地发起请求来获取相应的资源，可是为了提升效率，浏览器会同时运行“预加载扫描程序”。如果在HTML文档里面存在诸如<img>或者<link>这样的标签，预加载扫描程序会在HTML解析器生成的token里面找到对应要获取的资源，并把这些要获取的资源告诉浏览器进程里面的网络线程。
![](/images/chrome/dom.png)
<p align="center">主线程会解析获取到的HTML内容并且构建出DOM树</p>

### JavaScript会阻塞HTML的解析过程
当HTML解析器碰到script标签的时候，它会停止对HTML文档的解析从而转向对JavaScript代码的加载，解析以及执行。为什么会这样的呢？这是因为遇到的JavaScript代码会使用诸如**document.write()**这样的代码会改变文档流（document）的形状，这会使整个DOM树的解构发生根本性的改变（HTML规范里面的[overview of the parsing model部分](https://html.spec.whatwg.org/multipage/parsing.html#overview-of-the-parsing-model)有很好的示意图）。因为这个原因，HTML解析器不得不等JavaScript执行完之前才能继续对HTML文档流的解析工作了。如果你想知道JavaScipt的执行过程都发生了什么，V8团队有很多关于这个话题的[演讲以及博客](https://mathiasbynens.be/notes/shapes-ics)。

## 给浏览器一点你想如何加载资源的提示
Web开发者可以通过很多方式去告诉浏览器如何从能更加优雅的加载网页需要用到的资源。如果你的JavaScript不会使用到诸如**document.write()**的方式去改变文档流的内容的话，你可以为script标签添加一个[async](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async)或者[defer](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-defer)属性来使JavaScript脚本异步加载。当然如何适合你的情景需要的话，你也可以使用[JavaScript Module](https://developers.google.com/web/fundamentals/primers/modules)。同时**<link rel="preload">**资源预加载也是一种很好的方式去告诉浏览器当前的资源在当前的导航肯定会被用到，你想要尽快加载这个资源。更多相关的内容，你可阅读[Resource Prioritization - Getting the Browser to Help You](https://developers.google.com/web/fundamentals/performance/resource-prioritization)这篇文章。

## 样式计算
拥有了DOM树我们还不足以知道页面的外貌，因为我们通常会为页面的元素设置一些样式。主线程会解析页面的CSS并且会确定每个DOM界面的计算样式（computed style）。计算样式是根据CSS样式选择器（CSS selectors）来计算确定出的每个DOM元素应该具备的具体样式，你可以打开devtool来查看每个DOM节点对应的计算样式。
![](/images/chrome/computedstyle.png)
<p align="center">主线程解析CSS来确定每个元素的计算样式</p>

即使你的页面没有如何自定义的样式，每个DOM节点还是有一个计算样式属性 - 浏览器的默认样式表。这样即使没有自定义样式，页面上的h1标签就一定会被h2标签大，而且不同的标签会有不同的magin和padding。如果你想知道Chrome的默认样式是长什么样的，你可以直接查看[代码](https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/html/resources/html.css)。

## 布局 - Layout
前面这些步骤完成之后，渲染进程就已经知道页面的文档结构，并且每个DOM节点对应的样式信息了，可是这还是不能确定页面的样子。举个例子，你现在正在尝试通过电话来给你的朋友描绘一个页面的样子：“页面上有一个红色的大圆圈以及一个蓝色的正方形”，但从这些信息来看你的朋友是很难知道这个页面具体是长什么样的，因为他不知道大圆圈和正方形具体在页面的什么位置以及它们是不是互相重叠以及它们的重叠关系是什么样子的。
![](/images/chrome/tellgame.png)
<p align="center">一个人站在一幅画面前通过电话告诉另外一个人页面的信息</p>

网页渲染也是同样的道理，只知道网站的文档流以及每个节点的样式是远远不够渲染出页面的内容的，还需要布局（layout）这个步骤去计算出页面上每个节点的**几何信息**（geometry）。具体过程是：主线程会遍历刚刚得出的DOM树以及每个节点的计算样式信息来计算出一个布局树（layout tree），这颗树上面有每个节点会有一些诸如x，y坐标以及盒子大小的具体信息。布局树长得可能和先前的DOM树差不多，可是这颗树只有那些可见的（visible）节点的信息。举个例子，如果一个节点被设置为了**display:none**，这个节点就是不可见的就不会出现在布局树上面（**visibility:hidden**的节点会出现在布局树上面，你可以思考一下这是为什么）。同样的，如果一个伪元素（pseudo class）节点有诸如**p::before{content:"Hi!"}**这样的内容，它会出现在布局上，而不存在于DOM树上。
![](/images/chrome/layout.png)
<p align="center">主线程会遍历有计算样式信息的DOM树来生成一棵布局树</p>

确定页面的布局其实是一件非常有挑战性的事情。即使那些很简单的布局，例如从上而下展示一个又一个文本块也会很复杂，因为你需要考虑文本的字体大小以及在哪里需要换行因为这些东西会影响到段落的大小以及形状，继而影响到接下来的文本段落的布局。
<video id="video" controls="" preload="none" poster="http://media.w3.org/2010/05/sintel/poster.png">
  <source id="mp4" src="/images/chrome/trees.mp4" type="video/mp4">
</video>
<p align="center">由于换行使段落的布局发生了改变</p>

CSS可以让元素悬浮（float）到页面的其中一边，还可以遮挡住页面溢出的（overflow）元素，还可以改变内容的书写方向，所以单凭想象，你就知道布局这个过程是一个十分艰巨和复杂的任务了。对于Chrome浏览器，我们会有一整个负责布局过程的工程师团队。如果你想知道他们工作的具体内容，他们在[BlinkOn Conference](https://www.youtube.com/watch?v=Y5Xa4H2wtVA)上面的相关讨论被录制了下来，有时间的话你可以去看一下。