---
title: 窥探现代浏览器架构-三
thumbnail: /gallery/thumbnails/chrome.png
tags:
  - Chrome
  - 浏览器
categories:
  - 前端
---
## 前言
本文是笔者对[Mario Kosaka](https://developers.google.com/web/resources/contributors/kosamari)写的[inside look at modern web browser](https://developers.google.com/web/updates/2018/09/inside-browser-part3)系列文章的翻译。这里的翻译不是指直译，而是结合个人的理解将作者想表达的意思表达出来，而且会尽量补充一些相关的内容来帮助大家更好地理解。

## 渲染进程里面发生的事
这篇文章是探究Chrome内部工作原理的**四集系列文章**中的第三篇。之前我们分别探讨了[Chrome的多进程架构](prev_1)以及[导航的过程都发生了什么](prev_2)。在本篇文章中，我们将要窥探一下渲染进程在渲染页面的时候具体都发生了什么事情。

渲染进程会影响到Web性能的很多方面。页面渲染的时候发生的东西实在太多了，本篇文章只能作一个大体的介绍。如果你想要了解得更多，[Web Fundamentals的Performance栏目](https://developers.google.com/web/fundamentals/performance/why-performance-matters/)有很多相关的资源可以查看。

## 渲染进程处理web内容
渲染进程负责标签（tab）内发生的所有事情。在渲染进程里面，主线程（main thread）处理了绝大多数你发送给用户的代码。如果你使用了web worker或者service worker，相关的代码将会由工作线程（worker thread）处理。合成（compositor）以及光栅化（raster）线程运行在渲染进程里面用来高效流畅地渲染出页面内容。

**渲染进程的主要任务是将HTML，CSS，以及JavaScript转变为我们可以进程交互的网页内容**。
![](/images/chrome/renderer.png)
<p align="center">渲染进程里面有：一个主线程（main thread），几个工作线程（worker threads），一个合成线程（compositor thread）以及一个光栅化线程（raster thread）</p>

## 解析
### 构建DOM
前面文章提到，渲染进程在导航结束的时候会收到来自浏览器进程提交导航（commit navigation）的消息，在这之后渲染进程就会开始接收HTML数据，同时主线程也会开始解析接收到的文本数据（text string）并把它转化为一个DOM（**D**ocument **O**bject **M**odel）对象

DOM对象既是浏览器对当前页面的内部表示，也是Web开发人员通过JavaScript与网页进行交互的数据结构以及API。

如何将HTML文档解析为DOM树是在[HTML标准](https://html.spec.whatwg.org/)中定义的。不过在你的web开发生涯中，你可能从来没有遇到过浏览器在解析HTML的时候发生错误的情景。这是因为浏览器对HTML的错误容忍度很大。举些例子：缺失了闭合p标签（\</p\>）的页面还是会被当做有效的HTML；Hi! \<b\>I'm \<i\>Chrome\</b\>!\</i\> (闭合b标签写在了闭合i标签的前面) 是个错误的HTML标签，不过浏览器会把它处理为Hi! \<b\>I'm \<i\>Chrome\</i\>\</b\>\<i\>!\</i\>。如果你想知道浏览器是如何对这些错误的HTML情景进行容错处理的，可以参考HTML规范里面的[An introduction to error handling and strange cases in the parser](https://html.spec.whatwg.org/multipage/parsing.html#an-introduction-to-error-handling-and-strange-cases-in-the-parser)部分内容。

### 子资源加载
除了HTML文件，网站通常还会使用到一些诸如图片，CSS样式以及JavaScript脚本等子资源。这些文件会从缓存或者网络上获取。主线程会按照在构建DOM树时遇到各个资源的循序一个接着一个地发起网络请求，可是为了提升效率，浏览器会同时运行“预加载扫描”程序。如果在HTML文档里面存在诸如\<img\>或者\<link\>这样的标签，预加载扫描程序会在HTML解析器生成的token里面找到对应要获取的资源，并把这些要获取的资源告诉浏览器进程里面的网络线程。
![](/images/chrome/dom.png)
<p align="center">主线程会解析HTML内容并且构建出DOM树</p>

### JavaScript会阻塞HTML的解析过程
当HTML解析器碰到script标签的时候，它会停止HTML文档的解析从而转向JavaScript代码的加载，解析以及执行。为什么要这样做呢？因为script标签中的JavaScript可能会使用诸如`document.write()`这样的代码改变文档流（document）的形状，从而使整个DOM树的结构发生根本性的改变（HTML规范里面的[overview of the parsing model部分](https://html.spec.whatwg.org/multipage/parsing.html#overview-of-the-parsing-model)有很好的示意图）。因为这个原因，HTML解析器不得不等JavaScript执行完成之后才能继续对HTML文档流的解析工作。如果你想知道JavaScipt的执行过程都发生了什么，V8团队有很多关于这个话题的[讨论以及博客](https://mathiasbynens.be/notes/shapes-ics)。

## 给浏览器一点如何加载资源的提示
Web开发者可以通过很多方式告诉浏览器如何才能更加优雅地加载网页需要用到的资源。如果你的JavaScript不会使用到诸如`document.write()`的方式去改变文档流的内容的话，你可以为script标签添加一个[async](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async)或者[defer](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-defer)属性来使JavaScript脚本异步加载。当然如果能满足到你的需求，你也可以使用[JavaScript Module](https://developers.google.com/web/fundamentals/primers/modules)。同时`<link rel="preload">`资源预加载也是一种很好的方式去告诉浏览器当前的资源在当前的导航肯定会被用到，你想要尽快加载这个资源。更多相关的内容，你可阅读[Resource Prioritization - Getting the Browser to Help You](https://developers.google.com/web/fundamentals/performance/resource-prioritization)这篇文章。

## 样式计算 - Style calculation
拥有了DOM树我们还不足以知道页面的外貌，因为我们通常会为页面的元素设置一些样式。主线程会解析页面的CSS从而确定每个DOM节点的计算样式（computed style）。计算样式是主线程根据CSS样式选择器（CSS selectors）计算出的每个DOM元素应该具备的具体样式，你可以打开devtools来查看每个DOM节点对应的计算样式。
![](/images/chrome/computedstyle.png)
<p align="center">主线程解析CSS来确定每个元素的计算样式</p>

即使你的页面没有任何自定义的样式，每个DOM节点还是有一个计算样式属性，这是因为每个浏览器都有自己的默认样式表。因为这个样式表的存在，页面上的h1标签一定会比h2标签大，而且不同的标签会有不同的magin和padding。如果你想知道Chrome的默认样式是长什么样的，你可以直接查看[代码](https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/html/resources/html.css)。

## 布局 - Layout
前面这些步骤完成之后，渲染进程就已经知道页面的具体文档结构以及每个节点拥有的样式信息了，可是这些信息还是不能最终确定页面的样子。举个例子，假如你现在想通过电话告诉你的朋友你身边的一幅画的内容：“画布上有一个红色的大圆圈和一个蓝色的正方形”，单凭这些信息你的朋友是很难知道这幅画具体是什么样子的，因为他不知道大圆圈和正方形具体在页面的什么位置，是正方形在圆圈前面呢还是圆圈在正方形的前面。
![](/images/chrome/tellgame.png)
<p align="center">你站在一幅画面前通过电话告诉你朋友画上的内容</p>

渲染网页也是同样的道理，只知道网站的文档流以及每个节点的样式是远远不足以渲染出页面内容的，还需要布局（layout）来计算出每个节点的**几何信息**（geometry）。具体过程是：主线程会遍历刚刚构建的DOM树，根据DOM节点的计算样式计算出一个布局树（layout tree）。布局树上每个节点会有它在页面上的x，y坐标以及盒子大小（bounding box sizes）的具体信息。布局树长得和先前构建的DOM树差不多，不同的是这颗树只有那些可见的（visible）节点信息。举个例子，如果一个节点被设置为了**display:none**，这个节点就是不可见的就不会出现在布局树上面（**visibility:hidden**的节点会出现在布局树上面，你可以思考一下这是为什么）。同样的，如果一个伪元素（pseudo class）节点有诸如`p::before{content:"Hi!"}`这样的内容，它会出现在布局上，而不存在于DOM树上。
![](/images/chrome/layout.png)
<p align="center">主线程会遍历每个DOM tree节点的计算样式信息来生成一棵布局树</p>

即使页面的布局十分简单，布局这个过程都是非常复杂的。例如简单地从上而下展示一个又一个段落，这个过程就很复杂，因为你需要考虑段落中的字体大小以及段落在哪里需要进行换行之类的东西，它们都会影响到段落的大小以及形状，继而影响到接下来段落的布局。
![](/images/chrome/tree.png)
<p align="center">浏览器得考虑段落是不是要换行</p>

CSS可以让元素悬浮（float）到页面的某一边，还可以遮挡住页面溢出的（overflow）元素，还可以改变内容的书写方向，所以单是想一下你就知道布局这个过程是一个十分艰巨和复杂的任务。对于Chrome浏览器，我们有一整个负责布局过程的工程师团队。如果你想知道他们工作的具体内容，他们在[BlinkOn Conference](https://www.youtube.com/watch?v=Y5Xa4H2wtVA)上面的相关讨论被录制了下来，有时间的话你可以去看一下。

## 绘画 - Paint
知道了DOM节点以及它的样式和布局其实还是不足够渲染出页面来。假如你想要重新绘制出一幅画，你知道了画布上每个元素的大小，形状以及位置，可是你还是需要判断你画这些元素的顺序。

![](/images/chrome/drawgame.png)
<p align="center">一个人拿着画笔站在画布前面，在思考着是先画一个圆还是先画一个正方形</p>

举个例子，页面上的某些元素可能设置了**z-index**属性，这样绘画元素的顺序其实就会影响到页面渲染的正确性。

![](/images/chrome/zindex.png)
<p align="center">按照HTML布局的顺序进行页面元素绘制的话，页面是被错误渲染的，因为元素的z-index元素没有被考虑到</p>

在绘画这个步骤中，主线程会遍历之前的到的布局树（layout tree）来生成一系列的绘画记录（paint records）。绘画记录是对绘画过程的注释，例如“首先画背景，然后是文本，最后画矩形”。如果你曾经在canvas画布上有使用过JavaScript绘制元素的经验，你可能会感觉这个过程比较熟悉。

![](/images/chrome/paint.png)
<p align="center">主线程表里布局树来生成绘画记录</p>

## 更新渲染流水线（rendering pipeline）成本是很高的
对于渲染流水线的过程有一个重点内容是要知道的，那就是在流水线的每一步中都要使用到前一步结果来生成新的数据。举个例子，如果布局树有些东西被改变了，文档上那些被影响到的那些部分的绘画顺序是需要重新被生成的。
![](/images/chrome/tree.gif)
<p align="center">DOM+Style，布局以及绘画树按照它们生成的顺序排列</p>

如果你有给页面的元素添加动画（animating），浏览器就不得不在每个渲染帧的间隔中进行着一些列的操作。我们大多数的显示器都是一秒钟刷新页面60次的（60fps）；如果你每个渲染帧都能够在屏幕上移动东西，这些动画对于人眼来说是非常流畅的。然而，如果动画在有丢帧现象出现的话，页面开起来就会“卡顿”。

![](/images/chrome/pagejank1.png)
<p align="center">在时间轴上的动画帧</p>

即使你的渲染操作和屏幕的刷新频率保持一致都好，这些计算是运行在渲染进程的主线程上面的，这就意味着它可能被一些正在运行的JavaScript代码阻塞，因为JavaScript代码也是运行在主线程上面的！

![](/images/chrome/pagejank2.png)
<p align="center">在时间轴上的动画帧，不过有一些帧被JavaScript阻塞了</p>

你可以将JavaScript操作拆分为一些小块然后通过`requestAnimationFrame`这个API把他们放在每个帧中执行。想知道更多关于这方面的信息的话，可以参考[Optimize JavaScript Execution](https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution)。当然你还可以讲你的JavaScript代码放在[WebWorkers](https://www.youtube.com/watch?v=X57mh8tKkgE)中执行来避免它们阻塞主线程。

![](/images/chrome/raf.png)
<p align="center">在带有动画帧的时间轴上运行更小块的JavaScript代码</p>