---
title: 窥探现代浏览器架构-四
tags:
  - Chrome
  - 浏览器
thumbnail: /gallery/thumbnails/chrome.png
categories:
  - 前端
date: 2020-01-08 08:00:50
---

## 前言
本文是笔者对[Mario Kosaka](https://developers.google.com/web/resources/contributors/kosamari)写的[inside look at modern web browser](https://developers.google.com/web/updates/2018/09/inside-browser-part4)系列文章的翻译。这里的翻译不是指直译，而是结合个人的理解将作者想表达的意思表达出来，而且会尽量补充一些相关的内容来帮助大家更好地理解。

## 到达合成器的输入
这篇文章是探究Chrome内部工作原理的**四集系列文章**中的最后一篇了。在上一篇文章中，我们探讨了一下[浏览器渲染页面的过程以及详细了一些关于合成器的知识](prev_blog)，在本篇文章中，我们要看一下当用户在网页上输入内容的时候，合成器做了些什么来保证用户流畅的体验的。

## 从浏览器的角度来看输入事件
当你听到“输入事件这个词”的时候，你可能只会想到用户在文本框中输入内容或者点击了页面的某些区域，可是从浏览器的角度来看的话，输入其实代表着来自于用户的任何手势动作。所以用户滚动页面，触碰屏幕以及移动鼠标等操作都可以作为来自于用户的输入事件。

当用户做了一些诸如触碰屏幕的手势动作时，浏览器进程是第一个可以接收到这个事件的地方。然而浏览器只能知道用户的手势动作发生在什么地方因为标签内的内容是由页面的渲染进程处理的。因此浏览器进程会将事件的累次那个（如`touchstart`）以及事件的坐标发送给渲染进程。为了可以正确地处理这个事件，渲染继承会找到事件的目标对象（target）然后运行这个事件绑定的监听函数（listener）。

![](/images/chrome/input_event.png)
<p align="center">点击事件从浏览器进程路由到渲染进程</p>

## 合成器接收到输入事件
在上一篇文章中，我们查看了合成线程是如何通过合成光栅化后的层来保障流畅的滚动体验的。如果当前的页面没有绑定输入事件，当用户手势事件发生的时候，合成线程完全不需要主线程的参与来新建一个合成帧。可是如果页面有一些事件监听器（event listeners）呢？合成线程是如何判断出这个事件是否要被处理的呢？

## 了解非快速（non-fast）滚动区域
因为运行页面的JavaScript脚本是主线程的工作，所以当一个页面被合成的时候，合成线程会将页面那些拥有事件监听器的区域标记为“非快速滚动区域”（Non-fast Scrollable Region）。知道这个信息后，当有用户事件在这些区域发生时，合成线程会将输入事件发送给主线程来处理。如果输入事件不是发生在这些区域内，合成线程就无须等待主线程就可以新合成一个帧。

![](/images/chrome/nfsr1.png)
<p align="center">非快速滚动区域有用户事件发生时的示意图</p>

### 当你写事件监听器的时候留点心眼
Web开发的一个常见的模式是事件委托（event delegation）。由于事件会冒泡，你可以为顶层的元素绑定一个事件监听函数来作为事件的委托者，这样子节点的事件就可以统一被顶层的元素进程处理了。因此你可能看过或者写过像下面一样的代码：
```javascript
document.body.addEventListener('touchstart', event => {
  if (event.target === area) {
    event.preventDefault()
  }
})
```
因为你写一个事件监听函数就可以服务到所有的元素，乍一看这种写法还是挺实惠的。可是，如果你从浏览器的角度去看一下这段代码，你会发现上面给body绑定了事件监听函数后其实是将整个页面都标记为一个非快速滚动区域了，这就意味着即使你页面的某些区域压根就不在乎是不是有用户输入，当用户输入事件发生时，合成线程每次都会告知主线程并且会等待主线程处理完。因此这种情况下合成事件的处理流畅滚动的能力其实就没什么用处了。

![](/images/chrome/nfsr2.png)
<p align="center">当整个页面都是非快速滚动区域时页面的事件处理示意图</p>

为了减轻这种情况的发生，您可以为事件监听器传递passive：true选项。 这个选项会告诉浏览器您仍要在主线程中侦听事件，可是合成线程也可以继续合成新的帧。
```javascript
document.body.addEventListener('touchstart', event => {
    if (event.target === area) {
        event.preventDefault()
    }
 }, {passive: true});
```

## 查找事件的目标对象（event target）
当合成线程向主线程发送输入事件时，主线程第一件做的事是通过命中测试（hit test）去找到事件的目标对象。具体的命中测试的流程是遍历在渲染流水线中生成的绘画记录（paint records）来找到用户事件出现的x, y坐标上面描绘的对象是哪个。

![](/images/chrome/hittest.png)
<p align="center">主线程通过查找绘画记录来确定在x，y坐标上的是哪个对象</p>

## 最小化发送给主线程的事件
上前面的文章中我们有讨论过一般的显示器的刷新频率是一秒钟60次以及我们如果通过和屏幕刷新频率保持一致来实现页面的平滑动画效果。对于输入来说，通常的触摸屏一秒钟会触发60到120次点击事件，而典型的鼠标则会每秒传递100次事件，输入事件的频率其实远远高于我们的屏幕刷新能力。

如果每秒将诸如`touchmove`之类的连续事件发送到主线程120次，则与屏幕刷新的速度相比，它可能会触发大量的点击测试和JavaScript执行。

![](/images/chrome/rawevents.png)
<p align="center">事件淹没了屏幕刷新的时间轴，导致页面很卡顿</p>

为了最大程度地减少对主线程的过多调用，Chrome会合并连续事件（例如wheel，mousewheel，mousemove，pointermove，touchmove），并将调度延迟到下一个requestAnimationFrame之前。

任何诸如keydown，keyup，mouseup，mousedown，touchstart和touchend的分散事件都会被立即派送给主线程。

## 使用getCoalesecedEvents来获取帧内（intra-frame）事件
对于大多数的web应用来说，合并事件应该已经足够用来提供很好的用户体验了，然而，如果你正在构建的是一个画图应用的话，因为合并事件的存在可能会使你在页面画的线不够顺畅和连续。在这种情景下，你可以使用鼠标事件的`getCoalescedEvents`来获取关于被合成的那些事件的详细信息。

![](/images/chrome/getCoalescedEvents.png)
<p align="center">左边是顺畅的触摸手势，右边是事件合成后不那么连续的手势</p>

```javascript
window.addEventListener('pointermove', event => {
    const events = event.getCoalescedEvents();
    for (let event of events) {
        const x = event.pageX;
        const y = event.pageY;
        // draw a line using x and y coordinates.
    }
});
```

## 下一步

