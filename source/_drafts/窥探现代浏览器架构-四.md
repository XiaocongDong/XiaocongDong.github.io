---
title: 窥探现代浏览器架构-四
tags:
  - Chrome
  - 浏览器
thumbnail: /gallery/thumbnails/chrome.png
categories:
  - 前端
date: 2020-01-08 08:00:50
---

## 前言
本文是笔者对[Mario Kosaka](https://developers.google.com/web/resources/contributors/kosamari)写的[inside look at modern web browser](https://developers.google.com/web/updates/2018/09/inside-browser-part4)系列文章的翻译。这里的翻译不是指直译，而是结合个人的理解将作者想表达的意思表达出来，而且会尽量补充一些相关的内容来帮助大家更好地理解。

## 到达合成器的输入
这篇文章是探究Chrome内部工作原理的**四集系列文章**中的最后一篇了。在上一篇文章中，我们探讨了一下[浏览器渲染页面的过程以及详细了一些关于合成器的知识](prev_blog)，在本篇文章中，我们要看一下当用户在网页上输入内容的时候，合成器做了些什么来保证用户流畅的体验的。

## 从浏览器的角度来看输入事件
当你听到“输入事件这个词”的时候，你可能只会想到用户在文本框中输入内容或者点击了页面的某些区域，可是从浏览器的角度来看的话，输入其实代表着来自于用户的任何手势动作。所以用户滚动页面，触碰屏幕以及移动鼠标等操作都可以作为来自于用户的输入事件。

当用户做了一些诸如触碰屏幕的手势动作时，浏览器进程是第一个可以接收到这个事件的地方。然而浏览器只能知道用户的手势动作发生在什么地方因为标签内的内容是由页面的渲染进程处理的。因此浏览器进程会将事件的累次那个（如`touchstart`）以及事件的坐标发送给渲染进程。为了可以正确地处理这个事件，渲染继承会找到事件的目标对象（target）然后运行这个事件绑定的监听函数（listener）。

![](/images/chrome/input_event.png)
<p align="center">点击事件从浏览器进程路由到渲染进程</p>

## 合成器接收到输入事件
在上一篇文章中，我们查看了合成线程是如何通过合成光栅化后的层来保障流畅的滚动体验的。如果当前的页面没有绑定输入事件，当用户手势事件发生的时候，合成线程完全不需要主线程的参与来新建一个合成帧。可是如果页面有一些事件监听器（event listeners）呢？合成线程是如何判断出这个事件是否要被处理的呢？

## 了解非快速（non-fast）滚动区域
因为运行页面的JavaScript脚本是主线程的工作，所以当一个页面被合成的时候，合成线程会将页面那些拥有事件监听器的区域标记为“非快速滚动区域”（Non-fast Scrollable Region）。知道这个信息后，当有用户事件在这些区域发生时，合成线程会将输入事件发送给主线程来处理。如果输入事件不是发生在这些区域内，合成线程就无须等待主线程就可以新合成一个帧。

![](/images/chrome/nfsr1.png)
<p align="center">非快速滚动区域有用户事件发生时的示意图</p>

### 当你写事件监听器的时候留点心眼
Web开发的一个常见的模式是事件委托（event delegation）。由于事件会冒泡，你可以为顶层的元素绑定一个事件监听函数来作为事件的委托者，这样子节点的事件就可以统一被顶层的元素进程处理了。因此你可能看过或者写过像下面一样的代码：
```javascript
document.body.addEventListener('touchstart', event => {
  if (event.target === area) {
    event.preventDefault()
  }
})
```
因为你写一个事件监听函数就可以服务到所有的元素，乍一看这种写法还是挺实惠的。可是，如果你从浏览器的角度去看一下这段代码，你会发现上面给body绑定了事件监听函数后其实是将整个页面都标记为一个非快速滚动区域了，这就意味着即使你页面的某些区域压根就不在乎是不是有用户输入，当用户输入事件发生时，合成线程每次都会告知主线程并且会等待主线程处理完。因此这种情况下合成事件的处理流畅滚动的能力其实就没什么用处了。

![](/images/chrome/nfsr2.png)
<p align="center">当整个页面都是非快速滚动区域时页面的事件处理示意图</p>

为了减轻这种情况的发生，您可以为事件监听器传递passive：true选项。 这个选项会告诉浏览器您仍要在主线程中侦听事件，可是合成线程也可以继续合成新的帧。
```javascript
document.body.addEventListener('touchstart', event => {
    if (event.target === area) {
        event.preventDefault()
    }
 }, {passive: true});
```

## 检查某个事件不是是可以被取消的（cancelable）
