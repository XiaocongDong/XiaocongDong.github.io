{"pages":[{"title":"about","text":"大家好，我是董小聪。我2016年毕业于北京邮电大学通信工程本科专业。大学前三年过得浑浑噩噩，直到大三才主动去学习编程。刚开始做的是网络虚拟化相关的工作，在思科中国实习的时候参与了OpenDaylight控制器的研发，用的是Java。后面大学毕业去了美国硅谷工作了一年，在那一年里做了很多大大小小的项目，写过NodeJS也玩过Python。后面却鬼使神差回国做了前端，现在正努力成为一个全面的全栈开发。 我个人觉得其实没有太大必要区分前端后端，我更看重的是Software Engineer这个称号。我个人认为软件工程师就是利用程序去实现和创造一些有价值的东西，程序员的核心价值并不是他掌握了多少语言，能够使用多少工具，而是他自己分析问题和解决问题的能力，或者说系统设计能力(System Design)。 我的梦想是通过自己的努力去改变别人，这就是改变世界。","link":"/about/index.html"}],"posts":[{"title":"JavaScript小技巧 - 数组篇","text":"本文整理了一些在日常工作可以用到的JavaScript数组小技巧 去重巧用Set特性 1const arr = [1, 2, 2, 3, 4, 7, 7]2const uniqueArr = [...new Set(arr)]3console.log(uniqueArr)4// [1, 2, 3, 4, 7] 某一个位置插入元素改变原数组 1const arr = [1, 2, 3, 5, 6, 7]2arr.splice(3, 0, 4)3console.log(arr)4// [1, 2, 3, 4, 5, 6, 7] 不改变原数组 1const arr = [1, 2, 4, 5]2const indexNeededToInsert = 23const newArr = [...arr.slice(0, indexNeededToInsert), 3, ...arr.slice(indexNeededToInsert)]45console.log(newArr)6// [1, 2, 3, 4, 5]7console.log(arr)8// [1, 2, 4, 5] 删除某一个位置的元素不改变原数组 1const arr = [1, 2, 3, 4, 5]2const indexToBeRemoved = 33const filteredArr = arr.filter((_, index) =&gt; index !== indexToBeRemoved)4console.log(filteredArr)5// [1, 2, 3, 5]6console.log(arr)7// [1, 2, 3, 4, 5] 改变原数组 1const arr = [1, 2, 3, 4, 5]2const indexToBeRemoved = 33arr.splice(indexToBeRemoved, 1)4console.log(arr)5// [1, 2, 3, 5] 获取数组最后一个元素改变原数组 1const arr = [1, 2, 3, 4, 5]2const lastElement = arr.pop()3console.log(lastElement)4// 55console.log(arr)6// [1, 2, 3, 4] 不改变原数组 1const arr = [1, 2, 3, 4, 5]2const lastElement = arr.slice(-1)[0]3console.log(lastElement)4// 55console.log(arr)6// [1, 2, 3, 4, 5] slice第一个参数如果是负数表示从后面开始数起的第几个元素，-1表示倒数第一个元素。 清空数组1const arr = [1, 2, 3, 4, 5]2arr.length = 03console.log(arr)4// []5console.log(arr[0])6// undefined 生成一定长度的数组1const newArr = new Array(10)2console.log(newArr)3// [ &lt;10 empty items&gt; ] 两个数组的交集1const arr1 = [1, 2, 3, 4]2const arr2 = [2, 3]3const intersectedArr = arr1.filter(item1 =&gt; arr2.includes(item1))4console.log(intersectedArr)5// [2, 3] 合并多个数组1const arr1 = [1, 2, 3]2const arr2 = [4, 5, 6]3const arr3 = [7, 8, 9]4const mergedArr = [...arr1, ...arr2, ...arr3]5console.log(mergedArr)6// [1, 2, 3, 4, 5, 6, 7, 8, 9] 移除数组的虚假(falsy)值1const mixedArr = [0, “blue”, “”, NaN, 9, true, undefined, “white”, false]2const trueArr = mixedArr.filter(Boolean);3console.log(trueArr)4// [“blue”, 9, true, “white”] 求和1const nums = [1, 2, 3, 4, 5]2const sum = nums.reduce((currSum, num) =&gt; currSum + num)3console.log(sum)4// 15","link":"/2019/12/11/JavaScript%E5%B0%8F%E6%8A%80%E5%B7%A7-%E6%95%B0%E7%BB%84%E7%AF%87/"},{"title":"几个提高效率的console APIs","text":"console.log我相信写过JavaScript人一定都有接触过，它可谓是我们debug的灵丹妙药。可是除了log方法，你知道console还有很多可以帮你快速提高代码debug效率（逼格）的方法吗？ console.log | console.info | console.debug | console.warn | console.error使用场景输出不同类型（level）的内容。 用法这几个方法用起来都差不多，只不过输出结果可能会存在颜色上的区别：注意console.debug如果没有输出可以将log level中的verbose选上（chrome）: 替换字符串 - string substitution使用场景呈现输出时的上下文信息（context）。 用法现在支持以下替换字符串： 替换字符串 描述 %o 或者 %O JavaScript 对象，可以是整数、字符串或是 JSON 数据。 %d或者%i 整数。 %s 字符串。 %f 浮点数。 为输出添加CSS样式使用场景让内容更加结构化而且可以极大地提高逼格。 用法使用%c为某部分的输出内容定义样式： console.assert使用场景条件性输出。有些信息你可能只想在某些条件不满足的时候才进行输出，这个时候你可以用这种方法而不是加多个if判断。 用法1console.assert(condition, ...data) 注意只有condition是false的时候data才会被输出： console.table使用情景以表格的形式输出数据。这个方法最适用的场景我觉得是对象的数组，因为他可以让你一目了然地看到数组内对象各个属性的值。 用法 console.group使用情景当你有大量的内容要输出到界面上时，可以使用console.group方法为输出的内容添加一定的缩进来更好地整理这些内容。 用法这里要记住的是每个group都需要手动地调用groupEnd来退出。 console.trace使用情景追踪函数的执行栈。当你想知道一个函数具体是怎样被调用的时，可以使用console.trace这个函数去追踪它的执行栈。 用法 console.count使用场景统计代码的执行次数。 用法你还可以使用label去区分不同的统计类型： console.time使用场景记录代码执行的耗时，以毫秒（ms）为单位。 用法1console.time(timerName) 参考网站 https://developer.mozilla.org/en-US/docs/Web/API/Console https://medium.com/javascript-in-plain-english/mastering-js-console-log-like-a-pro-1c634e6393f9","link":"/2019/12/23/%E5%87%A0%E4%B8%AA%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84consoleAPIs/"},{"title":"详解ECMAScript2019/ES10新属性","text":"每年都有一些新的属性进入ECMA262标准，今年发布的ECMAScript2019/ES10同样也有很多新的特性，本文将会挑选一些普通开发者会用到的新属性进行深入的解读。 Array.prototype.flat() The flat() method creates a new array with all sub-array elements concatenated into it recursively up to the specified depth. – MDN 简单来说flat这个函数就是按照一定的深度depth将一个深层次嵌套的数组拍扁, 例子: 1const nestedArr = [1, 2, [3, 4, [5, 6, [7, [8], 9]]], 10]2console.log(nestedArr.flat())3// [1, 2, 3, 4, [5, 6, [7, [8], 9]], 10]4console.log(nestedArr.flat(2))5// [1, 2, 3, 4, 5, 6, [7, [8], 9], 10]6console.log(nestedArr.flat(3))7// [1, 2, 3, 4, 5, 6, 7, [8], 9, 10]8console.log(nestedArr.flat(4))9// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]10console.log(nestedArr.flat(Infinity))11// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 由上面的例子可以看出flat会按照指定的深度depth将一个数组扁平化，如果需要将数组完全拍扁变成一维数组，则指定depth为无限大，即是Infinity，相反如果不指定深度，其默认值是1。 Array.prototype.flatMap() The flatMap() method first maps each element using a mapping function, then flattens the result into a new array. It is identical to a map() followed by a flat() of depth 1, but flatMap() is often quite useful, as merging both into one method is slightly more efficient. – MDN 简单来说flatMap等于一个数组先调用完map函数再调用flat函数将其扁平化，扁平化的深度固定为1，先通过一个简单的例子感受一下: 1const myArr = [1, 2, 3]2myArr3 .map(n =&gt; [n * n]) // [[1], [4], [9]]4 .flat() // [1, 4, 9]56// 用flatMap可以一步到位7myArr.flatMap(n =&gt; [n * n]) // [1, 4, 9] 从上面的例子来看flatMap如果只是将flat和map做了一个简单的组合好像可有可无，其实不然，flatMap有个强大的功能是可以在map的时候添加和删除元素，这个无论是map还是filter都没有这个功能。 要想删除某一个元素只需要在mapper函数里面返回一个空的数组[], 而增加元素只需在mapper函数里面返回一个长度大于1的数组，具体可以看下面的例子： 1// 假如我们想要删除掉原数组里面所有的负数，同时将单数转换为一个复数和12const a = [5, 4, -3, 20, 17, -33, -4, 18]3// |\\ \\ x | | \\ x x |4// [4,1, 4, 20, 16,1, 18]5a.flatMap(n =&gt;6 (n &lt; 0) ? []: // 删除负数7 (n % 2 == 0) ? [n] : // 保留复数8 [n - 1, 1] // 单数变为一个复数和19)10// [4, 1, 4, 20, 20, 16, 1, 18] Object.fromEntries() The Object.fromEntries() method transforms a list of key-value pairs into an object. – MDN fromEntries方法将一个iterable对象返回的一系列键值对(key-value pairs)转换为一个object。先看一个简单的例子理解一下: 1// key-value pairs数组2const entriesArr = [['k1', 1], ['k2', 2]]3console.log(Object.fromEntries(entriesArr)4// {k1: 1, k2: 2}56const entriesMap = new Map([7 ['k1', 1],8 ['k2', 2]9]) // {\"k1\" =&gt; 1, \"k2\" =&gt; 2}10console.log(Object.fromEntries(entriesMap))11// {k1: 1, k2: 2} 再来看一个自定义的iterable对象例子深入理解一下: 1const iteratorObj = {2 [Symbol.iterator]: function () {3 const entries = [['k1', 1], ['k2', 2]]4 let cursor = 056 return {7 next() {8 const done = entries.length === cursor9 10 return {11 value: done ? undefined : entries[cursor++],12 done13 }14 }15 }16 }17}18Object.fromEntries(iteratorObj) // {k1: 1, k2: 2} 这个方法有一个用途就是对object的key进行filter，举个例子: 1const studentMap = {2 student1: {grade: 80},3 student2: {grade: 50},4 student3: {grade: 100}5}6const goodStudentMap = Object.fromEntries(7 Object8 .entries(studentMap)9 .filter(([_, meta]) =&gt; meta.grade &gt;= 60)10)11console.log(goodStudentMap)12// {student1: {grade: 80}, student3: {grade: 100}} String.prototype.trimStart这个方法很简单，就是返回一个将原字符串开头的空格字符去掉的新的字符串，例子: 1const greeting = ' Hello world! '2console.log(greeting.trimStart())3// 'Hello world! ' 这个方法还有一个别名函数，叫做trimLeft，它们具有一样的功能。 String.prototype.trimEnd这个方法和trimStart类似，只不过是将原字符串结尾的空格字符去掉，例子: 1const greeting = ' Hello world! '2console.log(greeting.trimEnd())3// ' Hello world!' 这个方法也有一个别名函数，叫做trimRight, 它们也具有一样的功能。 Symbol.prototype.description The read-only description property is a string returning the optional description of Symbol objects. – MDN ECMAScript2019给Symbol对象添加了一个可选的description属性，这个属性是个只读属性，看看例子: 1console.log(Symbol('desc').description)2// desc3console.log(Symbol.for('desc').description)4// desc56// 一些内置的Symbol也有这个属性7console.log(Symbol.iterator.description)8// Symbol.iterator910// 如果初始化时没有带description，这个属性会返回一个undefined，因为这样才说这个属性是可选的11console.log(Symbol().description)12// undefined1314// 这个属性是只读的，不能被设置15Symbol.iterator.description = 'mess it'16console.log(Symbol.iterator.description)17// Symbol.iterator 这个新的属性只要是为了方便开发者调试，不能通过比较两个Symbol对象的description来确定这两个Symbol是不是同一个Symbol: 1var s1 = Symbol(\"desc\")2var s2 = Symbol(\"desc\")3console.log(s1.description === s2.description)4// true5console.log(s1 === s2)6// false try catch optional bindingECMAScript2019之后，你写try…catch时如果没必要时可以不用声明error： 1// ECMAScript2019之前，你一定要在catch里面声明error，否则会报错2try {3 ...4} catch (error) {56}7// 可是有时候，你确实用不到这个error对象，于是你会写这样的代码8try {9 ...10} catch (_) {11 ...12}1314// ECMAScript2019后，你可以直接这样写了15try {16 ...17} catch {18 ...19} 虽然这个新属性可以让你省略掉error，可是我觉得开发者应该避免使用这个属性，因为在我看来所有的错误都应该被处理，至少应该被console.error出来，否则可能会有一些潜在的bug，举个例子： 1let testJSONObj2try {3 testJSONObj = JSON.prase(testStr)4} catch {5 testJSONObj = {}6}7console.log(testJSONObj) 以上代码中无论testStr是不是一个合法的JSON字符串，testJSONObj永远都是一个空对象，因为JSON.parse函数名写错了，而你又忽略了错误处理，所以你永远不会知道这个typo。 稳定的排序 Array.prototype.sortECMAScript2019后Array.sort一定是个稳定的排序。什么是稳定排序？所谓的稳定排序就是：假如没排序之前有两个相同数值的元素a[i]和a[j]，而且i在j前面，即i &lt; j，经过排序后元素a[i]依然排在a[j]元素的前面，也就是说稳定的排序不会改变原来数组里面相同数值的元素的先后关系。看个例子： 1var users = [2 {name: 'Sean', rating: 14},3 {name: 'Ken', rating: 14},4 {name: 'Jeremy', rating: 13}5]6users.sort((a, b) =&gt; a.rating - b.rating)7// 非稳定的排序结果可能是8// [9// {name: 'Jeremy', rating: 13}, 10// {name: 'Ken', rating: 14}, 11// {name: 'Sean', rating: 14}12// ]13// 虽然Sean和Ken具有同样的rating，可是非稳定的排序不能保证他们两个的顺序在排序后保持不变1415// ECMAScript2019后，Array.sort将是一个稳定的排序，也就是说它可以保证Sean和Ken两个人的顺序在排序后不变16// [17// {name: 'Jeremy', rating: 13}, 18// {name: 'Sean', rating: 14}, 19// {name: 'Ken', rating: 14}20// ] 改进Function.prototype.toString()ECMAScript2019之前，调用function的toString方法会将方法体里面的空格字符省略掉，例如: 1function hello() {2 console.log('hello word')3}45console.log(hello.toString())6//'function hello() {\\nconsole.log('hello word')\\n}' ECMAScript2019之后，要求一定要返回函数源代码（保留空格字符）或者一个标准的占位符例如native code，所以ECMAScript2019之后，以上的输出会变为： 1console.log(hello.toString())2//\"function hello() {3// console.log('hello word')4//}\"","link":"/2019/12/05/ECMAScript2019-ES10%E6%96%B0%E5%B1%9E%E6%80%A7/"},{"title":"窥探现代浏览器架构(一)","text":"前言本文是笔者对Mario Kosaka写的inside look at modern web browser系列文章的翻译。这里的翻译不是指直译，而是结合个人的理解将作者想表达的意思表达出来，而且会尽量补充一些相关的内容来帮助大家更好地理解。 CPU，GPU，内存和多进程架构在这个4集系列教程里面，我将会从Chrome浏览器的高层次架构（high-level architecture）开始说起，一直深入讲到页面渲染流水线（rendering pipeline）的具体细节。如果你想知道浏览器是怎么把你编写的代码转变成一个可用的网站，或者你不知道为什么一些特定的代码写法可以提高网站的性能的，那你就来对地方了，这篇文章就是为你准备的。 作为本系列文章的第一篇，我们会先了解一些关键的计算机术语以及Chrome浏览器的多进程架构。 计算机的核心 - CPU和GPU要想理解浏览器的运行环境，我们先要搞明白一些计算机组件以及它们的作用。 CPU首先我们要说的是计算机的大脑 - CPU（Central Processing Unit）。CPU是计算机里面的一块芯片，上面有一个或者多个核心（core）。我们可以把CPU的一个核心（core）比喻成一个办公室工人，他功能强大，上知天文下知地理，琴棋书画无所不能，它可以串行地一件接着一件处理交给它的任务。很久之前的时候大多数CPU只有一个核心，不过在现在的硬件设备上CPU通常会有多个核心，因为多核心CPU可以大大提高手机和电脑的运算能力。 四个CPU核心愉快地在各自工位上一个接着一个地处理交给它们的任务 GPU图形处理器 - 或者说GPU（Graphics Processing Unit）是计算机的另外一个重要组成部分。和功能强大的CPU核心不一样的是，单个GPU核心只能处理一些简单的任务，不过它胜在数量多，单片GPU上会有很多很多的核心可以同时工作，也就是说它的并行计算能力是非常强的。图形处理器（GPU）顾名思义一开始就是专门用来处理图形的，所以在说到图形使用GPU（using）或者GPU支持（backed）时，人们就会联想到图形快速渲染或者流畅的用户体验相关的概念。最近几年来，随着GPU加速概念的流行，在GPU上单独进行的计算也变得越来越多了。 每个GPU核心手里只有一个扳手，这就说明它的能力是非常有限的，可是它们人多啊！ 当你在手机或者电脑上打开某个应用程序的时候，背后其实是CPU和GPU支撑着这个应用程序的运行。通常来说，你的应用要通过操作系统提供的一些机制才能跑在CPU和GPU上面。 计算机的三层架构，最下层是硬件机器，操作系统夹在中间，最上层是运行的应用 在进程和线程上执行程序在深入到浏览器的架构之前我们还得了解一下进程（process）和线程（thread）的相关概念。进程可以看成正在被执行的应用程序（executing program）。而线程是跑在进程里面的，一个进程里面可能有一个或者多个线程，这些线程可以执行任何一部分应用程序的代码。 进程就像一个大鱼缸，而线程就是浴缸里面畅游的鱼儿 当你启动一个应用程序的时候，操作系统会为这个程序创建一个进程同时还为这个进程分配一片私有的内存空间，这片空间会被用来存储所有程序相关的数据和状态。当你关闭这个程序的时候，这个程序对应的进程也会随之消失，进程对应的内存空间也会被操作系统释放掉。 进程使用系统分配的内存空间去存储应用的数据 有时候为了满足功能的需要，创建的进程会叫系统创建另外一些进程去处理其它任务，不过新建的进程会拥有全新的独立的内存空间而不是和原来的进程共用内存空间。如果这些进程需要通信，它们要通过IPC机制（Inter Process Communication）来进行。很多应用程序都会采取这种多进程的方式来工作，因为进程和进程之间是互相独立的它们互不影响，换句话来书，如果其中一个工作进程（worker process）挂掉了其他进程不会受到影响，而且挂掉的进程还可以重启。 不同的进程通过IPC来通信 浏览器架构那么浏览器是怎么使用进程和线程来工作的呢？其实大概可以分为两种架构，一种是单进程架构，也就是只启动一个进程，这个进程里面有多个线程工作。第二种是多进程架构，浏览器会启动多个进程，每个进程里面有多个线程，不同进程通过IPC进行通信。 单进程和多进程浏览器的架构图 上面的图表架构其实包含了浏览器架构的具体实现了，在现实中其实并没有一个大家都遵循的浏览器实现标准，所以不同浏览器的实现方式可能会完全不一样。 为了更好地在本系列文章中展开论述，我们主要讨论最新的Chrome浏览器架构，它采用的是多进程架构，以下是架构图： Chrome的多进程架构图，多个渲染进程的卡片（render process）是用来表明Chrome会为每一个tab创建一个渲染进程。 Chrome浏览器会有一个浏览器进程（browser process），这个进程会和其他进程一起协作来实现浏览器的功能。对于渲染进程（renderer process），Chrome会尽可能为每一个tab甚至是页面里面的每一个iframe都分配一个单独的进程。 各个进程如何分工合作呢？以下是各个进程具体负责的工作内容： 进程 负责的工作 Browser 负责浏览器的“Chrome”部分， 包括导航栏，书签， 前进和后退按钮。同时这个进程还会控制那些我们看不见的部分，包括网络请求的发送以及文件的读写。 Renderer 负责tab内和网页展示相关的所有工作。 Plugin 控制网页使用的所有插件，例如flash插件。 GPU 负责独立于其它进程的GPU任务。它之所以被独立为一个进程是因为它要处理来自于不同tab的渲染请求并把它在同一个界面上画出来。 不同的进程负责浏览器不同部分的界面内容 除了上面列出来的进程，Chrome还有很多其他进程在工作，例如扩展进程（Extension Process）和工具进程（utility process）。如果你想看一下你的Chrome浏览器现在有多少个进程在跑可以点击浏览器右上角的更多按钮，选择更多工具和任务管理器：在弹出的窗口里面你会看到正在工作的进程列表，以及每个进程使用的CPU和内存状况。 Chrome多进程架构的好处那么为什么Chrome会采取多进程架构工作呢？ 其中一个好处是多进程可以使浏览器具有很好的容错性。对于大多数简单的情景来说，Chrome会为每个tab单独分配一个属于它们的渲染进程（render process）。举个例子，假如你有三个tab，你就会有三个独立的渲染进程。当其中一个tab的崩溃时，你可以随时关闭这个tab并且其他tab不受到影响。可是如果所有的tab都跑在同一个进程的话，它们就会有连带关系，一个挂全部挂。 不同的tab会有不同的渲染进程来负责 Chrome采用多进程架构的另外一个好处就是可以提供安全性和沙盒性（sanboxing）。因为操作系统可以提供方法让你限制每个进程拥有的能力，所以浏览器可以让某些进程不具备某些特定的功能。例如，由于tab渲染进程可能会处理来自用户的随机输入，所以Chrome限制了它们对系统文件随机读写的能力。 不过多进程架构也有它不好的地方，那就是进程的内存消耗。由于每个进程都有各自独立的内存空间，所以它们不能像存在于同一个进程的线程那样共用内存空间，这就造成了一些基础的架构（例如V8 JavaScript引擎）会在不同进程的内存空间同时存在的问题，这些重复的内容会消耗更多的内存。所以为了节省内存，Chrome会限制被启动的进程数目，当进程数达到一定的界限后，Chrome会将访问同一个网站的tab都放在一个进程里面跑。 节省更多的内存 - Chrome的服务化同样的优化方法也可以被使用在浏览器进程（browser process）上面。Chrome浏览器的架构正在发生一些改变，目的是将和浏览器本身（Chrome）相关的部分拆分为一个个不同的服务，服务化之后，这些功能既可以放在不同的进程里面运行也可以合并为一个单独的进程运行。 这样做的主要原因是让Chrome在不同性能的硬件上有不同的表现。当Chrome运行在一些性能比较好的硬件时，浏览器进程相关的服务会被放在不同的进程运行以提高系统的稳定性。相反如果硬件性能不好，这些服务就会被放在同一个进程里面执行来减少内存的占用。其实在这次架构变化之前，Chrome在Android上面已经开始采取类似的做法了。 Chrome将浏览器相关的服务放在同一个进程里面运行和放在不同的进程运行的区别 单帧渲染进程 - 网站隔离（Site Isolation）网站隔离（Site Isolation）是最近Chrome浏览器启动的功能，这个功能会为网站内不同站点的iframe分配一个独立的渲染进程。之前说过Chrome会为每个tab分配一个单独的渲染进程，可是如果一个tab只有一个进程的话不同站点的iframe都会跑在这个进程里面，这也意味着它们会共享内存，这就有可能会破坏同源策略。同源策略是浏览器最核心的安全模型，它可以禁止网站在未经同意的情况下去获取另外一个站点的数据，因此绕过同源策略是很多安全攻击的主要目的。而进程隔离（proces isolation）是隔离网站最好最有效的办法了。再加上CPU存在Meltdown和Spectre的隐患，网站隔离变得势在必行。因此在Chrome 67版本之后，桌面版的Chrome会默认开启网站隔离功能，这样每一个跨站点的iframe都会拥有一个独立的渲染进程。 网站隔离功能会让跨站的iframe拥有独立的进程 网站隔离技术汇聚了我们工程师好几年的研发努力，它其实远远没有想象中那样只是为不同站点的iframe分配一个独立的渲染进程那么简单，因为它从根本上改变了各个iframe之间的通信方式。网站隔离后，对于有iframe的网站，当用户打开右边的devtool时，Chrome浏览器其实要做很多幕后工作才能让开发者感觉不出这和之前的有什么区别，这其实是很难实现的。对于一些很简单的功能，例如在devtool里面用Ctrl + F键在页面搜索某个关键词，Chrome都要遍历多个渲染进程去完成。所以我们的浏览器工程师在网站隔离这个功能发布后都感叹这是一个里程碑式的成就。 总结在本篇文章中，我们探讨了浏览器高层次的架构设计以及多进程架构的带来的好处。同时我们还讨论了服务化和网站隔离这些和浏览器多进程架构息息相关的技术。在下一篇文章中我们要开始深入了解这些进程和线程是如何呈现我们的网站页面的了。","link":"/2019/12/25/%E7%AA%A5%E6%8E%A2%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84-%E4%B8%80/"},{"title":"窥探现代浏览器架构(二)","text":"前言本文是笔者对Mario Kosaka写的inside look at modern web browser系列文章的翻译。这里的翻译不是指直译，而是结合个人的理解将作者想表达的意思表达出来，而且会尽量补充一些相关的内容来帮助大家更好地理解。 导航的时候都发生了什么这篇文章是探究Chrome内部工作原理的四集系列文章中的第二篇，在上一篇文章中我们探讨了不同进程或者线程是如何负责浏览器各个不同部分的工作的。在这篇文章中，我们将会深入了解每个进程和线程是如何沟通协作来为我们呈现出网站内容的。 让我们来看一个用户浏览网页最简单的情景：你在浏览器导航栏里面输入一个URL然后按下回车键，浏览器接着会从互联网上获取相关的数据并把网页展示出来。在本篇文章中，我们将会重点关注这个简单场景中网站数据请求以及浏览器在呈现网页之前做的准备工作 - 也就是导航（navigation）的过程。 一切都从浏览器进程开始我们在上一篇文章CPU，GPU，内存和多进程架构中提到，浏览器中tab外面发生的一切都是由浏览器进程（browser process）控制的。浏览器进程有很多负责不同工作的线程（worker thread），其中包括绘制浏览器顶部按钮和导航栏输入框等组件的UI线程（UI thread）、管理网络请求的网络线程（network thread）、以及控制文件读写的存储线程（storage thread）等。当你在导航栏里面输入一个URL的时候，其实就是UI线程在处理你的输入。 UI，网络和存储线程都是属于浏览器进程的 一次简单的导航第一步：处理输入当用户开始在导航栏上面输入内容的时候，UI线程（UI thread）做的第一件事就是询问：“你输入的字符串是一些搜索的关键词（search query）还是一个URL地址呢？”。因为对于Chrome浏览器来说，导航栏的输入既可能是一个可以直接请求的域名还可能是用户想在搜索引擎（例如Google）里面搜索的关键词信息，所以当用户在导航栏输入信息的时候UI线程要进行一系列的解析来判定是将用户输入发送给搜索引擎还是直接请求你输入的站点资源。 UI线程在询问输入的字符串是搜索关键词还是一个URL 第二步：开始导航当用户按下回车键的时候，UI线程会叫网络线程（network thread）初始化一个网络请求来获取站点的内容。这时候tab上会展示一个提示资源正在加载中的旋转圈圈，而且网络线程会进行一系列诸如DNS寻址以及为请求建立TLS连接的操作。 UI线程告诉网络线程跳转到mysite.com 这时如果网络线程收到服务器的HTTP 301重定向响应，它就会告知UI线程进行重定向然后它会再次发起一个新的网络请求。 第三步：读取响应网络线程在收到HTTP响应的主体（payload）流（stream）时，在必要的情况下它会先检查一下流的前几个字节以确定响应主体的具体媒体类型（MIME Type）。响应主体的媒体类型一般可以通过HTTP头部的Content-Type来确定，不过Content-Type有时候会缺失或者是错误的，这种情况下浏览器就要进行MIME类型嗅探来确定响应类型了。MIME类型嗅探并不是一件容易的事情，你可以从Chrome的源代码的注释来了解不同浏览器是如何根据不同的Content-Type来判断出主体具体是属于哪个媒体类型的。 响应的头部有Content-Type信息，而响应的主体有真实的数据 如果响应的主体是一个HTML文件，浏览器会将获取的响应数据交给渲染进程（renderer process）来进行下一步的工作。如果拿到的响应数据是一个压缩文件（zip file）或者其他类型的文件，响应数据就会交给下载管理器（download manager）来处理。 网络线程在询问响应的数据是不是来自安全源的HTML文件 网络线程在把内容交给渲染进程之前还会对内容做SafeBrowsing检查。如果请求的域名或者响应的内容和某个已知的病毒网站相匹配，网络线程会给用户展示一个警告的页面。除此之外，网络线程还会做CORB（Cross Origin Read Blocking）检查来确定那些敏感的跨站数据不会被发送至渲染进程。 第四步：寻找一个渲染进程（renderer process）在网络线程做完所有的检查后并且能够确定浏览器应该导航到该请求的站点，它就会告诉UI线程所有的数据都已经被准备好了。UI线程在收到网络线程的确认后会为这个网站寻找一个渲染进程（renderer process）来渲染界面。 网络线程告诉UI线程去寻找一个渲染进程来渲染界面 由于网络请求可能需要长达几百毫秒的时间才能完成，为了缩短导航需要的时间，浏览器会在之前的一些步骤里面做一些优化。例如在第二步中当UI线程发送URL链接给网络线程后，它其实已经知晓它们要被导航到哪个站点了，所以在网络线程干活的时候，UI线程会主动地为这个网络请求启动一个渲染线程。如果一切顺利的话（没有重定向之类的东西出现），网络线程准备好数据后页面的渲染进程已经就准备好了，这就节省了新建渲染进程的时间。不过如果发生诸如网站被重定向到不同站点的情况，刚刚那个渲染进程就不能被使用了，它会被摒弃，一个新的渲染进程会被启动。 第五步：提交（commit）导航到这一步的时候，数据和渲染进程都已经准备好了，浏览器进程（browser process）会通过IPC告诉渲染进程去提交本次导航（commit navigation）。除此之外浏览器进程还会将刚刚接收到的响应数据流传递给对应的渲染进程让它继续接收到来的HTML数据。一旦浏览器进程收到渲染线程的回复说导航已经被提交了（commit），导航这个过程就结束了，文档的加载阶段（document loading phase）会正式开始。 到了这个时候，导航栏会被更新，安全指示符（security indicator）和站点设置UI（site settings UI）会展示新页面相关的站点信息。当前tab的回话历史（session history）也会被更新，这样当你点击浏览器的前进和后退按钮也可以导航到刚刚导航完的页面。为了方便你在关闭了tab或窗口（window）的时候还可以恢复当前tab和会话（session）内容，当前的会话历史会被保存在磁盘上面。 浏览器进程通过IPC来对渲染进程发起渲染页面的请求 额外步骤：初始加载完成（Initial load complete）当导航提交完成后，渲染进程开始着手加载资源以及渲染页面。我会在后面系列文章中讲述渲染进程渲染页面的具体细节。一旦渲染进程“完成”（finished）渲染，它会通过IPC告知浏览器进程（注意这发生在页面上所有帧（frames）的onload事件都已经被触发了而且对应的处理函数已经执行完成了的时候），然后UI线程就会停止导航栏上旋转的圈圈。 我这里用到“完成”这个词，因为后面客户端的JavaScript还是可以继续加载资源和改变视图内容的。 渲染进程通过IPC告诉浏览器进程页面已经加载完成了 导航到不同的站点一个最简单的导航情景已经描述完了！可是如果这时用户在导航栏上输入一个不一样的URL会发生什么呢？如果是这样，浏览器进程会重新执行一遍之前的那几个步骤来完成新站点的导航。不过在浏览器进程做这些事情之前，它需要让当前的渲染页面做一些收尾工作，具体就是询问一下当前的渲染进程需不需要处理一下beforeunload事件。 beforeunload可以在用户重新导航或者关闭当前tab时给用户展示一个“你确定要离开当前页面吗？”的二次确认弹框。浏览器进程之所以要在重新导航的时候和当前渲染进程确认的原因是，当前页面发生的一切（包括页面的JavaScript执行）是不受它控制而是受渲染进程控制，所以它也不知道里面的具体情况。 注意：不要随便给页面添加beforeunload事件监听，你定义的监听函数会在页面被重新导航的时候执行，因此这会增加重导航的时延。beforeunload事件监听函数只有在十分必要的时候才能被添加，例如用户在页面上输入了数据，并且这些数据会随着页面消失而消失。 浏览器进程通过IPC告诉渲染进程它将要离开当前页面导航到新的页面了 如果重新导航是在页面内被发起的呢？例如用户点击了页面的一个链接或者客户端的JavaScript代码执行了诸如window.location = “https://newsite.com&quot;的代码。这种情况下，渲染进程会自己先检查一个它有没有注册beforeunload事件的监听函数，如果有的话就执行，执行完后发生的事情就和之前的情况没什么区别了，唯一的不同就是这次的导航请求是由渲染进程给浏览器进程发起的。 如果是重新导航到不同站点（different site）的话，会有另外一个渲染进程被启动来完成这次重导航，而当前的渲染进程会继续处理现在页面的一些收尾工作，例如unload事件的监听函数执行。Overview of page lifecycle states这篇文章会介绍页面所有的生命周期状态，the Page Lifecycle API会教你如何在页面中监听页面状态的变化。 浏览器进程告诉新的渲染进程去渲染新的页面并且告诉当前的渲染进程进行收尾工作 Service Worker的情景这个导航过程最近发生的一个改变是引进了service worker的概念。因为Service worker可以用来写网站的网络代理（network proxy），所以开发者可以对网络请求有更多的控制权，例如决定哪些数据缓存在本地以及哪些数据需要从网络上面重新获取等等。如果开发者在service worker里设置了当前的页面内容从缓存里面获取，当前页面的渲染就不需要重新发送网络请求了，这就大大加快了整个导航的过程。 这里要重点留意的是service worker其实只是一些跑在渲染进程里面的JavaScript代码。那么问题来了，当导航开始的时候，浏览器进程是如何判断要导航的站点存不存在对应的service worker并启动一个渲染进程去执行它的呢？ 其实service worker在注册的时候，它的作用范围（scope）会被记录下来（你可以通过文章The Service Worker Lifecycle了解更多关于service worker作用范围的信息）。在导航开始的时候，网络线程会根据请求的域名在已经注册的service worker作用范围里面寻找有没有对应的service worker。如果有命中该URL的service worker，UI线程就会为这个service worker启动一个渲染进程（renderer process）来执行它的代码。Service worker既可能使用之前缓存的数据也可能发起新的网络请求。 网络线程会在收到导航任务后寻找有没有对应的service worker UI线程会启动一个渲染进程来运行找到的service worker代码，代码具体是由渲染进程里面的工作线程（worker thread）执行 导航预加载 - Navigation Preload在上面的例子中，你应该可以感受到如果启动的service worker最后还是决定发送网络请求的话，浏览器进程和渲染进程这一来一回的通信包括service worker启动的时间其实增加了页面导航的时延。导航预加载就是一种通过在service worker启动的时候并行加载对应资源的方式来加快整个导航过程效率的技术。预加载资源的请求头会有一些特殊的标志来让服务器决定是发送全新的内容给客户端还是只发送更新了的数据给客户端。 UI线程在启动一个渲染进程去运行service worker代码的同时会并行发送网络请求 总结在本篇文章中，我们讨论了导航具体都发生了哪些事情以及浏览器优化导航效率采取的一些技术方案，在下一篇文章中我们将会深入了解浏览器是如何解析我们的HTML/CSS/JavaScript来呈现出网页内容的。","link":"/2019/12/27/%E7%AA%A5%E6%8E%A2%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84-%E4%BA%8C/"},{"title":"窥探现代浏览器架构-三","text":"前言本文是笔者对Mario Kosaka写的inside look at modern web browser系列文章的翻译。这里的翻译不是指直译，而是结合个人的理解将作者想表达的意思表达出来，而且会尽量补充一些相关的内容来帮助大家更好地理解。 渲染进程里面发生的事这篇文章是探究Chrome内部工作原理的四集系列文章中的第三篇。之前我们分别探讨了Chrome的多进程架构以及导航的过程都发生了什么。在本篇文章中，我们将要窥探一下渲染进程在渲染页面的时候具体都发生了什么事情。 渲染进程会影响到Web性能的很多方面。页面渲染的时候发生的东西实在太多了，本篇文章只能作一个大体的介绍。如果你想要了解更多相关的内容，Web Fundamentals的Performance栏目有很多资源可以查看。 渲染进程处理页面内容渲染进程负责标签（tab）内发生的所有事情。在渲染进程里面，主线程（main thread）处理了绝大多数你发送给用户的代码。如果你使用了web worker或者service worker，相关的代码将会由工作线程（worker thread）处理。合成（compositor）以及光栅（raster）线程运行在渲染进程里面用来高效流畅地渲染出页面内容。 渲染进程的主要任务是将HTML，CSS，以及JavaScript转变为我们可以进程交互的网页内容。 渲染进程里面有：一个主线程（main thread），几个工作线程（worker threads），一个合成线程（compositor thread）以及一个光栅线程（raster thread） 解析构建DOM前面文章提到，渲染进程在导航结束的时候会收到来自浏览器进程提交导航（commit navigation）的消息，在这之后渲染进程就会开始接收HTML数据，同时主线程也会开始解析接收到的文本数据（text string）并把它转化为一个DOM（Document Object Model）对象 DOM对象既是浏览器对当前页面的内部表示，也是Web开发人员通过JavaScript与网页进行交互的数据结构以及API。 如何将HTML文档解析为DOM对象是在HTML标准中定义的。不过在你的web开发生涯中，你可能从来没有遇到过浏览器在解析HTML的时候发生错误的情景。这是因为浏览器对HTML的错误容忍度很大。举些例子：如果一个段落缺失了闭合p标签（&lt;/p&gt;），这个页面还是会被当做为有效的HTML来处理；Hi! &lt;b&gt;I’m &lt;i&gt;Chrome&lt;/b&gt;!&lt;/i&gt; (闭合b标签写在了闭合i标签的前面) ，虽然有语法错误，不过浏览器会把它处理为Hi! &lt;b&gt;I’m &lt;i&gt;Chrome&lt;/i&gt;&lt;/b&gt;&lt;i&gt;!&lt;/i&gt;。如果你想知道浏览器是如何对这些错误进行容错处理的，可以参考HTML规范里面的An introduction to error handling and strange cases in the parser内容。 子资源加载除了HTML文件，网站通常还会使用到一些诸如图片，CSS样式以及JavaScript脚本等子资源。这些文件会从缓存或者网络上获取。主线程会按照在构建DOM树时遇到各个资源的循序一个接着一个地发起网络请求，可是为了提升效率，浏览器会同时运行“预加载扫描”（preload scanner）程序。如果在HTML文档里面存在诸如&lt;img&gt;或者&lt;link&gt;这样的标签，预加载扫描程序会在HTML解析器生成的token里面找到对应要获取的资源，并把这些要获取的资源告诉浏览器进程里面的网络线程。 主线程会解析HTML内容并且构建出DOM树 JavaScript会阻塞HTML的解析过程当HTML解析器碰到script标签的时候，它会停止HTML文档的解析从而转向JavaScript代码的加载，解析以及执行。为什么要这样做呢？因为script标签中的JavaScript可能会使用诸如document.write()这样的代码改变文档流（document）的形状，从而使整个DOM树的结构发生根本性的改变（HTML规范里面的overview of the parsing model部分有很好的示意图）。因为这个原因，HTML解析器不得不等JavaScript执行完成之后才能继续对HTML文档流的解析工作。如果你想知道JavaScipt的执行过程都发生了什么，V8团队有很多关于这个话题的讨论以及博客。 给浏览器一点如何加载资源的提示Web开发者可以通过很多方式告诉浏览器如何才能更加优雅地加载网页需要用到的资源。如果你的JavaScript不会使用到诸如document.write()的方式去改变文档流的内容的话，你可以为script标签添加一个async或者defer属性来使JavaScript脚本进行异步加载。当然如果能满足到你的需求，你也可以使用JavaScript Module。同时&lt;link rel=&quot;preload&quot;&gt;资源预加载可以用来告诉浏览器这个资源在当前的导航肯定会被用到，你想要尽快加载这个资源。更多相关的内容，你可阅读Resource Prioritization - Getting the Browser to Help You这篇文章。 样式计算 - Style calculation拥有了DOM树我们还不足以知道页面的外貌，因为我们通常会为页面的元素设置一些样式。主线程会解析页面的CSS从而确定每个DOM节点的计算样式（computed style）。计算样式是主线程根据CSS样式选择器（CSS selectors）计算出的每个DOM元素应该具备的具体样式，你可以打开devtools来查看每个DOM节点对应的计算样式。 主线程解析CSS来确定每个元素的计算样式 即使你的页面没有设置任何自定义的样式，每个DOM节点还是会有一个计算样式属性，这是因为每个浏览器都有自己的默认样式表。因为这个样式表的存在，页面上的h1标签一定会比h2标签大，而且不同的标签会有不同的magin和padding。如果你想知道Chrome的默认样式是长什么样的，你可以直接查看代码。 布局 - Layout前面这些步骤完成之后，渲染进程就已经知道页面的具体文档结构以及每个节点拥有的样式信息了，可是这些信息还是不能最终确定页面的样子。举个例子，假如你现在想通过电话告诉你的朋友你身边的一幅画的内容：“画布上有一个红色的大圆圈和一个蓝色的正方形”，单凭这些信息你的朋友是很难知道这幅画具体是什么样子的，因为他不知道大圆圈和正方形具体在页面的什么位置，是正方形在圆圈前面呢还是圆圈在正方形的前面。 你站在一幅画面前通过电话告诉你朋友画上的内容 渲染网页也是同样的道理，只知道网站的文档流以及每个节点的样式是远远不足以渲染出页面内容的，还需要通过布局（layout）来计算出每个节点的几何信息（geometry）。布局的具体过程是：主线程会遍历刚刚构建的DOM树，根据DOM节点的计算样式计算出一个布局树（layout tree）。布局树上每个节点会有它在页面上的x，y坐标以及盒子大小（bounding box sizes）的具体信息。布局树长得和先前构建的DOM树差不多，不同的是这颗树只有那些可见的（visible）节点信息。举个例子，如果一个节点被设置为了display:none，这个节点就是不可见的就不会出现在布局树上面（visibility:hidden的节点会出现在布局树上面，你可以思考一下这是为什么）。同样的，如果一个伪元素（pseudo class）节点有诸如p::before{content:&quot;Hi!&quot;}这样的内容，它会出现在布局上，而不存在于DOM树上。 主线程会遍历每个DOM tree节点的计算样式信息来生成一棵布局树 即使页面的布局十分简单，布局这个过程都是非常复杂的。例如页面就是简单地从上而下展示一个又一个段落，这个过程就很复杂，因为你需要考虑段落中的字体大小以及段落在哪里需要进行换行之类的东西，它们都会影响到段落的大小以及形状，继而影响到接下来段落的布局。 浏览器得考虑段落是不是要换行 如果考虑到CSS的话将会更加复杂，因为CSS是一个很强大的东西，它可以让元素悬浮（float）到页面的某一边，还可以遮挡住页面溢出的（overflow）元素，还可以改变内容的书写方向，所以单是想一下你就知道布局这个过程是一个十分艰巨和复杂的任务。对于Chrome浏览器，我们有一整个负责布局过程的工程师团队。如果你想知道他们工作的具体内容，他们在BlinkOn Conference上面的相关讨论被录制了下来，有时间的话你可以去看一下。 绘画 - Paint知道了DOM节点以及它的样式和布局其实还是不足以渲染出页面来的。为什么呢？举个例子，假如你现在想对着一幅画画一幅一样的画，你已经知道了画布上每个元素的大小，形状以及位置，你还是得思考一下每个元素的绘画顺序，因为画布上的元素是会互相遮挡的（z-index）。 一个人拿着画笔站在画布前面，在思考着是先画一个圆还是先画一个正方形 举个例子，如果页面上的某些元素设置了z-index属性，绘制元素的顺序就会影响到页面的正确性。 单纯按照HTML布局的顺序绘制页面的元素是错误的，因为元素的z-index元素没有被考虑到 在绘画这个步骤中，主线程会遍历之前得到的布局树（layout tree）来生成一系列的绘画记录（paint records）。绘画记录是对绘画过程的注释，例如“首先画背景，然后是文本，最后画矩形”。如果你曾经在canvas画布上有使用过JavaScript绘制元素，你可能会觉着这个过程不是很陌生。 主线程遍历布局树来生成绘画记录 高成本的渲染流水线（rendering pipeline）更新关于渲染流水线有一个十分重要的点就是流水线的每一步都要使用到前一步的结果来生成新的数据，这就意味着如果某一步的内容发生了改变的话，这一步后面所有的步骤都要被重新执行以生成新的记录。举个例子，如果布局树有些东西被改变了，文档上那些被影响到的部分的绘画顺序是要重新生成的。 DOM+Style，布局以及绘画树 如果你的页面元素有动画效果（animating），浏览器就不得不在每个渲染帧的间隔中通过渲染流水线来更新页面的元素。我们大多数显示器的刷新频率是一秒钟60次（60fps），如果你在每个渲染帧的间隔都能通过流水线移动元素，人眼就会看到流畅的动画效果。可是如果流水线更新时间比较久，动画存在丢帧的状况的话，页面看起来就会很“卡顿”。 流水线更新没有赶上屏幕刷新，动画就有点卡 即使你的渲染流水线更新是和屏幕的刷新频率保持一致的，这些更新是运行在主线程上面的，这就意味着它可能被同样运行在主线程上面的JavaScript代码阻塞。 某些动画帧被JavaScript阻塞了 对于这种情况，你可以将要被执行的JavaScript操作拆分为更小的块然后通过requestAnimationFrame这个API把他们放在每个动画帧中执行。想知道更多关于这方面的信息的话，可以参考Optimize JavaScript Execution。当然你还可以将JavaScript代码放在WebWorkers中执行来避免它们阻塞主线程。 在动画帧上运行一小段JavaScript代码 合成如何绘制一个页面？到目前为止，浏览器已经知道了关于页面以下的信息：文档结构，元素的样式，元素的几何信息以及它们的绘画顺序。那么浏览器是如何利用这些信息来绘制出页面来的呢？将以上这些信息转化为显示器的像素的过程叫做光栅化（rasterizing）。 可能一个最简单的做法就是只光栅化视口内（viewport）的网页内容。如果用户进行了页面滚动，就移动光栅帧（rastered frame）并且光栅化更多的内容以补上页面缺失的部分。Chrome的第一个版本其实就是这样做的。然而，对于现代的浏览器来说，它们往往采取一种更加复杂的叫做合成（compositing）的做法。 最简单的光栅化过程 什么是合成合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程（compositor thread）里面合并成一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。页面的动画效果实现也是类似，将页面上的层进行移动并构建出一个新的帧即可。 你可以通过Layers panel在DevTools查看你的网站是如何被浏览器分成不同的层的。 页面合成过程 页面分层为了确定哪些元素需要放置在哪一层，主线程需要遍历渲染树来创建一棵层次树（Layer Tree）（在DevTools中这一部分工作叫做“Update Layer Tree”）。如果页面的某些部分应该被放置在一个单独的层上面（滑动菜单）可是却没有的话，你可以通过使用will-change CSS属性来告诉浏览器对其分层。 主线程遍历布局树来生成层次树 你可能会想要给页面上所有的元素一个单独的层，然而当页面的层超过一定的数量后，层的合成操作要比在每个帧中光栅化页面的一小部分还要慢，因此衡量你应用的渲染性能是十分重要的一件事情。想要获取关于这方面的更多信息，可以参考文章Stick to Compositor-Only Properties and Manage Layer Count。 在主线程之外光栅化和合成页面一旦页面的层次树创建出来并且页面元素的绘制顺序确定后，主线程就会向合成线程（compositor thread）提交这些信息。然后合成线程就会光栅化页面的每一层。因为页面的一层可能有整个网页那么大，所以合成线程需要将它们切分为一块又一块的小图块（tiles）然后将图块发送给一系列光栅线程（raster threads）。光栅线程会栅格化每个图块并且把它们存储在GPU的内存中。 光栅线程创建图块的位图并发送给GPU 合成线程可以给不同的光栅线程赋予不同的优先级（prioritize），进而使那些在视口中的或者视口附近的页面可以先被光栅化。为了响应用户对页面的放大和缩小操作，页面的图层（layer）会为不同的清晰度配备不同的图块。 当图层上面的图块都被栅格化后，合成线程会收集图块上面叫做绘画四边形（draw quads）的信息来构建一个合成帧（compositor frame）。 绘画四边形：包含图块在内存的位置以及图层合成后图块在页面的位置之类的信息。 合成帧：代表页面一个帧的内容的绘制四边形集合。 上面的步骤完成之后，合成线程就会通过IPC向浏览器进程（browser process）提交（commit）一个渲染帧。这个时候可能有另外一个合成帧被浏览器进程的UI线程（UI thread）提交以改变浏览器的UI。这些合成帧都会被发送给GPU从而展示在屏幕上。如果合成线程收到页面滚动的事件，合成线程会构建另外一个合成帧发送给GPU来更新页面。 合成线程构建出合成帧，合成帧会被发送给浏览器进程然后再发送给GPU 合成的好处在于这个过程没有涉及到主线程，所以合成线程不需要等待样式的计算以及JavaScript完成执行。这也就是为什么说只通过合成来构建页面动画是构建流畅用户体验的最佳实践的原因了。如果页面需要被重新布局或者绘制的话，主线程一定会参与进来的。 总结在这篇文章中，我们探讨了从解析HTML文件到合成页面整个的渲染流水线。希望你读完后，可以自己去看一些关于页面性能优化的文章了。 在接下来也是最后一篇本系列的文章中，我们将要查看合成线程更多的细节，来了解一下当用户在页面移动鼠标（mouse move）以及进行点击（click）的时候浏览器会做些什么事情。","link":"/2020/01/08/%E7%AA%A5%E6%8E%A2%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84-%E4%B8%89/"},{"title":"Svelte 3 初学者完全指南","text":"React, Vue和Angular差不多占据了Web开发的大部分江山，可是最近半年Svelte开始逐渐吸引越来越多人的眼球。这个Svelte框架到底有什么过人之处呢？本文将会为大家分析一下Svelte火起来的原因，并且通过使用Svelte去搭建一个简单的书店应用（bookshop）来帮助大家快速入门这门框架。 Svelte为什么会火?要想知道Svelte为什么会火，首先得看看React和Vue这些框架存在什么问题。 big runtime - 大的运行时React和Vue都是基于runtime的框架。所谓基于runtime的框架就是框架本身的代码也会被打包到最终的bundle.js并被发送到用户浏览器。当用户在你的页面进行各种操作改变组件的状态时，框架的runtime会根据新的组件状态（state）计算（diff）出哪些DOM节点需要被更新，从而更新视图。那么这些runtime代码到底有多大呢，可以看一些社区的统计数据: Name Size Ember 2.2.0 435K Ember 1.13.8 486K Angular 2 566K Angular 2 + Rx 766K Angular 1.4.5 143K Vue 2.4.2 58.8K Inferno 1.2.2 48K Preact 7.2.0 16K React 0.14.5 + React DOM 133K React 0.14.5 + React DOM + Redux 139K React 16.2.0 + React DOM 97.5K 从上面的表格可以看出常用的框架中，最小的Vue都有58k，React更有97.5k。换句话说如果你使用了React作为开发的框架，即使你的业务代码很简单，你的首屏bundle size都要100k起步。当然100k不算很大，可是事物都是相对的，相对于大型的管理系统来说100k肯定不算什么，可是对于那些首屏加载时间敏感的应用（例如淘宝，京东主页），100k的bundle size在一些网络环境不好的情况或者手机端真的会影响用户体验。那么如何减少框架的runtime代码大小呢？要想减少runtime代码的最有效的方法就是压根不用runtime。其实回想一下Web开发的历史，很早之前在用Jquery和Bootstrap一把梭的时候，我们的代码不就是不包含runtime的吗？当数据变化时直接通过JavaScript去改变原生DOM节点，没有框架那一系列diff和调度（React Fiber）的过程。这时你可能会问，要减少bundle size真的要回到那个刀耕火种的时代吗？有没有那种既可以让我用接近React和Vue的语法编写代码，同时又不包含框架runtime的办法。这恰恰就是Svelte要做的东西，它采用了Compiler-as-framework的理念，将框架的概念放在编译时而不是运行时。你编写的应用代码在用诸如Webpack和Rollup等工具打包的时候会被直接转换为JavaScript对DOM节点的原生操作，从而让bundle.js不包含框架的runtime。那么Svelte到底可以将bundle size减少多少呢？以下是RealWorld这个项目的统计：由上面的图表可以看出实现相同功能的应用，Svelte的bundle size大小是Vue的1/4，是React的1/20！单纯从这个数据来看，Svelte这个框架对bundle size的优化真的很大。 低效的Virtual DOM Diff什么？Virtual DOM不是一直都很高效的吗？其实Virtual DOM高效是一个误解。说Virtual DOM高效的一个理由就是它不会直接操作原生的DOM节点，因为这个很消耗性能。当组件状态变化时它会通过某些diff算法去计算出本次数据更新真实的视图变化，然后只改变“需要改变”的DOM节点。用过React的人可能都会体会到React并没有想象中那么高效，框架有时候会做很多无用功，这体现在很多组件会被“无缘无故”进行重渲染（re-render）。注意这里说的re-render和对原生DOM进行操作是两码事！所谓的re-render是你定义的class Component的render方法被重新执行，或者你的组件函数被重新执行。组件被重渲染是因为Vitual DOM的高效是建立在diff算法上的，而要有diff一定要将组件重渲染才能知道组件的新状态和旧状态有没有发生改变，从而才能计算出哪些DOM需要被更新。你可能会说React Fiber不是出来了吗，这个应该不是问题了吧？其实Fiber这个架构解决的问题是不让组件的重渲染和reconcile的过程阻塞主线程的执行，组件重渲染的问题依然存在，而且据反馈，React Hooks出来后组件的重渲染更加频繁了。正是因为框架本身很难避免无用的渲染，React才允许你使用一些诸如shouldComponentUpdate，PureComponent和useMemo的API去告诉框架哪些组件不需要被重渲染，可是这也就引入了很多模板代码（boilerplate）。如果大家想了解更多关于Virtual DOM存在的问题，可以看一下virtual dom is pure overhead这篇文章。 那么如何解决Vitual DOM算法低效的问题呢？最有效的解决方案就是不用Virtual DOM！其实作为一个框架要解决的问题是当数据发生改变的时候相应的DOM节点会被更新（reactive），Virtual DOM需要比较新老组件的状态才能达到这个目的，而更加高效的办法其实是数据变化的时候直接更新对应的DOM节点： 1if (changed.name) {2 text.data = name;3} 这就是Svelte采用的办法。Svelte会在代码编译的时候将每一个状态的改变转换为对应DOM节点的操作，从而在组件状态变化的时候快速高效地对DOM节点进行更新。根据js framework benchmark的统计，Svelte在对一些大列表操作的时候性能比React和Vue都要好。 什么是Svelte?Svelte是由RollupJs的作者Rich Harris编写的编译型框架，没了解过RollupJs的同学可以去它官网了解一下，它其实是一个类似于Webpack的打包工具。Svelte这个框架具有以下特点： 和React，Vue等现代Web框架的用法很相似，它可以允许开发者快速开发出具有流畅用户体验的Web应用。 不使用Virtual DOM，也不是一个runtime的库。 基于Compiler as framework的理念，会在编译的时候将你的应用转换为原生的DOM操作。 默认就支持类似于CSS modules的CSS scope功能，让你避免CSS样式冲突的困扰。 原生支持CSS animation。 极其容易的组件状态管理（state management），减少开发者的模板代码编写（boilerplate less）。 支持反应式定义（Reactive statement）。 极其容易的应用全局状态管理，框架本身自带全局状态，类似于React的Redux和Vue的Vuex。 支持context，避免组件的props drilling。 Svelte这个框架与Vue和React之间最大的区别是它除了管理组件的状态和追踪他们的渲染，还有很多其他有用的功能。例如它原生支持CSS scope和CSS animation。如果你用React或者Vue是需要引入第三方库来实现同样的功能的，而第三方依赖的引入会给开发者增加学习和维护的成本。 用Svelte搭建一个Bookshop应用接下来我们会从头开始搭建一个基于Svelte框架的简单书店应用bookshop，通过这个demo，希望大家可以理解Svelte的一些基本概念和掌握它的一些基本用法并能够使用Svelte去搭建更加复杂的应用。 应用功能Bookshop应用支持以下功能： 管理员录入新图书 展示书店图书列表 将图书加到购物车 展示购物车的数据信息 对学习者的技术要求 掌握html，css和javascript的基础用法 有过React或者Vue的相关开发经验最佳 项目的源代码可以在我的github仓库找到。 项目搭建首先在我们的本地开发环境新建一个项目文件夹： 1mkdir svelte-bookshop 接着用svelte官方的脚手架去初始化我们的应用： 1npx degit sveltejs/template svelte-bookshop2cd svelte-bookshop34yarn5yarn dev degit这个命令会将github上面的项目文件直接拷贝到某个本地文件夹，这里使用到的svelte/tempalte模板项目的github地址是这个。以上命令成功运行后，访问http://localhost:5000你会看到如下界面：界面很简单就是展示一个hello world，接着让我们看一下生成的项目目录结构：生成的代码主要包含以下文件目录结构： rollup.config.js，这个是rollup的配置文件，类似于webpack.config.js，里面指定了项目的入口文件是src/main.js。 src文件夹，这个文件夹用来存储我们的项目源代码，现在只有一个项目的主入口文件main.js和一个组件文件App.svelte。 public文件夹，这个文件夹是用来存储项目的静态文件（index.html, global.css和favicon.png）和rollup编译生成的静态文件（build文件夹底下的bundle.js和bundle.css以及它们各自的source map）。 接着让我们具体看一下src文件夹底下的各个文件内容 src/App.svelte1&lt;script&gt;2 export let name;3&lt;/script&gt;45&lt;main&gt;6 &lt;h1&gt;Hello {name}!&lt;/h1&gt;7 &lt;p&gt;Visit the &lt;a href=\"https://svelte.dev/tutorial\"&gt;Svelte tutorial&lt;/a&gt; to learn how to build Svelte apps.&lt;/p&gt;8&lt;/main&gt;910&lt;style&gt;11 main {12 text-align: center;13 padding: 1em;14 max-width: 240px;15 margin: 0 auto;16 }1718 h1 {19 color: #ff3e00;20 text-transform: uppercase;21 font-size: 4em;22 font-weight: 100;23 }2425 @media (min-width: 640px) {26 main {27 max-width: none;28 }29 }30&lt;/style&gt; 这个文件定义了一个叫做App的Svelte组件，这里要注意App.svelte文件内并没有定义组件的名称，组件的名称是由它的文件名确定的。Svelte组件的文件名都是以.svelte结尾的，一个组件文件通常会包含以下三部分内容： &lt;script&gt;标签，和组件相关的任何JavaScript代码都可以放在这里，例如组件的状态定义或者一些异步Ajax请求。在这个App.svelte文件里面没有定义局部的组件状态，而是定义并export了一个name变量。对于Svelte框架，export一个变量就是将这个变量指定为当前组件的一个外部参数 - props。这种做法和React里面的将props作为组件的第一个参数的区别很大，可能大家一开始有点不习惯，不过后面习惯了，你可能也会爱上这种写法的。 &lt;style&gt;标签，和组件相关的CSS代码会放在这里。注意这里的CSS是局部生效的（scope），也就是说App.svelte中的h1标签的样式只会对App组件内的h1标签生效，而对项目其他的包括这个组件的子节点的h1标签失效。具体可以用浏览器的调试工具看一下h1标签的实际样式就明白了: 由上图可以看出Svelte在生成代码的时候会用一些随机的哈希值将组件的样式和其它组件的样式区别开来。 组件的HTML标签。组件的HTML标签可以直接在文件中写出来，例如App组件的HTML部分是：1&lt;main&gt;2 &lt;h1&gt;Hello {name}!&lt;/h1&gt;3 &lt;p&gt;Visit the &lt;a href=\"https://svelte.dev/tutorial\"&gt;Svelte tutorial&lt;/a&gt; to learn how to build Svelte apps.&lt;/p&gt;4&lt;/main&gt; App组件最外层是一个main标签，main标签里面有一个h1标签和p标签，其中h1标签里面是一个Hello字符串加一个用花括号包裹的插入字符串（interpolation），在React JSX里面的写法应该是Hello ${name}，它们都表示这个位置的字符串就是name这个变量的内容。至于这个name变量就是我们在上面用export定义的外部参数。 总的来说Svelte会将所有和组件相关的JavaScript，CSS和HTML代码都放在同一个文件里面，这个做法有点像Vue，不过和Vue相比它的模板代码更少。 src/main.js1import App from './App.svelte';23const app = new App({4 target: document.body,5 props: {6 name: 'world'7 }8});910export default app; 这个文件内容很简单，就是将刚刚定义的App组件挂载到目标节点body上，而且为App组件提供了值为world的name参数。这段代码的作用和React中的ReactDOM.render函数一样。 接着让我们看一下生成的静态代码是什么样子的。 public/build/bundle.js先看生成的JavaScript主文件bundle.js，由于原文件比较大，我只截取了其中比较关键的一部分： 1/* src/App.svelte generated by Svelte v3.16.4 */23const file = \"src/App.svelte\";45function create_fragment(ctx) {6 let main;7 let h1;8 let t0;9 let t1;10 let t2;11 let t3;12 let p;13 let t4;14 let a;15 let t6;1617 const block = {18 c: function create() {19 main = element(\"main\");20 h1 = element(\"h1\");21 t0 = text(\"Hello \");22 t1 = text(/*name*/ ctx[0]);23 t2 = text(\"!\");24 t3 = space();25 p = element(\"p\");26 t4 = text(\"Visit the \");27 a = element(\"a\");28 a.textContent = \"Svelte tutorial\";29 t6 = text(\" to learn how to build Svelte apps.\");30 attr_dev(h1, \"class\", \"svelte-1tky8bj\");31 add_location(h1, file, 5, 1, 46);32 attr_dev(a, \"href\", \"https://svelte.dev/tutorial\");33 add_location(a, file, 6, 14, 83);34 add_location(p, file, 6, 1, 70);35 attr_dev(main, \"class\", \"svelte-1tky8bj\");36 add_location(main, file, 4, 0, 38);37 },38 l: function claim(nodes) {39 throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");40 },41 m: function mount(target, anchor) {42 insert_dev(target, main, anchor);43 append_dev(main, h1);44 append_dev(h1, t0);45 append_dev(h1, t1);46 append_dev(h1, t2);47 append_dev(main, t3);48 append_dev(main, p);49 append_dev(p, t4);50 append_dev(p, a);51 append_dev(p, t6);52 },53 p: function update(ctx, dirty) {54 if (dirty[0] &amp; /*name*/ 1) set_data_dev(t1, /*name*/ ctx[0]);55 },56 i: noop,57 o: noop,58 d: function destroy(detaching) {59 if (detaching) detach_dev(main);60 }61 };6263 dispatch_dev(\"SvelteRegisterBlock\", {64 block,65 id: create_fragment.name,66 type: \"component\",67 source: \"\",68 ctx69 });7071 return block;72} 这段代码对应的就是我们刚刚定义的App组件，create_fragment方法会接受一个上下文对象ctx参数并返回一个代表组件的block对象。 block这个对象主要包含以下四个重要的方法c（create），m（mount），p（update）和d（destroy）。 c（create）1function create() {2 main = element(\"main\");3 h1 = element(\"h1\");4 t0 = text(\"Hello \");5 t1 = text(/*name*/ ctx[0]);6 t2 = text(\"!\");7 t3 = space();8 p = element(\"p\");9 t4 = text(\"Visit the \");10 a = element(\"a\");11 a.textContent = \"Svelte tutorial\";12 t6 = text(\" to learn how to build Svelte apps.\");13 attr_dev(h1, \"class\", \"svelte-1tky8bj\");14 add_location(h1, file, 5, 1, 46);15 attr_dev(a, \"href\", \"https://svelte.dev/tutorial\");16 add_location(a, file, 6, 14, 83);17 add_location(p, file, 6, 1, 70);18 attr_dev(main, \"class\", \"svelte-1tky8bj\");19 add_location(main, file, 4, 0, 38);20} 这个函数的功能是生成（create）和App组件相关的一些原生DOM节点，并为它们添加一些元数据（meta data）。 m（mount）1function mount(target, anchor) {2 insert_dev(target, main, anchor);3 append_dev(main, h1);4 append_dev(h1, t0);5 append_dev(h1, t1);6 append_dev(h1, t2);7 append_dev(main, t3);8 append_dev(main, p);9 append_dev(p, t4);10 append_dev(p, a);11 append_dev(p, t6);12} 这个函数的功能是挂载c函数生成的那些DOM节点。 p（update）1function update(ctx, dirty) {2 if (dirty[0] &amp; /*name*/ 1) set_data_dev(t1, /*name*/ ctx[0]);3} p函数会在ctx上下文更新的时候去更新对应DOM节点的属性。大概就是当上下文变化的时候，检查一下name这个变量有没有变化，如果发生变化则更新DOM节点。 d（destroy）1function destroy(detaching) {2 if (detaching) detach_dev(main);3} d函数是用来删除App组件的。 看完Svelte生成的代码后，我想你对我在文章开头说的Compiler-as-framework等概念应该有了更加深刻的认识，Svelte和React（Vue也类似）不一样的是，React应用在打包完之后，还保留了如React.createElement，setState等框架函数的调用代码，而Svelte编译完之后，框架代码会被转化为操作原生DOM节点的代码。 大概了解了项目的组织结构后，让我们开始正式搭建书店bookshop应用。 组件定义HTML markup首先让我们创建一个展示书本具体信息的卡片组件，在src文件夹底下新建一个BookCard.svelte文件，里面定义一下卡片组件的HTML markup： 1// src/BookCard.svelte2&lt;div&gt;3 &lt;h1&gt;title&lt;/h1&gt;4 &lt;div&gt;price&lt;/div&gt;5 &lt;div&gt;description&lt;/div&gt;6 &lt;button&gt;添加到购物车&lt;/button&gt;7&lt;/div&gt; 然后在App.svelte组件里面使用BookCard组件: 1// src/App.svelte2&lt;script&gt;3 import BookCard from \"./BookCard.svelte\";4&lt;/script&gt;56&lt;style&gt;7 ...8&lt;/style&gt;910&lt;main&gt;11 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;12 &lt;section&gt;13 &lt;BookCard /&gt;14 &lt;/section&gt;15&lt;/main&gt; 使用自定义的组件的方法很简单：先在script标签里面导入新定义的组件BookCard，然后将该组件写在App组件的HTML markup里面，语法和JSX一样的。这时候再查看页面的内容： CSSBookCard组件虽然出来了，我们得定义一些CSS让它变得更好看一点： 1// src/BookCard.svelte2&lt;style&gt;3 .card {4 text-align: left;5 border-radius: 5px;6 box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);7 padding: 10px;8 }910 h1 {11 font-size: 20px;12 }1314 h2 {15 font-size: 15px;16 color: #999;17 }1819 button {20 background-color: #ff3e00;21 color: white;22 border-radius: 5px;23 cursor: pointer;24 border: none;25 }26&lt;/style&gt;2728&lt;div class=\"card\"&gt;29 &lt;h1&gt;title&lt;/h1&gt;30 &lt;h2&gt;price&lt;/h2&gt;31 &lt;p&gt;description&lt;/p&gt;32 &lt;button&gt;添加到购物车&lt;/button&gt;33&lt;/div&gt; 给组件定义样式的方法就是新建一个style标签然后把该组件相关的样式写在这个标签内，注意这里的样式只会对组件内的元素有效，不会影响到其他组件的样式的。加完样式后，界面应该会变成这个样子： props定义书本的具体信息应该是由传入的props指定的。Svelte组件的props要用export来指明，指明的props变量可以直接被组件使用： 1// src/BookCard.svelte2&lt;script&gt;3 export let title;4 export let price;5 export let description;6&lt;/script&gt;78&lt;style&gt;9...10&lt;/style&gt;1112&lt;div class=\"card\"&gt;13 &lt;h1&gt;title&lt;/h1&gt;14 &lt;h2&gt;price&lt;/h2&gt;15 &lt;p&gt;description&lt;/p&gt;16 &lt;button&gt;添加到购物车&lt;/button&gt;17&lt;/div&gt; 变量使用定义和引入的变量可以在组件的HTML markup中直接使用，具体用法是在Markup中用花括号（curly braces）引用该变量，具体代码时： 1// src/BookCard.svelte2&lt;script&gt;3 export let title;4 export let price;5 export let description;6&lt;/script&gt;78&lt;style&gt;9...10&lt;/style&gt;1112&lt;div class=\"card\"&gt;13 &lt;h1&gt;{title}&lt;/h1&gt;14 &lt;h2&gt;${price}&lt;/h2&gt;15 &lt;p&gt;{description}&lt;/p&gt;16 &lt;button&gt;添加到购物车&lt;/button&gt;17&lt;/div&gt; 组件参数传递然后在父级组件App中，将BookCard需要的参数传给该组件： 1// src/App.svelte2&lt;script&gt;3 ...4 let title = \"JavaScript高级编程\";5 let price = 99.0;6 let description = \"一起来学习JavaScript啊\";7&lt;/script&gt;89&lt;style&gt;10 ...11&lt;/style&gt;1213&lt;main&gt;14 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;15 &lt;section&gt;16 &lt;BookCard title={title} price={price} description={description} /&gt;17 &lt;/section&gt;18&lt;/main&gt; 这时候书本卡片的内容应该是传入的参数了：对于组件参数传递，Svelte还提供了以下更加方便的写法： 1// src/App.svelte2&lt;main&gt;3 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;4 &lt;section&gt;5 &lt;BookCard {title} {price} {description} /&gt;6 &lt;/section&gt;7&lt;/main&gt; 录入书本信息作为一个书店，管理员应该可以录入新的图书，所以我们给App组件添加一个简单的表单来让用户录入数据： 1// src/App.svelte2&lt;script&gt;3 ...4&lt;/script&gt;56&lt;style&gt;7 ....8&lt;/style&gt;910&lt;main&gt;11 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;12 &lt;section&gt;13 &lt;h2&gt;Add new book&lt;/h2&gt;14 &lt;label for=\"title\"&gt;Title&lt;/label&gt;15 &lt;input type=\"text\" id=\"title\" value={title} /&gt;16 &lt;label for=\"price\"&gt;Price&lt;/label&gt;17 &lt;input type=\"number\" id=\"price\" value={price} /&gt;18 &lt;label for=\"description\"&gt;Description&lt;/label&gt;19 &lt;textarea rows=\"3\" id=\"description\" value={description} /&gt;20 &lt;/section&gt;21 &lt;section&gt;22 &lt;BookCard {title} {price} {description} /&gt;23 &lt;/section&gt;24&lt;/main&gt; 我们为App组件新建了一些input标签，并指定这些input标签的值为我们之前定义的变量，这时候我们试着改变输入框的内容：虽然输入框的初始值是变量对应的值，可是变量的值并不会随着输入框的值的改变而改变，也就是它们的值没有”绑定起来“，要想实现双向数据绑定，我们可以给输入框添加一个监听事件。 事件绑定我们可以使用on关键字加事件名称给DOM添加事件监听器，以下代码将会监听input输入框的input事件： 1&lt;script&gt;2 ...3 let title = \"JavaScript高级编程\";4 ...56 function handleTitleChange(event) {7 title = event.target.value;8 }9&lt;/script&gt;1011&lt;style&gt;12 ...13&lt;/style&gt;1415&lt;main&gt;16 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;17 &lt;section&gt;18 &lt;h2&gt;Add new book&lt;/h2&gt;19 &lt;label for=\"title\"&gt;Title&lt;/label&gt;20 &lt;input type=\"text\" id=\"title\" value={title} on:input={handleTitleChange} /&gt;21 ...22 &lt;/section&gt;23&lt;/main&gt; 这时候我们再改变input的值，会发现卡片里面的内容也发生了改变，说明我们成功改变了title变量的值： 自动数据双向绑定可是如果每一个input标签都要手动添加一个事件监听的话我们的代码会有很多模板代码，为了解决这个问题，Svelte允许我们直接用bind关键字加要绑定的属性进行双向数据绑定： 1// src/App.svelte2&lt;script&gt;3 ...4 let title = \"JavaScript高级编程\";5 let price = 99.0;6 let description = \"一起来学习JavaScript啊\";7&lt;/script&gt;89&lt;style&gt;10 ...11&lt;/style&gt;1213&lt;main&gt;14 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;15 &lt;section&gt;16 &lt;h2&gt;Add new book&lt;/h2&gt;17 &lt;label for=\"title\"&gt;Title&lt;/label&gt;18 &lt;input type=\"text\" id=\"title\" bind:value={title} /&gt;19 &lt;label for=\"price\"&gt;Price&lt;/label&gt;20 &lt;input type=\"number\" id=\"price\" bind:value={price} /&gt;21 &lt;label for=\"description\"&gt;Description&lt;/label&gt;22 &lt;textarea rows=\"3\" id=\"description\" bind:value={description} /&gt;23 &lt;/section&gt;24 ...25&lt;/main&gt; 这时候我们就可以把各个变量的初始值去掉： 1// src/App.svelte2&lt;script&gt;3 let title = \"\";4 let price = 0;5 let description = \"\";6&lt;/script&gt; 这时候我们页面的输入框和所有变量都”绑定“起来了： 展示书本列表我们的书店应该不止一本书，要用一个数组把所有的书本存起来： 1// src/App.svelte2&lt;script&gt;3 ...4 let books = [];5 ...6&lt;/script&gt; 接着我们再为刚刚新增的表单添加一个提交按钮，用户填完书本的信息后点击提交会新建一个book对象，新建的book对象会被加到books列表中去： 1&lt;script&gt;2 ...3 let books = [];45 function handleAddBook() {6 books = books.concat({ title, price, description });7 title = \"\";8 price = 0;9 description = \"\";10 }11 ...12&lt;/script&gt;1314&lt;style&gt;15 ...16 button {17 background-color: #ff3e00;18 color: white;19 border-radius: 5px;20 cursor: pointer;21 border: none;22 }23 ...24&lt;/style&gt;2526&lt;main&gt;27 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;28 &lt;section&gt;29 &lt;h2&gt;Add new book&lt;/h2&gt;30 &lt;label for=\"title\"&gt;Title&lt;/label&gt;31 &lt;input type=\"text\" id=\"title\" bind:value={title} /&gt;32 &lt;label for=\"price\"&gt;Price&lt;/label&gt;33 &lt;input type=\"number\" id=\"price\" bind:value={price} /&gt;34 &lt;label for=\"description\"&gt;Description&lt;/label&gt;35 &lt;textarea rows=\"3\" id=\"description\" bind:value={description} /&gt;36 &lt;div&gt;37 &lt;button on:click={handleAddBook}&gt;add book&lt;/button&gt;38 &lt;/div&gt;39 &lt;/section&gt;40 ...41&lt;/main&gt; 展示列表数据我们可以使用each语法块去展示books列表的数据： 1// src/App.svelte2&lt;script&gt;3 ....45 let books = [];67 function handleAddBook() {8 books = books.concat({ title, price, description });9 title = \"\";10 price = 0;11 description = \"\";12 }13&lt;/script&gt;1415&lt;main&gt;16 ...17 &lt;section&gt;18 {#each books as book}19 &lt;BookCard20 title={book.title}21 price={book.price}22 description={book.description} /&gt;23 {/each}24 &lt;/section&gt;25&lt;/main&gt; 你也可以直接在each块定义的时候解构出被递归对象里面的内容，上面的代码变为： 1// src/App.svelte2 ...3 &lt;section&gt;4 {#each books as { title, price, description }}5 &lt;BookCard {title} {price} {description} /&gt;6 {/each}7 &lt;/section&gt;8 ... 代码更改完后，你的页面就可以录入新书并展示书的列表了： 购物车功能首先我们要为BookCard这个组件的按钮添加一个点击事件：用户点击书本卡片按钮的时候这本书会被加到购物车中。要实现这个效果我们可以为BookCard按钮定义一个handleAddBook的参数，这个参数由外面组件来提供，handleAddBook函数会在用户点击BookCard按钮的时候被调用并将该书添加购物车中。代码如下： 1// src/BookCard.svelte2&lt;script&gt;3 ...4 export let handleAddToCart;5&lt;/script&gt;67&lt;style&gt;8 ...9&lt;/style&gt;1011&lt;div class=\"card\"&gt;12 &lt;h1&gt;{title}&lt;/h1&gt;13 &lt;h2&gt;${price}&lt;/h2&gt;14 &lt;p&gt;{description}&lt;/p&gt;15 &lt;button on:click={() =&gt; handleAddToCart(title)}&gt;添加到购物车&lt;/button&gt;16&lt;/div&gt; 1// src/App.svelte2&lt;script&gt;3 ...4 let booksInCart = [];56 function handleAddToCart(title) {7 let bookNeededToBeAdded = books.find(book =&gt; book.title == title);8 booksInCart = booksInCart.concat(bookNeededToBeAdded);9 }10&lt;/script&gt;1112&lt;style&gt;13 ...14&lt;/style&gt;1516&lt;main&gt;17 ...18 &lt;section&gt;19 &lt;h2&gt;购物车&lt;/h2&gt;20 {#each booksInCart as { title, price }}21 &lt;div&gt;名称: {title}, 价钱: {price}&lt;/div&gt;22 {/each}23 &lt;/section&gt;24 &lt;section&gt;25 &lt;h2&gt;书单&lt;/h2&gt;26 {#each books as { title, price, description }}27 &lt;BookCard {title} {price} {description} {handleAddToCart} /&gt;28 {/each}29 &lt;/section&gt;30&lt;/main&gt; 这时候我们就可以看到我们的购物车了： 条件判断Svelte可以用if语法块根据不同条件展示不同的内容，我们可以在购物车为空的时候给用户展示一个空的状态： 1// src/App.svelte2...3&lt;section&gt;4 &lt;h2&gt;购物车&lt;/h2&gt;5 {#if booksInCart.length === 0}6 &lt;p&gt;购物车空的哦~&lt;/p&gt;7 {:else}8 {#each booksInCart as { title, price }}9 &lt;div&gt;名称: {title}, 价钱: {price}&lt;/div&gt;10 {/each}11 {/if}12&lt;/section&gt;13... 这时候界面变为： 展示购物车统计信息我们再为书店添加一个帮用户统计购物车的书本的功能，可以展示现在购物车里面的书本总数和总金额，代码如下: 1// src/App.svelte2&lt;script&gt;3 ...4 let booksInCart = [];56 let booksNumInCart = booksInCart.length;7 let totalCheckoutPrice = booksInCart.reduce(8 (sum, book) =&gt; sum + book.price,9 010 );11 ...12&lt;/script&gt;1314...15&lt;section&gt;16 &lt;h2&gt;购物车&lt;/h2&gt;17 &lt;div&gt;书本总数：{booksNumInCart}&lt;/div&gt;18 &lt;div&gt;订单金额：{totalCheckoutPrice}&lt;/div&gt;19 ...20&lt;/section&gt;21... 这时候我们操作界面却发现购物车的数据变化时统计数据竟然没有变化：数据没有变化的原因是我们每次添加书本到购物车的时候没有手动地去改变booksNumInCart和totalCheckoutPrice的值。不过如果需要在购物车数据发生变化的时候手动维护统计数据的话，代码会变得很丑陋。 反应式定义对于这种情况，Svelte提供了反应式定义（Reactive assignment）的方法来表示这种联动的数据，具体做法就是用$符号定义变量而不是let，以下是代码： 1&lt;script&gt;2 ...3 let booksInCart = [];45 $: booksNumInCart = booksInCart.length;6 $: totalCheckoutPrice = booksInCart.reduce(7 (sum, book) =&gt; sum + book.price,8 09 );10 ...11&lt;/script&gt; 这样当booksInCart这个数据发生改变的时候，booksNumInCart和totalCheckoutPrice这个两个变量就会自动被重新计算。这时候我们再对界面进行操作的话，会发现统计数据会随着购物车的数据变化而自动发生改变： 总结我们的简易书店系统（bookshop）大概就实现了这些功能，现在来总结一下在开发项目的时候覆盖到的Svelte框架基础知识： 组件定义 - component definition 变量使用 - using variables props定义和参数传递 - props definition and passing 事件监听 - event listening 数据绑定 - data binding 条件判断 - if condition 列表数据展示 - each block 其实Svelte框架还有很多我没有提到的有用的功能特性，例如： 事件传递 - event forwarding 生命周期函数 - life-cycle functions 全局状态管理 - stores 上下文管理 - context CSS 动画 - css animation … 由于文章篇幅的限制我在这里没有覆盖Svelte所有的属性，大家兴趣可以看一下svelte的官方教程。 我个人对Svelte框架的一些看法个人觉得由于Virtual DOM的各种问题，Compiler as framework这个思路应该是前端框架发展的一个趋势。Svelte目前实现的功能虽然已经非常不错了，可是就目前来说我觉得它还有以下问题： Scalability - 可扩展性。React和Vue等框架自带的runtime虽然会增加首屏加载的bundle.js，可是当项目变得越来越大的时候，框架的runtime在bundle.js里面占据的比例也会越来越小，相反由于Svelte生成的代码的封装性没有React和Vue的好，它在大型项目中会不会堆积很多重复的代码呢？这个时候我们就得考虑一下是不是存在一个Svelte生成的代码大于React和Vue生成的代码的阈值了。这个问题现在还没有具体的答案，只能等后人实践的时候给出答案了，大家有兴趣可以看一下作者在github上面的讨论。 Ecosystem - 生态。作为一个最近才火起来的框架，Svelte的生态还远远不及已经普及那么多年的React和Vue，这也是我觉得就目前来说Svelte还撼动不了React和Vue的地位的原因。不过Svelte会不会因为它的先进性而迎来生态大爆发呢？我们可以拭目以待。 不过有一点可以肯定的是，Svelte由于在一些不复杂的项目中生成的代码远远比React，Vue和Angular小的优势会在一些性能不那么好的嵌入式操作系统中大放异彩。 学习Svelte有用的链接 作者的Rethinking reactivity演讲 Svelte官网 Svelte github仓库","link":"/2019/12/17/Svelte-3-%E5%88%9D%E5%AD%A6%E8%80%85%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"前端开发技巧","slug":"前端开发技巧","link":"/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"},{"name":"ECMAScript","slug":"ECMAScript","link":"/tags/ECMAScript/"},{"name":"2019","slug":"2019","link":"/tags/2019/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"Svelte","slug":"Svelte","link":"/tags/Svelte/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"}]}