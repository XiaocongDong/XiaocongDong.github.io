{"pages":[{"title":"about","text":"大家好，我是进击的大葱。我2016年毕业于北京邮电大学通信工程本科专业，现在正努力成为一个全面的全栈工程师。 我的梦想是通过自己的努力去改变别人，然后改变世界。 欢迎关注公众号进击的大葱一起学习成长","link":"/about/index.html"}],"posts":[{"title":"JavaScript小技巧 - 数组篇","text":"本文整理了一些在日常工作可以用到的JavaScript数组小技巧 去重巧用Set特性 1const arr = [1, 2, 2, 3, 4, 7, 7]2const uniqueArr = [...new Set(arr)]3console.log(uniqueArr)4// [1, 2, 3, 4, 7] 某一个位置插入元素改变原数组 1const arr = [1, 2, 3, 5, 6, 7]2arr.splice(3, 0, 4)3console.log(arr)4// [1, 2, 3, 4, 5, 6, 7] 不改变原数组 1const arr = [1, 2, 4, 5]2const indexNeededToInsert = 23const newArr = [...arr.slice(0, indexNeededToInsert), 3, ...arr.slice(indexNeededToInsert)]45console.log(newArr)6// [1, 2, 3, 4, 5]7console.log(arr)8// [1, 2, 4, 5] 删除某一个位置的元素不改变原数组 1const arr = [1, 2, 3, 4, 5]2const indexToBeRemoved = 33const filteredArr = arr.filter((_, index) =&gt; index !== indexToBeRemoved)4console.log(filteredArr)5// [1, 2, 3, 5]6console.log(arr)7// [1, 2, 3, 4, 5] 改变原数组 1const arr = [1, 2, 3, 4, 5]2const indexToBeRemoved = 33arr.splice(indexToBeRemoved, 1)4console.log(arr)5// [1, 2, 3, 5] 获取数组最后一个元素改变原数组 1const arr = [1, 2, 3, 4, 5]2const lastElement = arr.pop()3console.log(lastElement)4// 55console.log(arr)6// [1, 2, 3, 4] 不改变原数组 1const arr = [1, 2, 3, 4, 5]2const lastElement = arr.slice(-1)[0]3console.log(lastElement)4// 55console.log(arr)6// [1, 2, 3, 4, 5] slice第一个参数如果是负数表示从后面开始数起的第几个元素，-1表示倒数第一个元素。 清空数组1const arr = [1, 2, 3, 4, 5]2arr.length = 03console.log(arr)4// []5console.log(arr[0])6// undefined 生成一定长度的数组1const newArr = new Array(10)2console.log(newArr)3// [ &lt;10 empty items&gt; ] 两个数组的交集1const arr1 = [1, 2, 3, 4]2const arr2 = [2, 3]3const intersectedArr = arr1.filter(item1 =&gt; arr2.includes(item1))4console.log(intersectedArr)5// [2, 3] 合并多个数组1const arr1 = [1, 2, 3]2const arr2 = [4, 5, 6]3const arr3 = [7, 8, 9]4const mergedArr = [...arr1, ...arr2, ...arr3]5console.log(mergedArr)6// [1, 2, 3, 4, 5, 6, 7, 8, 9] 移除数组的虚假(falsy)值1const mixedArr = [0, “blue”, “”, NaN, 9, true, undefined, “white”, false]2const trueArr = mixedArr.filter(Boolean);3console.log(trueArr)4// [“blue”, 9, true, “white”] 求和1const nums = [1, 2, 3, 4, 5]2const sum = nums.reduce((currSum, num) =&gt; currSum + num)3console.log(sum)4// 15 个人技术动态欢迎关注公众号进击的大葱一起学习成长","link":"/2019/12/11/JavaScript%E5%B0%8F%E6%8A%80%E5%B7%A7-%E6%95%B0%E7%BB%84%E7%AF%87/"},{"title":"几个提高效率的console APIs","text":"console.log我相信写过JavaScript人一定都有接触过，它可谓是我们debug的灵丹妙药。可是除了log方法，你知道console还有很多可以帮你快速提高代码debug效率（逼格）的方法吗？ console.log | console.info | console.debug | console.warn | console.error使用场景输出不同类型（level）的内容。 用法这几个方法用起来都差不多，只不过输出结果可能会存在颜色上的区别：注意console.debug如果没有输出可以将log level中的verbose选上（chrome）: 替换字符串 - string substitution使用场景呈现输出时的上下文信息（context）。 用法现在支持以下替换字符串： 替换字符串 描述 %o 或者 %O JavaScript 对象，可以是整数、字符串或是 JSON 数据。 %d或者%i 整数。 %s 字符串。 %f 浮点数。 为输出添加CSS样式使用场景让内容更加结构化而且可以极大地提高逼格。 用法使用%c为某部分的输出内容定义样式： console.assert使用场景条件性输出。有些信息你可能只想在某些条件不满足的时候才进行输出，这个时候你可以用这种方法而不是加多个if判断。 用法1console.assert(condition, ...data) 注意只有condition是false的时候data才会被输出： console.table使用情景以表格的形式输出数据。这个方法最适用的场景我觉得是对象的数组，因为他可以让你一目了然地看到数组内对象各个属性的值。 用法 console.group使用情景当你有大量的内容要输出到界面上时，可以使用console.group方法为输出的内容添加一定的缩进来更好地整理这些内容。 用法这里要记住的是每个group都需要手动地调用groupEnd来退出。 console.trace使用情景追踪函数的执行栈。当你想知道一个函数具体是怎样被调用的时，可以使用console.trace这个函数去追踪它的执行栈。 用法 console.count使用场景统计代码的执行次数。 用法你还可以使用label去区分不同的统计类型： console.time使用场景记录代码执行的耗时，以毫秒（ms）为单位。 用法1console.time(timerName) 参考网站 https://developer.mozilla.org/en-US/docs/Web/API/Console https://medium.com/javascript-in-plain-english/mastering-js-console-log-like-a-pro-1c634e6393f9 个人技术动态欢迎关注公众号进击的大葱一起学习成长","link":"/2019/12/23/%E5%87%A0%E4%B8%AA%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84consoleAPIs/"},{"title":"详解ECMAScript2019/ES10新属性","text":"每年都有一些新的属性进入ECMA262标准，今年发布的ECMAScript2019/ES10同样也有很多新的特性，本文将会挑选一些普通开发者会用到的新属性进行深入的解读。 Array.prototype.flat() The flat() method creates a new array with all sub-array elements concatenated into it recursively up to the specified depth. – MDN 简单来说flat这个函数就是按照一定的深度depth将一个深层次嵌套的数组拍扁, 例子: 1const nestedArr = [1, 2, [3, 4, [5, 6, [7, [8], 9]]], 10]2console.log(nestedArr.flat())3// [1, 2, 3, 4, [5, 6, [7, [8], 9]], 10]4console.log(nestedArr.flat(2))5// [1, 2, 3, 4, 5, 6, [7, [8], 9], 10]6console.log(nestedArr.flat(3))7// [1, 2, 3, 4, 5, 6, 7, [8], 9, 10]8console.log(nestedArr.flat(4))9// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]10console.log(nestedArr.flat(Infinity))11// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 由上面的例子可以看出flat会按照指定的深度depth将一个数组扁平化，如果需要将数组完全拍扁变成一维数组，则指定depth为无限大，即是Infinity，相反如果不指定深度，其默认值是1。 Array.prototype.flatMap() The flatMap() method first maps each element using a mapping function, then flattens the result into a new array. It is identical to a map() followed by a flat() of depth 1, but flatMap() is often quite useful, as merging both into one method is slightly more efficient. – MDN 简单来说flatMap等于一个数组先调用完map函数再调用flat函数将其扁平化，扁平化的深度固定为1，先通过一个简单的例子感受一下: 1const myArr = [1, 2, 3]2myArr3 .map(n =&gt; [n * n]) // [[1], [4], [9]]4 .flat() // [1, 4, 9]56// 用flatMap可以一步到位7myArr.flatMap(n =&gt; [n * n]) // [1, 4, 9] 从上面的例子来看flatMap如果只是将flat和map做了一个简单的组合好像可有可无，其实不然，flatMap有个强大的功能是可以在map的时候添加和删除元素，这个无论是map还是filter都没有这个功能。 要想删除某一个元素只需要在mapper函数里面返回一个空的数组[], 而增加元素只需在mapper函数里面返回一个长度大于1的数组，具体可以看下面的例子： 1// 假如我们想要删除掉原数组里面所有的负数，同时将单数转换为一个复数和12const a = [5, 4, -3, 20, 17, -33, -4, 18]3// |\\ \\ x | | \\ x x |4// [4,1, 4, 20, 16,1, 18]5a.flatMap(n =&gt;6 (n &lt; 0) ? []: // 删除负数7 (n % 2 == 0) ? [n] : // 保留复数8 [n - 1, 1] // 单数变为一个复数和19)10// [4, 1, 4, 20, 20, 16, 1, 18] Object.fromEntries() The Object.fromEntries() method transforms a list of key-value pairs into an object. – MDN fromEntries方法将一个iterable对象返回的一系列键值对(key-value pairs)转换为一个object。先看一个简单的例子理解一下: 1// key-value pairs数组2const entriesArr = [['k1', 1], ['k2', 2]]3console.log(Object.fromEntries(entriesArr)4// {k1: 1, k2: 2}56const entriesMap = new Map([7 ['k1', 1],8 ['k2', 2]9]) // {\"k1\" =&gt; 1, \"k2\" =&gt; 2}10console.log(Object.fromEntries(entriesMap))11// {k1: 1, k2: 2} 再来看一个自定义的iterable对象例子深入理解一下: 1const iteratorObj = {2 [Symbol.iterator]: function () {3 const entries = [['k1', 1], ['k2', 2]]4 let cursor = 056 return {7 next() {8 const done = entries.length === cursor9 10 return {11 value: done ? undefined : entries[cursor++],12 done13 }14 }15 }16 }17}18Object.fromEntries(iteratorObj) // {k1: 1, k2: 2} 这个方法有一个用途就是对object的key进行filter，举个例子: 1const studentMap = {2 student1: {grade: 80},3 student2: {grade: 50},4 student3: {grade: 100}5}6const goodStudentMap = Object.fromEntries(7 Object8 .entries(studentMap)9 .filter(([_, meta]) =&gt; meta.grade &gt;= 60)10)11console.log(goodStudentMap)12// {student1: {grade: 80}, student3: {grade: 100}} String.prototype.trimStart这个方法很简单，就是返回一个将原字符串开头的空格字符去掉的新的字符串，例子: 1const greeting = ' Hello world! '2console.log(greeting.trimStart())3// 'Hello world! ' 这个方法还有一个别名函数，叫做trimLeft，它们具有一样的功能。 String.prototype.trimEnd这个方法和trimStart类似，只不过是将原字符串结尾的空格字符去掉，例子: 1const greeting = ' Hello world! '2console.log(greeting.trimEnd())3// ' Hello world!' 这个方法也有一个别名函数，叫做trimRight, 它们也具有一样的功能。 Symbol.prototype.description The read-only description property is a string returning the optional description of Symbol objects. – MDN ECMAScript2019给Symbol对象添加了一个可选的description属性，这个属性是个只读属性，看看例子: 1console.log(Symbol('desc').description)2// desc3console.log(Symbol.for('desc').description)4// desc56// 一些内置的Symbol也有这个属性7console.log(Symbol.iterator.description)8// Symbol.iterator910// 如果初始化时没有带description，这个属性会返回一个undefined，因为这样才说这个属性是可选的11console.log(Symbol().description)12// undefined1314// 这个属性是只读的，不能被设置15Symbol.iterator.description = 'mess it'16console.log(Symbol.iterator.description)17// Symbol.iterator 这个新的属性只要是为了方便开发者调试，不能通过比较两个Symbol对象的description来确定这两个Symbol是不是同一个Symbol: 1var s1 = Symbol(\"desc\")2var s2 = Symbol(\"desc\")3console.log(s1.description === s2.description)4// true5console.log(s1 === s2)6// false try catch optional bindingECMAScript2019之后，你写try…catch时如果没必要时可以不用声明error： 1// ECMAScript2019之前，你一定要在catch里面声明error，否则会报错2try {3 ...4} catch (error) {56}7// 可是有时候，你确实用不到这个error对象，于是你会写这样的代码8try {9 ...10} catch (_) {11 ...12}1314// ECMAScript2019后，你可以直接这样写了15try {16 ...17} catch {18 ...19} 虽然这个新属性可以让你省略掉error，可是我觉得开发者应该避免使用这个属性，因为在我看来所有的错误都应该被处理，至少应该被console.error出来，否则可能会有一些潜在的bug，举个例子： 1let testJSONObj2try {3 testJSONObj = JSON.prase(testStr)4} catch {5 testJSONObj = {}6}7console.log(testJSONObj) 以上代码中无论testStr是不是一个合法的JSON字符串，testJSONObj永远都是一个空对象，因为JSON.parse函数名写错了，而你又忽略了错误处理，所以你永远不会知道这个typo。 稳定的排序 Array.prototype.sortECMAScript2019后Array.sort一定是个稳定的排序。什么是稳定排序？所谓的稳定排序就是：假如没排序之前有两个相同数值的元素a[i]和a[j]，而且i在j前面，即i &lt; j，经过排序后元素a[i]依然排在a[j]元素的前面，也就是说稳定的排序不会改变原来数组里面相同数值的元素的先后关系。看个例子： 1var users = [2 {name: 'Sean', rating: 14},3 {name: 'Ken', rating: 14},4 {name: 'Jeremy', rating: 13}5]6users.sort((a, b) =&gt; a.rating - b.rating)7// 非稳定的排序结果可能是8// [9// {name: 'Jeremy', rating: 13}, 10// {name: 'Ken', rating: 14}, 11// {name: 'Sean', rating: 14}12// ]13// 虽然Sean和Ken具有同样的rating，可是非稳定的排序不能保证他们两个的顺序在排序后保持不变1415// ECMAScript2019后，Array.sort将是一个稳定的排序，也就是说它可以保证Sean和Ken两个人的顺序在排序后不变16// [17// {name: 'Jeremy', rating: 13}, 18// {name: 'Sean', rating: 14}, 19// {name: 'Ken', rating: 14}20// ] 改进Function.prototype.toString()ECMAScript2019之前，调用function的toString方法会将方法体里面的空格字符省略掉，例如: 1function hello() {2 console.log('hello word')3}45console.log(hello.toString())6//'function hello() {\\nconsole.log('hello word')\\n}' ECMAScript2019之后，要求一定要返回函数源代码（保留空格字符）或者一个标准的占位符例如native code，所以ECMAScript2019之后，以上的输出会变为： 1console.log(hello.toString())2//\"function hello() {3// console.log('hello word')4//}\" 个人技术动态欢迎关注公众号进击的大葱一起学习成长","link":"/2019/12/05/ECMAScript2019-ES10%E6%96%B0%E5%B1%9E%E6%80%A7/"},{"title":"React为什么需要Hook","text":"自从React 16.8发布Hook之后，笔者已经在实际项目中使用Hook快一年了，虽然Hook在使用中存在着一些坑，但是总的来说它是一个很好的功能，特别是在减少模板代码和提高代码复用率这些方面特别有用。为了让更多的人了解和使用Hook，我决定写一系列和Hook相关的文章，本篇文章就是这个系列的第一篇，主要和大家聊一下React为什么需要Hook。 Hook解决的问题Component非UI逻辑复用困难对于React或者其它的基于Component的框架来说，页面是由一个个UI组件构成的。独立的组件可以在同一个项目中甚至不同项目中进行复用，这十分有利于前端开发效率的提高。可是除了UI层面上的复用，一些状态相关（stateful）或者副作用相关（side effect）的非UI逻辑在不同组件之间复用起来却十分困难。对于React来说，你可以使用高阶组件（High-order Component）或者renderProps的方法来复用这些逻辑，可是这两种方法都不是很好，存在各种各样的问题。如果你之前没有复用过这些非UI逻辑的话，我们可以先来看一个高阶组件的例子。 假如你在开发一个社交App的个人详情页，在这个页面中你需要获取并展示当前用户的在线状态，于是你写了一个叫做UserDetail的组件： 1class UserDetail extends React.Component {2 state = {3 isOnline: false4 }56 handleUserStatusUpdate = (isOnline) =&gt; {7 this.setState({ isOnline })8 }910 componentDidMount() {11 // 组件挂载的时候订阅用户的在线状态12 userService.subscribeUserStatus(this.props.userId, this.handleUserStatusUpdate)13 }1415 componentDidUpdate(prevProps) {16 // 用户信息发生了变化17 if (prevProps.userId != this.props.userId) {18 // 取消上一个用户的状态订阅19 userService.unSubscribeUserStatus(this.props.userId, this.handleUserStatusUpdate)20 // 订阅下一个用户的状态21 userService.subscribeUserStatus(this.props.userId, this.handleUserStatusUpdate)22 }23 }2425 componentWillUnmount() {26 // 组件卸载的时候取消状态订阅27 userService.unSubscribeUserStatus(this.props.userId, this.handleUserStatusUpdate)28 }2930 render() {31 return (32 &lt;UserStatus isOnline={this.state.isOnline}&gt;33 )34 }35} 从上面的代码可以看出其实在UserDetail组件里面维护用户状态信息并不是一件简单的事情，我们既要在组件挂载和卸载的时候订阅和取消订阅用户的在线状态，而且还要在用户id发生变化的时候更新订阅内容。因此如果另外一个组件也需要用到用户在线状态信息的话，作为一个优秀如你的程序员肯定不想简单地对这部分逻辑进行复制和粘贴，因为重复的代码逻辑十分不利于代码的维护和重构。接着让我们看一下如何使用高阶组件的方法来复用这部分逻辑： 1// withUserStatus.jsx2const withUserStatus = (DecoratedComponent) =&gt; {3 class WrapperComponent extends React.Component {4 state = {5 isOnline: false6 }78 handleUserStatusUpdate = (isOnline) =&gt; {9 this.setState({ isOnline })10 }1112 componentDidMount() {13 // 组件挂载的时候订阅用户的在线状态14 userService.subscribeUserStatus(this.props.userId, this.handleUserStatusUpdate)15 }1617 componentDidUpdate(prevProps) {18 // 用户信息发生了变化19 if (prevProps.userId != this.props.userId) {20 // 取消上个用户的状态订阅21 userService.unSubscribeUserStatus(this.props.userId, this.handleUserStatusUpdate)22 // 订阅下个用户的状态23 userService.subscribeUserStatus(this.props.userId, this.handleUserStatusUpdate)24 }25 }2627 componentWillUnmount() {28 // 组件卸载的时候取消状态订阅29 userService.unSubscribeUserStatus(this.props.userId, this.handleUserStatusUpdate)30 }3132 render() {33 return &lt;DecoratedComponent34 isOnline={this.stateIsOnline}35 {...this.props}36 /&gt;37 }38 }3940 return WrapperComponent41} 在上面的代码中我们定义了用来获取用户在线状态的高阶组件，它维护了当前用户的在线状态信息并把它作为参数传递给被装饰的组件。接着我们就可以使用这个高阶组件来重构UserDetail组件的代码了： 1import withUserStatus from 'somewhere'23class UserDetail {4 render() {5 return &lt;UserStatus isOnline={this.props.isOnline}&gt;6 }7}89export default withUserStatus(UserDetail) 我们可以看到使用了withUserStatus高阶组件后，UserDetail组件的代码一下子变得少了很多，现在它只需要从父级组件中获取到isOnline参数进行展示就好。而且这个高阶组件可以套用在其它任何需要获取用户在线状态信息的组件上，你再也不需要在前端维护一样的代码了。 这里要注意的是上面的高阶组件封装的逻辑和UI展示没有太大关系，它维护的是用户在线状态信息的获取和更新这些和外面世界交互的side effect，以及用户状态的存储这些和组件状态相关的逻辑。虽然看起来似乎代码很优雅，不过使用高阶组件来封装组件的这些逻辑其实会有以下的问题： 高阶组件的开发对开发者不友好：开发者（特别是初级开发者）需要花费一段时间才能搞懂其中的原理并且适应它的写法。如果你使用高阶组件已经很久了，你看到这个说法可能会有些不以为然。可是我相信你在最开始接触高阶组件的时候肯定也花了一段时间才能搞懂它的原理，而且从上面的例子来看高阶组件其实是十分笨重的。试想一下，某天你的项目来了一个React新手，估计他也得花费一段时间才能理解你写的那些高阶组件代码吧。 高阶组件之间组合性差：使用过高阶组件的同学一定试过由于要为组件添加不同的功能，我们要为同一个组件嵌套多个高阶组件，例如这样的代码：withAuth(withRouter(withUserStatus(UserDetail)))。这种嵌套写法的高阶组件可能会导致很多问题，其中一个就是props丢失的问题，例如withAuth传递给UserDetail的某个prop可能在withUserStatus组件里面丢失或者被覆盖了。如果你使用的高阶组件都是自己写的话还好，因为调试和修改起来都比较简单，如果你使用的是第三方的库的话就很头痛了。 容易发生wrapper hell：这个问题在上面嵌套多重高阶组件的时候就会出现，具体会造成我们在React Devtools查看和调试某个组件的时候十分困难。我们可以看幅图片来感受一下：这真是高阶组件一时爽，出问题就火葬场的感觉有没有。 和高阶组件类似，renderProps也会存在同样的问题。基于这些原因，React需要一个新的用来复用组件之间非UI逻辑的方法，所以Hook就这么诞生了。总的来说，Hook相对于高阶组件和renderProps在复用代码逻辑方面有以下的优势： 写法简单：每一个Hook都是一个函数，因此它的写法十分简单，而且开发者更容易理解。 组合简单：Hook组合起来十分简单，组件只需要同时使用多个hook就可以使用到它们所有的功能。 容易扩展：Hook具有很高的可扩展性，你可以通过自定义Hook来扩展某个Hook的功能。 没有wrapper hell：Hook不会改变组件的层级结构，也就不会有wrapper hell问题的产生。 除了用来替代难用的HOC和renderProps来解决组件非UI逻辑复用的问题之外，其实Hook还解决了以下这些问题。 组件的生命周期函数不适合side effect逻辑的管理在上面UserDetail组件中我们将获取用户的在线状态这个side effect的相关逻辑分散到了componentDidMount，componentWillUnmount，componentDidUpdate三个生命周期函数中，这些互相关联的逻辑被分散到不同的函数中会导致bug的发生和产生数据不一致的情况。除了这个，我们还可能会在组件的同一个生命周期函数放置很多互不关联的side effect逻辑。举个例子，如果我们想在用户查看某个用户的详情页面的时候将浏览器当前标签页的title改为当前用户名的话，就需要在组件的componentDidMount生命周期函数里面添加document.title = this.props.userName这段代码，可是这段代码和之前订阅用户状态的逻辑是互不关联的，而且随着组件的功能变得越来越复杂，这些不关联而又放在一起的代码只会变得越来越多，于是你的组件逐渐变得难以测试。由此可见Class Component的生命周期函数并不适合用来管理组件的side effect逻辑。 那么这个问题Hook又是如何解决的呢？由于每个Hook都是一个函数，所以你可以将和某个side effect相关的逻辑都放在同一个函数（Hook）里面（useEffect Hook）。这种做法有很多好处，首先关联的代码都放在一起，可以十分方便代码的维护，其次实现了某个side effect的Hook还可以被不同的组件进行复用来提高开发效率。举个例子，我们就可以将改变标签页title的逻辑封装在一个自定的Hook中，如果其它组件有相同逻辑的话就可以使用这个Hook了： 1// 自定义Hook2function useTabTitle(title) {3 React.useEffect(() =&gt; {4 document.title = title5 }, [title])6}78// UserDetail中使用useTabTitle Hook9function UserDetail = (props) =&gt; {10 useTabTitle(props.userName)11 ...12} 这个复用side effect的功能其实是一个十分强大的功能，你可以检查一下你现在写的项目代码，肯定有很多组件的side effect是可以封装成Hook的。封装成Hook的side effect不仅仅可以在某一个项目中使用，还可以在不同项目中复用，这对我们的开发效率肯定会有很大的提升。 不友好的Class Component其实Class Component除了生命周期函数不适合side effect的管理之外，还有一些其它的问题。 首先Class Component对开发者不友好。如果你要使用Class Component首先你得理解JS里面的this是怎么使用的，它的使用方法其实和其他语言有很大的区别。由于JS本身的原因，在Class Component中你要手动为注册的event listener绑定this，不然就会报this is undefined的错误，早期的React玩家肯定体验过每个事件监听函数都要手动绑定this的酸爽感觉，乏味而且容易引发bug，这个问题直到class properties出来之后才有所改善。 1class UserDetail extends React.Component {2 constructor(props) {3 super(props)4 this.handlerUserStatusUpdate = this.handleUserStatusUpdate.bind(this)5 ...6 }7} 除了对开发者不友好，Class Component对机器也很不友好。例如Class Component的生命周期函数很难被minified。其次，Class Component的存在可能会阻碍React后面的发展。举个例子，随着新的理念 - Compiler as Framework的兴起，一些诸如Svelte, Angular和Glimmer的框架将框架的概念放到了编译时以去除production code里面的runtime代码来加快应用的首屏加载速度，这个方案已经开始被逐渐采纳了，而且未来有可能会成为潮流。如果大家不是很了解Compiler as Framework理念的话，可以看我的另外一篇文章：Svelte 3 初学者完全指南。React已经存在了5年，它如果想要继续存在多五年的话也要跟上这个潮流，出于这个原因，React团队和Prepack团队进行了一些和Compiler as Framework相关的尝试，而且就目前实验的结果来说这个思路有很大的想象空间。不过在这个过程中React的开发者也发现了一个严重的问题，那就是开发者可能会以一种非常规的模式来使用Class Component，而这些模式会降低这个方案带来的优化效果。 因此React要想得到进一步的发展的话，就必须让开发者更多地使用Function Component而不是Class Component。而开发者偏向于使用Class Component而不是Function Component的一个主要原因是Function Component没有状态管理和生命周期函数等功能。Hook出来后这个问题就不存在了，因为开发者可以使用useState Hook来在Function Component使用state以及useEffect Hook来实现一些和生命周期函数类似的功能。最重要的是，React将所有复杂的实现都封装在框架里面了，开发者无需学习函数式编程和响应式编程的概念也可以很好地使用Hook来进行开发。 总结本篇文章我主要论述了React为啥要有Hook，总的来说是以下三个原因： Component非UI逻辑复用困难。 组件的生命周期函数不适合side effect逻辑的管理。 不友好的Class Component。 如果你有其他的补充或者觉得我有什么地方说得不对的话可以在评论区和我一起探讨，在后面一篇文章中我将会为大家深入介绍一些常用的Hook。 参考文献 React Today and Tomorrow and 90% Cleaner React With Hooks React Hook RFC 个人技术动态欢迎关注公众号进击的大葱一起学习成长","link":"/2020/04/29/React%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Hook/"},{"title":"窥探现代浏览器架构(一)","text":"前言本文是笔者对Mario Kosaka写的inside look at modern web browser系列文章的翻译。这里的翻译不是指直译，而是结合个人的理解将作者想表达的意思表达出来，而且会尽量补充一些相关的内容来帮助大家更好地理解。 CPU，GPU，内存和多进程架构在这个4集系列教程里面，我将会从Chrome浏览器的高层次架构（high-level architecture）开始说起，一直深入讲到页面渲染流水线（rendering pipeline）的具体细节。如果你想知道浏览器是怎么把你编写的代码转变成一个可用的网站，或者你不知道为什么一些特定的代码写法可以提高网站的性能的，那你就来对地方了，这篇文章就是为你准备的。 作为本系列文章的第一篇，我们会先了解一些关键的计算机术语以及Chrome浏览器的多进程架构。 计算机的核心 - CPU和GPU要想理解浏览器的运行环境，我们先要搞明白一些计算机组件以及它们的作用。 CPU首先我们要说的是计算机的大脑 - CPU（Central Processing Unit）。CPU是计算机里面的一块芯片，上面有一个或者多个核心（core）。我们可以把CPU的一个核心（core）比喻成一个办公室工人，他功能强大，上知天文下知地理，琴棋书画无所不能，它可以串行地一件接着一件处理交给它的任务。很久之前的时候大多数CPU只有一个核心，不过在现在的硬件设备上CPU通常会有多个核心，因为多核心CPU可以大大提高手机和电脑的运算能力。 四个CPU核心愉快地在各自工位上一个接着一个地处理交给它们的任务 GPU图形处理器 - 或者说GPU（Graphics Processing Unit）是计算机的另外一个重要组成部分。和功能强大的CPU核心不一样的是，单个GPU核心只能处理一些简单的任务，不过它胜在数量多，单片GPU上会有很多很多的核心可以同时工作，也就是说它的并行计算能力是非常强的。图形处理器（GPU）顾名思义一开始就是专门用来处理图形的，所以在说到图形使用GPU（using）或者GPU支持（backed）时，人们就会联想到图形快速渲染或者流畅的用户体验相关的概念。最近几年来，随着GPU加速概念的流行，在GPU上单独进行的计算也变得越来越多了。 每个GPU核心手里只有一个扳手，这就说明它的能力是非常有限的，可是它们人多啊！ 当你在手机或者电脑上打开某个应用程序的时候，背后其实是CPU和GPU支撑着这个应用程序的运行。通常来说，你的应用要通过操作系统提供的一些机制才能跑在CPU和GPU上面。 计算机的三层架构，最下层是硬件机器，操作系统夹在中间，最上层是运行的应用 在进程和线程上执行程序在深入到浏览器的架构之前我们还得了解一下进程（process）和线程（thread）的相关概念。进程可以看成正在被执行的应用程序（executing program）。而线程是跑在进程里面的，一个进程里面可能有一个或者多个线程，这些线程可以执行任何一部分应用程序的代码。 进程就像一个大鱼缸，而线程就是浴缸里面畅游的鱼儿 当你启动一个应用程序的时候，操作系统会为这个程序创建一个进程同时还为这个进程分配一片私有的内存空间，这片空间会被用来存储所有程序相关的数据和状态。当你关闭这个程序的时候，这个程序对应的进程也会随之消失，进程对应的内存空间也会被操作系统释放掉。 进程使用系统分配的内存空间去存储应用的数据 有时候为了满足功能的需要，创建的进程会叫系统创建另外一些进程去处理其它任务，不过新建的进程会拥有全新的独立的内存空间而不是和原来的进程共用内存空间。如果这些进程需要通信，它们要通过IPC机制（Inter Process Communication）来进行。很多应用程序都会采取这种多进程的方式来工作，因为进程和进程之间是互相独立的它们互不影响，换句话来书，如果其中一个工作进程（worker process）挂掉了其他进程不会受到影响，而且挂掉的进程还可以重启。 不同的进程通过IPC来通信 浏览器架构那么浏览器是怎么使用进程和线程来工作的呢？其实大概可以分为两种架构，一种是单进程架构，也就是只启动一个进程，这个进程里面有多个线程工作。第二种是多进程架构，浏览器会启动多个进程，每个进程里面有多个线程，不同进程通过IPC进行通信。 单进程和多进程浏览器的架构图 上面的图表架构其实包含了浏览器架构的具体实现了，在现实中其实并没有一个大家都遵循的浏览器实现标准，所以不同浏览器的实现方式可能会完全不一样。 为了更好地在本系列文章中展开论述，我们主要讨论最新的Chrome浏览器架构，它采用的是多进程架构，以下是架构图： Chrome的多进程架构图，多个渲染进程的卡片（render process）是用来表明Chrome会为每一个tab创建一个渲染进程。 Chrome浏览器会有一个浏览器进程（browser process），这个进程会和其他进程一起协作来实现浏览器的功能。对于渲染进程（renderer process），Chrome会尽可能为每一个tab甚至是页面里面的每一个iframe都分配一个单独的进程。 各个进程如何分工合作呢？以下是各个进程具体负责的工作内容： 进程 负责的工作 Browser 负责浏览器的“Chrome”部分， 包括导航栏，书签， 前进和后退按钮。同时这个进程还会控制那些我们看不见的部分，包括网络请求的发送以及文件的读写。 Renderer 负责tab内和网页展示相关的所有工作。 Plugin 控制网页使用的所有插件，例如flash插件。 GPU 负责独立于其它进程的GPU任务。它之所以被独立为一个进程是因为它要处理来自于不同tab的渲染请求并把它在同一个界面上画出来。 不同的进程负责浏览器不同部分的界面内容 除了上面列出来的进程，Chrome还有很多其他进程在工作，例如扩展进程（Extension Process）和工具进程（utility process）。如果你想看一下你的Chrome浏览器现在有多少个进程在跑可以点击浏览器右上角的更多按钮，选择更多工具和任务管理器：在弹出的窗口里面你会看到正在工作的进程列表，以及每个进程使用的CPU和内存状况。 Chrome多进程架构的好处那么为什么Chrome会采取多进程架构工作呢？ 其中一个好处是多进程可以使浏览器具有很好的容错性。对于大多数简单的情景来说，Chrome会为每个tab单独分配一个属于它们的渲染进程（render process）。举个例子，假如你有三个tab，你就会有三个独立的渲染进程。当其中一个tab的崩溃时，你可以随时关闭这个tab并且其他tab不受到影响。可是如果所有的tab都跑在同一个进程的话，它们就会有连带关系，一个挂全部挂。 不同的tab会有不同的渲染进程来负责 Chrome采用多进程架构的另外一个好处就是可以提供安全性和沙盒性（sanboxing）。因为操作系统可以提供方法让你限制每个进程拥有的能力，所以浏览器可以让某些进程不具备某些特定的功能。例如，由于tab渲染进程可能会处理来自用户的随机输入，所以Chrome限制了它们对系统文件随机读写的能力。 不过多进程架构也有它不好的地方，那就是进程的内存消耗。由于每个进程都有各自独立的内存空间，所以它们不能像存在于同一个进程的线程那样共用内存空间，这就造成了一些基础的架构（例如V8 JavaScript引擎）会在不同进程的内存空间同时存在的问题，这些重复的内容会消耗更多的内存。所以为了节省内存，Chrome会限制被启动的进程数目，当进程数达到一定的界限后，Chrome会将访问同一个网站的tab都放在一个进程里面跑。 节省更多的内存 - Chrome的服务化同样的优化方法也可以被使用在浏览器进程（browser process）上面。Chrome浏览器的架构正在发生一些改变，目的是将和浏览器本身（Chrome）相关的部分拆分为一个个不同的服务，服务化之后，这些功能既可以放在不同的进程里面运行也可以合并为一个单独的进程运行。 这样做的主要原因是让Chrome在不同性能的硬件上有不同的表现。当Chrome运行在一些性能比较好的硬件时，浏览器进程相关的服务会被放在不同的进程运行以提高系统的稳定性。相反如果硬件性能不好，这些服务就会被放在同一个进程里面执行来减少内存的占用。其实在这次架构变化之前，Chrome在Android上面已经开始采取类似的做法了。 Chrome将浏览器相关的服务放在同一个进程里面运行和放在不同的进程运行的区别 单帧渲染进程 - 网站隔离（Site Isolation）网站隔离（Site Isolation）是最近Chrome浏览器启动的功能，这个功能会为网站内不同站点的iframe分配一个独立的渲染进程。之前说过Chrome会为每个tab分配一个单独的渲染进程，可是如果一个tab只有一个进程的话不同站点的iframe都会跑在这个进程里面，这也意味着它们会共享内存，这就有可能会破坏同源策略。同源策略是浏览器最核心的安全模型，它可以禁止网站在未经同意的情况下去获取另外一个站点的数据，因此绕过同源策略是很多安全攻击的主要目的。而进程隔离（proces isolation）是隔离网站最好最有效的办法了。再加上CPU存在Meltdown和Spectre的隐患，网站隔离变得势在必行。因此在Chrome 67版本之后，桌面版的Chrome会默认开启网站隔离功能，这样每一个跨站点的iframe都会拥有一个独立的渲染进程。 网站隔离功能会让跨站的iframe拥有独立的进程 网站隔离技术汇聚了我们工程师好几年的研发努力，它其实远远没有想象中那样只是为不同站点的iframe分配一个独立的渲染进程那么简单，因为它从根本上改变了各个iframe之间的通信方式。网站隔离后，对于有iframe的网站，当用户打开右边的devtool时，Chrome浏览器其实要做很多幕后工作才能让开发者感觉不出这和之前的有什么区别，这其实是很难实现的。对于一些很简单的功能，例如在devtool里面用Ctrl + F键在页面搜索某个关键词，Chrome都要遍历多个渲染进程去完成。所以我们的浏览器工程师在网站隔离这个功能发布后都感叹这是一个里程碑式的成就。 总结在本篇文章中，我们探讨了浏览器高层次的架构设计以及多进程架构的带来的好处。同时我们还讨论了服务化和网站隔离这些和浏览器多进程架构息息相关的技术。在下一篇文章中我们要开始深入了解这些进程和线程是如何呈现我们的网站页面的了。 个人技术动态欢迎关注公众号进击的大葱一起学习成长","link":"/2019/12/25/%E7%AA%A5%E6%8E%A2%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84-%E4%B8%80/"},{"title":"窥探现代浏览器架构(二)","text":"前言本文是笔者对Mario Kosaka写的inside look at modern web browser系列文章的翻译。这里的翻译不是指直译，而是结合个人的理解将作者想表达的意思表达出来，而且会尽量补充一些相关的内容来帮助大家更好地理解。 导航的时候都发生了什么这篇文章是探究Chrome内部工作原理的四集系列文章中的第二篇，在上一篇文章中我们探讨了不同进程或者线程是如何负责浏览器各个不同部分的工作的。在这篇文章中，我们将会深入了解每个进程和线程是如何沟通协作来为我们呈现出网站内容的。 让我们来看一个用户浏览网页最简单的情景：你在浏览器导航栏里面输入一个URL然后按下回车键，浏览器接着会从互联网上获取相关的数据并把网页展示出来。在本篇文章中，我们将会重点关注这个简单场景中网站数据请求以及浏览器在呈现网页之前做的准备工作 - 也就是导航（navigation）的过程。 一切都从浏览器进程开始我们在上一篇文章CPU，GPU，内存和多进程架构中提到，浏览器中tab外面发生的一切都是由浏览器进程（browser process）控制的。浏览器进程有很多负责不同工作的线程（worker thread），其中包括绘制浏览器顶部按钮和导航栏输入框等组件的UI线程（UI thread）、管理网络请求的网络线程（network thread）、以及控制文件读写的存储线程（storage thread）等。当你在导航栏里面输入一个URL的时候，其实就是UI线程在处理你的输入。 UI，网络和存储线程都是属于浏览器进程的 一次简单的导航第一步：处理输入当用户开始在导航栏上面输入内容的时候，UI线程（UI thread）做的第一件事就是询问：“你输入的字符串是一些搜索的关键词（search query）还是一个URL地址呢？”。因为对于Chrome浏览器来说，导航栏的输入既可能是一个可以直接请求的域名还可能是用户想在搜索引擎（例如Google）里面搜索的关键词信息，所以当用户在导航栏输入信息的时候UI线程要进行一系列的解析来判定是将用户输入发送给搜索引擎还是直接请求你输入的站点资源。 UI线程在询问输入的字符串是搜索关键词还是一个URL 第二步：开始导航当用户按下回车键的时候，UI线程会叫网络线程（network thread）初始化一个网络请求来获取站点的内容。这时候tab上会展示一个提示资源正在加载中的旋转圈圈，而且网络线程会进行一系列诸如DNS寻址以及为请求建立TLS连接的操作。 UI线程告诉网络线程跳转到mysite.com 这时如果网络线程收到服务器的HTTP 301重定向响应，它就会告知UI线程进行重定向然后它会再次发起一个新的网络请求。 第三步：读取响应网络线程在收到HTTP响应的主体（payload）流（stream）时，在必要的情况下它会先检查一下流的前几个字节以确定响应主体的具体媒体类型（MIME Type）。响应主体的媒体类型一般可以通过HTTP头部的Content-Type来确定，不过Content-Type有时候会缺失或者是错误的，这种情况下浏览器就要进行MIME类型嗅探来确定响应类型了。MIME类型嗅探并不是一件容易的事情，你可以从Chrome的源代码的注释来了解不同浏览器是如何根据不同的Content-Type来判断出主体具体是属于哪个媒体类型的。 响应的头部有Content-Type信息，而响应的主体有真实的数据 如果响应的主体是一个HTML文件，浏览器会将获取的响应数据交给渲染进程（renderer process）来进行下一步的工作。如果拿到的响应数据是一个压缩文件（zip file）或者其他类型的文件，响应数据就会交给下载管理器（download manager）来处理。 网络线程在询问响应的数据是不是来自安全源的HTML文件 网络线程在把内容交给渲染进程之前还会对内容做SafeBrowsing检查。如果请求的域名或者响应的内容和某个已知的病毒网站相匹配，网络线程会给用户展示一个警告的页面。除此之外，网络线程还会做CORB（Cross Origin Read Blocking）检查来确定那些敏感的跨站数据不会被发送至渲染进程。 第四步：寻找一个渲染进程（renderer process）在网络线程做完所有的检查后并且能够确定浏览器应该导航到该请求的站点，它就会告诉UI线程所有的数据都已经被准备好了。UI线程在收到网络线程的确认后会为这个网站寻找一个渲染进程（renderer process）来渲染界面。 网络线程告诉UI线程去寻找一个渲染进程来渲染界面 由于网络请求可能需要长达几百毫秒的时间才能完成，为了缩短导航需要的时间，浏览器会在之前的一些步骤里面做一些优化。例如在第二步中当UI线程发送URL链接给网络线程后，它其实已经知晓它们要被导航到哪个站点了，所以在网络线程干活的时候，UI线程会主动地为这个网络请求启动一个渲染线程。如果一切顺利的话（没有重定向之类的东西出现），网络线程准备好数据后页面的渲染进程已经就准备好了，这就节省了新建渲染进程的时间。不过如果发生诸如网站被重定向到不同站点的情况，刚刚那个渲染进程就不能被使用了，它会被摒弃，一个新的渲染进程会被启动。 第五步：提交（commit）导航到这一步的时候，数据和渲染进程都已经准备好了，浏览器进程（browser process）会通过IPC告诉渲染进程去提交本次导航（commit navigation）。除此之外浏览器进程还会将刚刚接收到的响应数据流传递给对应的渲染进程让它继续接收到来的HTML数据。一旦浏览器进程收到渲染线程的回复说导航已经被提交了（commit），导航这个过程就结束了，文档的加载阶段（document loading phase）会正式开始。 到了这个时候，导航栏会被更新，安全指示符（security indicator）和站点设置UI（site settings UI）会展示新页面相关的站点信息。当前tab的回话历史（session history）也会被更新，这样当你点击浏览器的前进和后退按钮也可以导航到刚刚导航完的页面。为了方便你在关闭了tab或窗口（window）的时候还可以恢复当前tab和会话（session）内容，当前的会话历史会被保存在磁盘上面。 浏览器进程通过IPC来对渲染进程发起渲染页面的请求 额外步骤：初始加载完成（Initial load complete）当导航提交完成后，渲染进程开始着手加载资源以及渲染页面。我会在后面系列文章中讲述渲染进程渲染页面的具体细节。一旦渲染进程“完成”（finished）渲染，它会通过IPC告知浏览器进程（注意这发生在页面上所有帧（frames）的onload事件都已经被触发了而且对应的处理函数已经执行完成了的时候），然后UI线程就会停止导航栏上旋转的圈圈。 我这里用到“完成”这个词，因为后面客户端的JavaScript还是可以继续加载资源和改变视图内容的。 渲染进程通过IPC告诉浏览器进程页面已经加载完成了 导航到不同的站点一个最简单的导航情景已经描述完了！可是如果这时用户在导航栏上输入一个不一样的URL会发生什么呢？如果是这样，浏览器进程会重新执行一遍之前的那几个步骤来完成新站点的导航。不过在浏览器进程做这些事情之前，它需要让当前的渲染页面做一些收尾工作，具体就是询问一下当前的渲染进程需不需要处理一下beforeunload事件。 beforeunload可以在用户重新导航或者关闭当前tab时给用户展示一个“你确定要离开当前页面吗？”的二次确认弹框。浏览器进程之所以要在重新导航的时候和当前渲染进程确认的原因是，当前页面发生的一切（包括页面的JavaScript执行）是不受它控制而是受渲染进程控制，所以它也不知道里面的具体情况。 注意：不要随便给页面添加beforeunload事件监听，你定义的监听函数会在页面被重新导航的时候执行，因此这会增加重导航的时延。beforeunload事件监听函数只有在十分必要的时候才能被添加，例如用户在页面上输入了数据，并且这些数据会随着页面消失而消失。 浏览器进程通过IPC告诉渲染进程它将要离开当前页面导航到新的页面了 如果重新导航是在页面内被发起的呢？例如用户点击了页面的一个链接或者客户端的JavaScript代码执行了诸如window.location = “https://newsite.com&quot;的代码。这种情况下，渲染进程会自己先检查一个它有没有注册beforeunload事件的监听函数，如果有的话就执行，执行完后发生的事情就和之前的情况没什么区别了，唯一的不同就是这次的导航请求是由渲染进程给浏览器进程发起的。 如果是重新导航到不同站点（different site）的话，会有另外一个渲染进程被启动来完成这次重导航，而当前的渲染进程会继续处理现在页面的一些收尾工作，例如unload事件的监听函数执行。Overview of page lifecycle states这篇文章会介绍页面所有的生命周期状态，the Page Lifecycle API会教你如何在页面中监听页面状态的变化。 浏览器进程告诉新的渲染进程去渲染新的页面并且告诉当前的渲染进程进行收尾工作 Service Worker的情景这个导航过程最近发生的一个改变是引进了service worker的概念。因为Service worker可以用来写网站的网络代理（network proxy），所以开发者可以对网络请求有更多的控制权，例如决定哪些数据缓存在本地以及哪些数据需要从网络上面重新获取等等。如果开发者在service worker里设置了当前的页面内容从缓存里面获取，当前页面的渲染就不需要重新发送网络请求了，这就大大加快了整个导航的过程。 这里要重点留意的是service worker其实只是一些跑在渲染进程里面的JavaScript代码。那么问题来了，当导航开始的时候，浏览器进程是如何判断要导航的站点存不存在对应的service worker并启动一个渲染进程去执行它的呢？ 其实service worker在注册的时候，它的作用范围（scope）会被记录下来（你可以通过文章The Service Worker Lifecycle了解更多关于service worker作用范围的信息）。在导航开始的时候，网络线程会根据请求的域名在已经注册的service worker作用范围里面寻找有没有对应的service worker。如果有命中该URL的service worker，UI线程就会为这个service worker启动一个渲染进程（renderer process）来执行它的代码。Service worker既可能使用之前缓存的数据也可能发起新的网络请求。 网络线程会在收到导航任务后寻找有没有对应的service worker UI线程会启动一个渲染进程来运行找到的service worker代码，代码具体是由渲染进程里面的工作线程（worker thread）执行 导航预加载 - Navigation Preload在上面的例子中，你应该可以感受到如果启动的service worker最后还是决定发送网络请求的话，浏览器进程和渲染进程这一来一回的通信包括service worker启动的时间其实增加了页面导航的时延。导航预加载就是一种通过在service worker启动的时候并行加载对应资源的方式来加快整个导航过程效率的技术。预加载资源的请求头会有一些特殊的标志来让服务器决定是发送全新的内容给客户端还是只发送更新了的数据给客户端。 UI线程在启动一个渲染进程去运行service worker代码的同时会并行发送网络请求 总结在本篇文章中，我们讨论了导航具体都发生了哪些事情以及浏览器优化导航效率采取的一些技术方案，在下一篇文章中我们将会深入了解浏览器是如何解析我们的HTML/CSS/JavaScript来呈现出网页内容的。 个人技术动态欢迎关注公众号进击的大葱一起学习成长","link":"/2019/12/27/%E7%AA%A5%E6%8E%A2%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84-%E4%BA%8C/"},{"title":"窥探现代浏览器架构-四","text":"前言本文是笔者对Mario Kosaka写的inside look at modern web browser系列文章的翻译。这里的翻译不是指直译，而是结合个人的理解将作者想表达的意思表达出来，而且会尽量补充一些相关的内容来帮助大家更好地理解。 到达合成线程的输入这篇文章是探究Chrome内部工作原理的四集系列文章中的最后一篇了。在上一篇文章中，我们探讨了一下浏览器渲染页面的过程以及学习了一些关于合成线程的知识，在本篇文章中，我们要看一下当用户在网页上输入内容的时候，合成线程（compositor）做了些什么来保证流畅的用户体验的。 从浏览器的角度来看输入事件当你听到“输入事件”（input events）的时候，你可能只会想到用户在文本框中输入内容或者对页面进行了点击操作，可是从浏览器的角度来看的话，输入其实代表着来自于用户的任何手势动作（gesture）。所以用户滚动页面，触碰屏幕以及移动鼠标等操作都可以看作来自于用户的输入事件。 当用户做了一些诸如触碰屏幕的手势动作时，浏览器进程（browser process）是第一个可以接收到这个事件的地方。可是浏览器进程只能知道用户的手势动作发生在什么地方而不知道如何处理，这是因为标签内（tab）的内容是由页面的渲染进程（render process）负责的。因此浏览器进程会将事件的类型（如touchstart）以及坐标（coordinates）发送给渲染进程。为了可以正确地处理这个事件，渲染进程会找到事件的目标对象（target）然后运行这个事件绑定的监听函数（listener）。 点击事件从浏览器进程路由到渲染进程 合成线程接收到输入事件在上一篇文章中，我们查看了合成线程是如何通过合并页面已经光栅化好的层来保障流畅滚动体验（scroll smoothly）的。如果当前页面不存在任何用户事件的监听器（event listener），合成线程完全不需要主线程的参与就能创建一个新的合成帧来响应事件。可是如果页面有一些事件监听器（event listeners）呢？合成线程是如何判断出这个事件是否需要路由给主线程处理的呢？ 了解非快速滚动区域 - non-fast scrollable region因为页面的JavaScript脚本是在主线程（main thread）中运行的，所以当一个页面被合成的时候，合成线程会将页面那些注册了事件监听器的区域标记为“非快速滚动区域”（Non-fast Scrollable Region）。由于知道了这些信息，当用户事件发生在这些区域时，合成线程会将输入事件发送给主线程来处理。如果输入事件不是发生在非快速滚动区域，合成线程就无须主线程的参与来合成一个新的帧。 非快速滚动区域有用户事件发生时的示意图 当你写事件监听器的时候留点心眼Web开发的一个常见的模式是事件委托（event delegation）。由于事件会冒泡，你可以给顶层的元素绑定一个事件监听函数来作为其所有子元素的事件委托者，这样子节点的事件就可以统一被顶层的元素处理了。因此你可能看过或者写过类似于下面的代码： 1document.body.addEventListener('touchstart', event =&gt; {2 if (event.target === area) {3 event.preventDefault()4 }5}) 只用一个事件监听器就可以服务到所有的元素，乍一看这种写法还是挺实惠的。可是，如果你从浏览器的角度去看一下这段代码，你会发现上面给body元素绑定了事件监听器后其实是将整个页面都标记为一个非快速滚动区域，这就意味着即使你页面的某些区域压根就不在乎是不是有用户输入，当用户输入事件发生时，合成线程每次都会告知主线程并且会等待主线程处理完它才干活。因此这种情况下合成线程就丧失提供流畅用户体验的能力了（smooth scrolling ability）。 当整个页面都是非快速滚动区域时页面的事件处理示意图 为了减轻这种情况的发生，您可以为事件监听器传递passive：true选项。 这个选项会告诉浏览器您仍要在主线程中侦听事件，可是合成线程也可以继续合成新的帧。 1document.body.addEventListener('touchstart', event =&gt; {2 if (event.target === area) {3 event.preventDefault()4 }5 }, {passive: true}); 查找事件的目标对象（event target）当合成线程向主线程发送输入事件时，主线程要做的第一件事是通过命中测试（hit test）去找到事件的目标对象（target）。具体的命中测试流程是遍历在渲染流水线中生成的绘画记录（paint records）来找到输入事件出现的x, y坐标上面描绘的对象是哪个。 主线程通过遍历绘画记录来确定在x，y坐标上的是哪个对象 最小化发送给主线程的事件数上一篇文章中我们有说过显示器的刷新频率通常是一秒钟60次以及我们可以通过让JavaScript代码的执行频率和屏幕刷新频率保持一致来实现页面的平滑动画效果（smooth animation）。对于用户输入来说，触摸屏一般一秒钟会触发60到120次点击事件，而鼠标一般则会每秒触发100次事件，因此输入事件的触发频率其实远远高于我们屏幕的刷新频率。 如果每秒将诸如touchmove这种连续被触发的事件发送到主线程120次，因为屏幕的刷新速度相对来说比较慢，它可能会触发过量的点击测试以及JavaScript代码的执行。 事件淹没了屏幕刷新的时间轴，导致页面很卡顿 为了最大程度地减少对主线程的过多调用，Chrome会合并连续事件（例如wheel，mousewheel，mousemove，pointermove，touchmove），并将调度延迟到下一个requestAnimationFrame之前。 和之前相同的事件轴，可是这次事件被合并并延迟调度了 任何诸如keydown，keyup，mouseup，mousedown，touchstart和touchend等相对不怎么频繁发生的事件都会被立即派送给主线程。 使用getCoalesecedEvents来获取帧内（intra-frame）事件对于大多数web应用来说，合并事件应该已经足够用来提供很好的用户体验了，然而，如果你正在构建的是一个根据用户的touchmove坐标来进行绘图的应用的话，合并事件可能会使页面画的线不够顺畅和连续。在这种情况下，你可以使用鼠标事件的getCoalescedEvents来获取被合成的事件的详细信息。 左边是顺畅的触摸手势，右边是事件合成后不那么连续的手势 1window.addEventListener('pointermove', event =&gt; {2 const events = event.getCoalescedEvents();3 for (let event of events) {4 const x = event.pageX;5 const y = event.pageY;6 // draw a line using x and y coordinates.7 }8}); 下一步这本系列的文章中，我们以Chrome浏览器为例子探讨了浏览器的内部工作原理。如果你之前从来没有想过为什么DevTools推荐你在事件监听器中使用passive:true选项或者在script标签中写async属性的话，我希望这个系列的文章可以给你一些关于浏览器为什么需要这些信息来提供更快更流畅的用户体验的原因。 学习如何衡量性能不同网站的性能调整可能会有所不同，你要自己衡量自己网站的性能并确定最适合提升你的网站性能的方案。 你可以查看Chrome DevTools团队的一些教程来学习如何才能衡量自己网站的性能。 为你的站点添加Feature Policy如果你想更进一步，你可以了解一下Feature Policy这个新的Web平台功能，这个功能可以在你构建项目的时候提供一些保护让您的应用程序具有某些行为并防止你犯下错误。例如，如果你想确保你的应用代码不会阻塞页面的解析（parsing），你可以在同步脚本策略（synchronius scripts policy）中运行你的应用。具体做法是将sync-script设置为’none’，这样那些会阻塞页面解析的JavaScript代码会被禁止执行。这样做的好处是避免你的代码阻塞页面的解析，而且浏览器无须担心解析器（parser）暂停。 总结以上就是所有和浏览器架构和运行原理相关的内容了，我们以后在开发web应用的时候，不应该只考虑代码的优雅性，还要多多从浏览器是如何解析运行我们的代码的方面进行思考，从而为用户提供更好的用户体验。 个人技术动态欢迎关注公众号进击的大葱一起学习成长","link":"/2020/01/08/%E7%AA%A5%E6%8E%A2%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84-%E5%9B%9B/"},{"title":"进击的JAMStack","text":"最近在研究JAMStack的一些相关内容，发现这的确是个好东西，所以想写一篇文章把这个概念分享给还不了解JAMStack的同学。本篇文章主要包含以下的内容： 什么是JAMStack JAMStack有什么优势 JAMStack适合什么应用 我的个人思考 什么是JAMStack概念JAMStack中的JAM其实是三个词的缩写，它们分别是JavaScript, APIs以及Markdown。而Stack用中文的说法就是技术栈（Tech Stack），也就是我们在构建应用的时候具体使用到的技术的集合。举个例子，国外现在比较火的一个Stack叫做Mean Stack，它表示使用MongoDB + Express.js + AngularJS + Node.js这些技术来构建一个Web应用。因此用最通俗易懂的话来描述JAMStack就是：使用JavaScript，APIs和Markdown三种技术来构建Web应用。所以JAMStack是一种问题解决方案，而不是一个具体的实现。 接着我们再具体看一下JavaScript，APIs和Markdown这三种技术在JAMStack的世界中是起到什么作用的。 JavaScript在JAMStack的概念中，JavaScript指的是在客户端（client）实现动态网页效果的JavaScript，它既可以是React和Vue这种Web框架，也可以是原生的JavaScript。它主要负责网页动态的内容。 APIs这里的API和我们平时开发调用的API是一样的。JAMStack的Web应用会通过JavaScript给后端API发送AJAX请求或者GraphQL query，后端API会以某种格式（一般是JSON）返回数据给前端来实现一些用户交互。 MarkdownMardown是一种轻量级的标记语言。在JAMStack的世界中，Markdown类型的文件通常是用来作为生成静态HTML文件的数据源。有用过hexo写博客的同学对这个概念肯定不会陌生，因为hexo的原理就是将我们编写的Markdown文件根据我们指定的主题或者模板生成一些静态的HTML然后托管在github pages或者其它类似的静态网站服务器来供别人访问的。 除了Markdown文件之外，JAMStack的静态数据源还可以是其它的东西，例如我们后面说到的Gatsby（JAMStack的一种实现）就允许通过插件的方式使用SQL直接读取数据库的内容来生成静态页面。 了解了这三个概念的具体内容后，我们再通过一个Gatsby的小demo来体会一下JAMStack的应用是如何工作的。 Gatsby Demo由于文章篇幅的限制，我将不在这里为大家讲述Gatsby的具体用法，不过我后面会写一系列文章来教大家如何用Gatsby来免费构建一个比较大的内容网站（CMS），大家可以留意一下。 简单来说，Gatsby是一个可以让开发者使用React，GraphQL等现代技术快速开发网站的静态网站生成器（static-site generator）。它是存在于网站构建（build）阶段的一个工具。为了给大家一个直观点的认识，我使用Gatsby搭建了一个简单的个人博客网站，网站的源代码可以在我的github仓库找到。 博客网站包含以下的功能： 博客列表页面：展示我发表的所有博客。（静态内容） 博客详情页面：展示每一篇博客的具体内容。（静态内容） 博客评论列表：游客评论博客以及展示游客对这篇博客的评论列表。（动态内容） 细心的你一定注意到了我在上面每个功能点的右边标出了这个功能是静态的还是动态的。所谓静态的内容就是那些不会经常发生变化的内容，这些内容在一段时间内不同用户访问的时候都会得到同样的结果。而动态的内容就是那些频繁发生变化的内容，例如游客对我的博客的评论。那么我为什么要区分开这两种类型的内容呢？要回答这个问题我们可以先看看如果使用服务端渲染（SSR）的方案这个博客应用是如何运行的。首先游客会向SSR服务器发送一个查看某个博客的请求，SSR服务器收到请求后向后端服务请求这个博客的内容然后渲染出一个HTML页面然后返回给用户。这时候如果其他用户也向SSR服务器请求了同样的资源，SSR服务器还是会做同样的工作，请求资源 + 渲染页面。这个时候其实SSR服务器消耗了很多IO和CPU资源来做这些重复性的渲染，而且随着你的博客访问量的增大这些无用的资源消耗也会越来越多，在不升级服务端资源的前提下用户体验也会随之变差。到这里你可能会问，既然服务端渲染这么浪费资源，我们不进行SSR，直接将webpack打包生成的文件放在一个静态服务器然后页面都是在浏览器渲染不就行了吗？从实现博客功能的层面上来说这是没有问题的，可是这对搜索引擎优化（SEO）很不友好，百度收录不了你的博客，你的网站火不起来啊！ 为了避免重复性的无用渲染而且能对SEO友好，Gatsby采取了区分网站静态内容和动态内容的技术方案。对于那些不经常变动的而且希望被搜索引擎收录的静态内容，Gatsby会在Webpack打包阶段就生成，这样就不需要在用户访问该页面的时候才浪费资源来渲染页面了，而且这些静态文件还可以通过CDN来优化用户体验。而对于那些数据经常发生变化的且不需要被搜索引擎收录的内容，它们会等到浏览器实际渲染对应组件的时候才通过APIs动态获取数据渲染出来。 我们接着来看一下博客网站的代码目录结构： 上面代码中，server文件夹存放的是一个简单的管理用户评论的express应用，src文件夹才是Gatsby操作的前端资源，它包括以下内容： blogs：这个文件夹是用来存放博客内容的，每一个Markdown文件都会生成一个静态的HTML文件。 components: 存放React组件用的。 images：存放博客的一些图片资源。 pages: 网站的路由文件夹，这个文件夹下的每一个文件都会被生成一个对应的HTML静态文件，当请求该路由时会直接返回该静态文件。例如现在pages底下有两个路由，404的路由对应着的是没找到资源的页面，而index路由则是博客的主页面。 templates: 网站的模板文件夹，该文件夹底下只有一个叫做blog-post.js的模板文件，在Gatsby构建网站的时候blogs文件夹底下的每一个Markdown文件都会通过这个模板文件生成一个对应的HTML文件，这样当用户访问服务器的时候博客的HTML文件就会被直接返回而无需进行服务端渲染了。 接着我们可以看一下Gatsby打包会生成哪些文件： 由上图可以看出，Gatsby会为每一个pages文件夹底下的文件生成一个对应的html文件，以及为每一个blogs文件夹底下的博客生成一个静态的HTML文件，同时还有一些在客户端执行的JS文件。生成的文件可以直接使用静态网站服务器来为用户提供服务，同时你还可以把它们放在CDN中来让用户访问起来更快。 最后让我们来看一下这个博客网站的运行效果吧： 上图中我点击了“如何马上实现财富自由”这个博客，进入到博客详情页时浏览器没有重新向服务端请求博客详情的HTML文件，而是直接在浏览器完成渲染，用户体验非常之流畅。这其实是Gatsby应用的一个很大的亮点，那就是：Gatsby打包的应用在浏览器首次请求获得提前生成的静态HTML文件后，会演变成一个React SPA应用，接下来的用户交互就和一般的SPA应用没有任何差别了，换句话来说，Gatsby既保留了SSR方案SEO友好的优点又保留了SPA应用的流畅用户体验，可谓是各取所长，扬长补短了！ 其他例子其实JAMStack的应用现在已经有很多了，只不过我们平时没有留意到而已。举个例子，React开发者十分熟悉的React官网reactjs.org就是用Gatsby构建。那么除了这些比较简单的文档性和博客网站，JAMStack可以用来构建复杂的商业应用吗？答案是肯定的，除了一些简单的CMS平台，JAMStack还可以用来搭建诸如braun这类电商平台，你可能想不到的是著名的程序员学习网站freeCodeCamp也是使用JAMStack技术栈来搭建的，大家可以去网上（Google）查一下关于freeCodeCamp架构设计的视频或文章，看完之后我相信你会对JAMStack有更深入的理解的。 JAMStack的优势在上面的介绍中我已经大概说了一些JAMStack的优势了，其中包括SEO友好还有流畅的用户体验，那么除了这些，JAMStack还有没有其它吸引人的地方呢？ 高性能为什么JAMStack是高性能的呢？这是因为JAMStack的应用将网站的静态部分和动态部分区分开来了，那些不会频繁发生变化的内容会被提前生成，从而无需使用额外的计算资源来进行服务端渲染。这样用户首次访问某个页面的时候速度会变得很快，而且这些静态的资源还可以被放在CDN来进一步提升用户体验。将动态内容和静态内容区分开来还有另外一个好处，就是我们后端接口的职责更加明确了，API接口的数量会变得更少，性能也会变得更好。 高性价比以及高可扩展性由于我们前端的内容都是一些静态的文件没有服务端渲染的要求，而静态资源服务器对性能的要求并不高，所以我们在购买服务器方面不需要很大的成本，我们甚至还可以使用一些诸如netlify和Gatsby Cloud等免费资源来托管我们的文件。对于后端来说由于我们已经将前后端彻底分离了，所以后端可以使用一些廉价的Baas或者Serverless服务，例如可以使用Auth0作为我们的用户鉴权服务，使用Firebase作为我们的接口服务等等。使用这些Baas和Serverless服务有一个好处就是它们很便宜，而且它们是按照接口使用量来收费的，你的用户量决定了你的支出，如果你的用户很少，你甚至不需要花一分钱。 除了极高的性价比，JAMStack还有很好的扩展性。举个例子，假如你现在的博客网站因为某一篇博客突然火了，访问用户激增。如果你的前端静态文件使用的是CDN网络的话，你的网站很容易就可以扩展了，一切都是自动的，无需你做任何东西，而后端如果你使用了Serverless和Baas的解决方案的话，一切也是自动的，用户不会感觉到有使用体验的差别，而你只需要给使用到的服务平台多一点点费用而已。 更好的开发者体验拿我们前面提到的Gatsby来举例，它就允许我们使用一些现代的前端技术来进行开发，例如React，Styled-components和GraphQL等，这些都是我们前端开发者十分熟悉的技术了，没有很大的学习成本所以开发者体验会很好。除此之外，由于Gatsby使用了React，所以它间接上接入了React的生态系统，这样开发者在开发Gatsby应用时就可以使用React生态的各种最佳实践和库实现了，这无疑可以大大提高我们的开发效率。 更高的安全性由于JAMStack是一种前后端分离的技术，没有了后端渲染所以可以降低被攻击的风险。举个例子采用Gatsby生成的CMS平台就比传统的WordPress平台安全很多：）。 JAMStack适合什么应用既然JAMStack有那么多好处，我们是不是一把梭在所有的项目中都使用JAMStack呢？答案是否定的，由于JAMStack需要我们将网站的静态部分和动态部分区分开来，静态部分的内容会在构建的时候就生成而动态的内容会在浏览器进行渲染，这个特点就注定了它不适合于构建以下类型的应用： 掘金，知乎这种主要由第三方用户创建内容的应用。由于这些应用的内容都是由平台用户创建的，而且用户可以不断地修改和删除已经创建的内容，如果使用JAMStack的话网站的内容就需要被频繁构建，这显然是不合理的。 微博，推特这种社交应用。这类应用的内容除了频繁更新之外，还有就是动态内容多于静态内容，例如用户的主页只会展示他关注的人发表的动态，所以也不适合使用JAMStack。 一些不需要SEO的应用。JAMStack一个很大的优点就是对SEO友好，如果你的应用没有被搜索引擎收录的需求的话，就没必要使用JAMStack了。 内容很多的应用。由于JAMStack需要我们每次都构建出所有的静态资源，所以对于那些静态内容很多的应用（例如页面数超过50k）的话，每次构建应用都需要大量的时间，因此这种类型的网站也不适合用JAMStack。 相反JAMStack十分适合构建以下类型的应用： 项目文档之类的网站，例如React的官网等。 企业或者组织的官方网站。 个人管理的博客网站。 中小型规模的CMS平台。 中小型的电商平台。 既有需要被SEO的静态内容又有动态的不需要SEO的内容的混合应用。例如一些To B的平台，里面既有用户的工作台又有一些操作文档相关的静态内容。 当然了我在这里列出来的无论是适用还是不适用JAMStack的应用其实都是一些很笼统的分类，我们在实际开发时还得具体问题具体分析，根据实际情况来评估我们的应用是不是适合使用JAMStack来开发。 我的个人思考在最后我想说一下我自己对JAMStack的一些思考。 首先我个人十分看好这个技术栈，也会在日后的开发中使用这个技术栈。因为它帮我解决了网站SEO的问题。在不了解JAMStack之前，如果我想我的网站被搜索引擎收录要么就是刀耕火种地硬写HTML和原生JS，这种方案明显开发效率十分低下。还有一种方案就是我使用React等现代开发技术，这样我就得学习next.js等SSR技术来实现SEO，这个方案有一个问题就是学习next.js有一定的学习成本，而且在项目上线后我得维护一个后端服务来进行服务端渲染，所以会有一定的运维成本。可是使用了JAMStack或者说是Gatsby后这些问题就迎刃而解了，因为我可以继续使用我熟悉的React技术栈来快速开发Web应用，还无需考虑服务端渲染的问题就可以达到SEO的效果，这不是美滋滋？ 其次我觉得JAMStack这个技术栈十分有利于我们实践一些自己想到的不确定能不能成功的点子（创业想法）。上面在介绍JAMStack优势的时候，我提到了一点就是使用JAMStack其实你可以免费部署你的应用，因为你可以将前端的静态代码放在一些免费的静态资源托管服务器，然后后端使用一些免费的Baas API服务，当然了这只适合于我们平台用户量不大的情景，当用户量大的时候我们还是得付费的。可是我们网站刚起步的时候用户量不都是不大的吗？如果我们一大早就买好服务器资源和域名，后面却发现这个想法根本行不通的话，这些钱就算是赔进去了。相反，使用免费服务的话，即使我们做的东西黄了，我们也不会有什么损失。 总的来说我对JAMStack这个技术栈是很有信心的，特别是在CMS内容管理平台这方面我相信它一定会逐渐火起来，而且有可能可以取代WordPress的地位。 个人技术动态欢迎关注公众号进击的大葱一起学习成长","link":"/2020/04/22/%E8%BF%9B%E5%87%BB%E7%9A%84JAMStack/"},{"title":"CSS in JS的好与坏","text":"是什么CSS-in-JS是一种技术（technique），而不是一个具体的库实现（library）。简单来说CSS-in-JS就是将应用的CSS样式写在JavaScript文件里面，而不是独立为一些.css，.scss或者less之类的文件，这样你就可以在CSS中使用一些属于JS的诸如模块声明，变量定义，函数调用和条件判断等语言特性来提供灵活的可扩展的样式定义。值得一提的是，虽然CSS-in-JS不是一种很新的技术，可是它在国内普及度好像并不是很高，它当初的出现是因为一些component-based的Web框架（例如React，Vue和Angular）的逐渐流行，使得开发者也想将组件的CSS样式也一块封装到组件中去以解决原生CSS写法的一系列问题。还有就是CSS-in-JS在React社区的热度是最高的，这是因为React本身不会管用户怎么去为组件定义样式的问题，而Vue和Angular都有属于框架自己的一套定义样式的方案。 本文将通过分析CSS-in-JS这项技术带来的好处以及它存在的一些问题来帮助大家判断自己是不是要在项目中使用CSS-in-JS。 不同的实现实现了CSS-in-JS的库有很多，据统计现在已经超过了61种。虽然每个库解决的问题都差不多，可是它们的实现方法和语法却大相径庭。从实现方法上区分大体分为两种：唯一CSS选择器和内联样式（Unique Selector VS Inline Styles）。接下来我们会分别看一下对应于这两种实现方式的两个比较有代表性的实现：styled-components和radium。 Styled-componentsStyled-components 应该是CSS-in-JS最热门的一个库了，到目前为止github的star数已经超过了27k。通过styled-components，你可以使用ES6的标签模板字符串语法（Tagged Templates）为需要styled的Component定义一系列CSS属性，当该组件的JS代码被解析执行的时候，styled-components会动态生成一个CSS选择器，并把对应的CSS样式通过style标签的形式插入到head标签里面。动态生成的CSS选择器会有一小段哈希值来保证全局唯一性来避免样式发生冲突。 CSS-in-JS Playground是一个可以快速尝试不同CSS-in-JS实现的网站，上面有一个简单的用styled-components实现表单的例子： 从上面的例子可以看出，styled-components不需要你为需要设置样式的DOM节点设置一个样式名，使用完标签模板字符串定义后你会得到一个styled好的Component，直接在JSX中使用这个Component就可以了。接着让我们打开DevTools查看一下生成的CSS： 从上面DevTools可以看出styled的Component样式存在于style标签内，而且选择器名字是一串随机的哈希字符串，这样其实实现了局部CSS作用域的效果（scoping styles），各个组件的样式不会发生冲突。除了styled-components，采用唯一CSS选择器做法的实现还有：jss，emotion，glamorous等。 RadiumRadium是由FormidableLabs创建的在github上有超过7.2k star的CSS-in-JS库。Radium和styled-components的最大区别是它生成的是标签内联样式（inline styles）。由于标签内联样式在处理诸如media query以及:hover，:focus，:active等和浏览器状态相关的样式的时候非常不方便，所以radium为这些样式封装了一些标准的接口以及抽象。 再来看一下radium在CSS-in-JS Playground的例子： 从上面的例子可以看出radium定义样式的语法和styled-components有很大的区别，它要求你使用style属性为DOM添加相应的样式。打开DevTools查看一下radium生成的CSS： 从DevTools上面inspect的结果可以看出，radium会直接在标签内生成内联样式。内联样式相比于CSS选择器的方法有以下的优点： 自带局部样式作用域的效果，无需额外的操作 内联样式的权重（specificity）是最高的，可以避免权重冲突的烦恼 由于样式直接写在HTML中，十分方便开发者调试 其他区别不同的CSS-in-JS实现除了生成的CSS样式和编写语法有所区别外，它们实现的功能也不尽相同，除了一些最基本的诸如CSS局部作用域的功能，下面这些功能有的实现会包含而有的却不支持： 自动生成浏览器引擎前缀 - built-in vendor prefix 支持抽取独立的CSS样式表 - extract css file 自带支持动画 - built-in support for animations 伪类 - pseudo classes 媒体查询 - media query 其他 想了解更多关于不同CSS-in-JS的对比，可以看一下Michele Bertoli整理的不同实现的对比图。 好处看完了一些不同的实现，大家应该对CSS-in-JS一些基本的概念和用法有了大概的理解，接着我们可以来聊一下CSS-in-JS都有什么好处和坏处了。 局部样式 - Scoping StylesCSS有一个被大家诟病的问题就是没有本地作用域，所有声明的样式都是全局的（global styles）。换句话来说页面上任意元素只要匹配上某个选择器的规则，这个规则就会被应用上，而且规则和规则之间可以叠加作用（cascading）。SPA应用流行了之后这个问题变得更加突出了，因为对于SPA应用来说所有页面的样式代码都会加载到同一个环境中，样式冲突的概率会大大加大。由于这个问题的存在，我们在日常开发中会遇到以下这些问题： 很难为选择器起名字。为了避免和页面上其他元素的样式发生冲突，我们在起选择器名的时候一定要深思熟虑，起的名字一定不能太普通。举个例子，假如你为页面上某个作为标题的DOM节点定义一个叫做.title的样式名，这个类名很大概率已经或者将会和页面上的其他选择器发生冲突，所以你不得不手动为这个类名添加一些前缀，例如.home-page-title来避免这个问题。 团队多人合作困难。当多个人一起开发同一个项目的时候，特别是多个分支同时开发的时候，大家各自取的选择器名字可能有会冲突，可是在本地独立开发的时候这个问题几乎发现不了。当大家的代码合并到同一个分支的时候，一些样式的问题就会随之出现。 CSS-in-JS会提供自动局部CSS作用域的功能，你为组件定义的样式会被限制在这个组件，而不会对其他组件的样式产生影响。不同的CSS-in-JS库实现局部作用域的方法可能有所不一样，一般来说它们会通过为组件的样式生成唯一的选择器来限制CSS样式的作用域。以下是一个简化了的CSS-in-JS库生成唯一选择器的示例代码： 1const css = styleBlock =&gt; {2 const className = someHash(styleBlock);3 const styleEl = document.createElement('style');4 styleEl.textContent = `5 .${className} {6 ${styleBlock}7 }8 `;9 document.head.appendChild(styleEl);10 return className;11};12const className = css(`13 color: red;14 padding: 20px;15`); // 'c23j4' 从上面的代码可以看出，CSS-in-JS的实现会根据定义的样式字符串生成一个唯一的CSS选择器，然后把对应的样式插入到页面头部的style标签中，styled-components使用的就是类似的方法。 避免无用的CSS样式堆积 - Dead Code Elimination进行过大型Web项目开发的同学应该都有经历过这个情景：在开发新的功能或者进行代码重构的时候，由于HTML代码和CSS样式之间没有显式的一一对应关系，我们很难辨认出项目中哪些CSS样式代码是有用的哪些是无用的，这就导致了我们不敢轻易删除代码中可能是无用的样式。这样随着时间的推移，项目中的CSS样式只会增加而不会减少(append-only stylesheets）。无用的样式代码堆积会导致以下这些问题： 项目变得越来越重量级，加载到浏览器的CSS样式会越来越多，会造成一定的性能影响。 开发者发现他们很难理解项目中的样式代码，甚至可能被大量的样式代码吓到，这就导致了开发效率的降低以及一些奇奇怪怪的样式问题的出现。 CSS-in-JS的思路就可以很好地解决这个问题。我们先来看一段styled-components的作者Max Stoiber说过的话： “For three years, I have styled my web apps without any .css files. Instead, I have written all the CSS in JavaScript. … I can add, change and delete CSS without any unexpected consequences. My changes to the styling of a component will not affect anything else. If I delete a component, I delete its CSS too. No more append-only stylesheets!” – Max Stoiber Max Stoiber大体就是说由于CSS-in-JS会把样式和组件绑定在一起，当这个组件要被删除掉的时候，直接把这些代码删除掉就好了，不用担心删掉的样式代码会对项目的其他组件样式产生影响。而且由于CSS是写在JavaScript里面的，我们还可以利用JS显式的变量定义，模块引用等语言特性来追踪样式的使用情况，这大大方便了我们对样式代码的更改或者重构。 Critical CSS浏览器在将我们的页面呈现给用户之前一定要先完成页面引用到的CSS文件的下载和解析（download and parse），所以link标签链接的CSS资源是渲染阻塞的（render-blocking）。如果CSS文件非常大或者网络的状况很差，渲染阻塞的CSS会严重影响用户体验。针对这个问题，社区有一种优化方案就是将一些重要的CSS代码（Critical CSS）直接放在头部的style标签内，其余的CSS代码再进行异步加载，这样浏览器在解析完HTML后就可以直接渲染页面了。具体做法类似于以下代码： 1&lt;html&gt;2 &lt;head&gt;3 &lt;style&gt;4 /* critical CSS */5 &lt;/style&gt;6 &lt;script&gt;asyncLoadCSS(\"non-critical.css\")&lt;/script&gt;7 &lt;/head&gt;8 &lt;body&gt;9 ...body goes here10 &lt;/body&gt;11&lt;/html&gt; 那么如何定义Critical CSS呢？放在head标签内的CSS当然是越少越好，因为太多的内容会加大html的体积，所以我们一般把用户需要在首屏看到的（above the fold）页面要用到的最少CSS提取为Critical CSS。以下是示意图： 上图中above the fold的CSS就是Critical CSS，因为它们需要立即展示在用户面前。由于页面在不同的设备上展示的效果不同，对应着的Critical CSS内容也会有所差别，因此Critical CSS的提取是一个十分复杂的过程，虽然社区有很多对应的工具可是效果都差强人意。CSS-in-JS却可以很好地支持Critical CSS的生成。在CSS-in-JS中，由于CSS是和组件绑定在一起的，只有当组件挂载到页面上的时候，它们的CSS样式才会被插入到页面的style标签内，所以很容易就可以知道哪些CSS样式需要在首屏渲染的时候发送给客户端，再配合打包工具的Code Splitting功能，可以将加载到页面的代码最小化，从而达到Critical CSS的效果。换句话来说，CSS-in-JS通过增加一点加载的JS体积就可以避免另外发一次请求来获取其它的CSS文件。而且一些CSS-in-JS的实现（例如styled-components）对Critical CSS是自动支持的。 基于状态的样式定义 - State-based stylingCSS-in-JS最吸引我的地方就是它可以根据组件的状态动态地生成样式。对于SPA应用来说，特别是一些交互复杂的页面，页面的样式通常要根据组件的状态变化而发生变化。如果不使用CSS-in-JS，处理这些逻辑复杂的情况会比较麻烦。举个例子，假如你现在页面有一个圆点，它根据不同的状态展示不同的颜色，running的时候是绿色，stop的时候是红色，ready的时候是黄色。如果使用的是CSS modules方案你可能会写下面的代码： style.css文件 1.circle {2 ... circle base styles3}45.healthy {6 composes: circle;7 background-color: green;8}910.stop {11 composes: circle;12 background-color: red;13}1415.ready {16 composes: circle;17 background-color: 18} index.js文件 1import React from 'react'2import styles from './style.css'34const styleLookup = {5 healthy: styles.healthy,6 stop: styles.stop,7 ready: styles.ready8}910export default ({ status }) =&gt; (11 &lt;div12 className={styleLookup[status]}13 /&gt;14) 在style.css中我们使用了CSS modules的继承写法来在不同状态的CSS类中共用circle基类的样式，代码看起来十分冗余和繁琐。由于CSS-in-JS会直接将CSS样式写在JS文件里面，所以样式复用以及逻辑判断都十分方便，如果上面的例子用styled-components来写是这样的： 1import styled from 'styled-components'23const circleColorLookup = {4 healthy: 'green',5 stop: 'red',6 ready: 'yellow'7}89export default styled.div`10 ... circle base styles11 background-color: ${({ status }) =&gt; circleColorLookup[status]};12` 对比起来，styled-components的逻辑更加清晰和简洁，如果后面需要增加一个状态，只需要为circleColorLookup添加一个键值对就好，而CSS modules的写法需要同时改动style.css和index.js文件，代码不好维护和扩展。 封装得更好的组件库大家在日常开发的过程中可能会封装一些组件在不同的项目中使用，如果你的组件的样式使用的CSS预处理方案和另外一个项目的预处理方案不一样，例如组件使用的是less，项目使用的是css modules，组件复用会变得很麻烦。可是如果CSS是写在JS里面的，项目想要使用封装的组件库只需要进行简单的npm install就可以了，非常方便。 坏处任何事物都有好的地方和坏的地方，只有对好处和坏处都了解清楚我们才能更好地做出判断。接着我们就来说一下CSS-in-JS不好的地方吧。 陡峭的学习曲线 - Steep learning curve这其实可以从两方面来说明。首先CSS-in-JS是针对component-based的框架的，这就意味着要学习CSS-in-JS你必须得学习：component-based框架（例如React），JavaScript和CSS这三样技能。其次，即使你已经会用React，JavaScript和CSS来构建SPA应用，你还要学习某个CSS-in-JS实现（例如styled-components），以及学习一种全新的基于组件定义样式的思考问题方式。我们团队在刚开始使用styled-components的时候，适应了好一段时间才学会如何用好这个库。因为学习成本比较高，在项目中引入CSS-in-JS可能会降低你们的开发效率。 运行时消耗 - Runtime cost由于大多数的CSS-in-JS的库都是在动态生成CSS的。这会有两方面的影响。首先你发送到客户端的代码会包括使用到的CSS-in-JS运行时（runtime）代码，这些代码一般都不是很小，例如styled-components的runtime大小是12.42kB min + gzip，如果你希望你首屏加载的代码很小，你得考虑这个问题。其次大多数CSS-in-JS实现都是在客户端动态生成CSS的，这就意味着会有一定的性能代价。不同的CSS-in-JS实现由于具体的实现细节不一样，所以它们的性能也会有很大的区别，你可以通过这个工具来查看和衡量各个实现的性能差异。 代码可读性差 - Unreadable class names大多数CSS-in-JS实现会通过生成唯一的CSS选择器来达到CSS局部作用域的效果。这些自动生成的选择器会大大降低代码的可读性，给开发人员debug造成一定的影响。 没有统一的业界标准 - No interoperability由于CSS-in-JS只是一种技术思路而没有一个社区统一遵循的标准和规范，所以不同实现的语法和功能可能有很大的差异。这就意味着你不能从一个实现快速地切换到另外一个实现。举个例子，假如你先在项目使用radium，可是随着项目规模的变大，你发现radium可能不适合你现在的业务，更好的解决方案应该是styled-components。可是由于写法差异巨大，这时候你要对代码进行脱胎换骨的改动才能将代码迁移到styled-components。不过令人欣慰的是，现在已经有人在制定相关的标准了，有兴趣的同学可以看一下Interoperable Style Transfer Format。 个人思考与总结CSS-in-JS有好处也有坏处，我们一定要根据自己的实际情况进行衡量和取舍来确定是不是要在自己的项目中使用它。永远不要为了使用一个技术而用一个技术。例如在下面几种情况下你就不需要它: 你是前端开发的初学者： 由于CSS-in-JS的学习坡度很陡，刚开始学习Web开发的同学没必要学习，可能会有挫败感。 你只想制作一些功能简单的静态页面：逻辑交互不复杂的网站没有必要使用CSS-in-JS。 你很注重样式名的可读性以及调试体验： CSS-in-JS动态生成的选择器很影响代码的可读性，可能会降低你的调试效率。 相反如果你的应用交互逻辑复杂的话，CSS-in-JS可能会给你带来很大的开发便利，没有使用过的人十分值得一试。 参考文献 An Introduction to CSS-in-JS: Examples, Pros, and Cons Why I Write CSS in JavaScript Oh No! Our Stylesheet Only Grows and Grows and Grows! What actually is CSS-in-JS The tradeoffs of CSS-in-JS 9 CSS in JS Libraries you should Know in 2019 Extract Critical CSS 个人技术动态欢迎关注公众号进击的大葱一起学习成长","link":"/2020/01/19/CSS-in-JS%E7%9A%84%E5%A5%BD%E4%B8%8E%E5%9D%8F/"},{"title":"Yarn v2介绍","text":"Yarn作为JavaScript生态的一个强大的依赖管理工具在今年1月24日的时候正式发布了v2版本。在本篇文章中，我将会为大家介绍以下内容： 为什么要开发v2版本 v2都有什么新的特性 Yarn的未来计划 备注：如果你想知道如何直接使用v2版本可以查看Getting Started，如果你想从v1版本迁移到v2版本可以查看Migrations。 为什么要开发v2版本原有代码架构满足不了新的需求Yarn创建于2016年初，它在刚开始的时候借鉴了很多npm的东西，其中的架构设计本身就不是很符合Yarn开发者的愿景。在那之后，由于不断有新的需求产生，Yarn在接下来的几年中还添加了很多新的功能，其中包括Workspaces(2017), Plug’n’Play(2018)和Zip loading(2019)。这些新的概念在Yarn刚刚被创建的时候压根就不存在，所以Yarn的架构设计也就没有考虑到日后这些新功能的添加，因此随着时间的推移，Yarn的代码变得越来越难维护和扩展。由于这个技术原因，Yarn需要一个更加现代化的代码架构来满足新需求的开发。 鼓励开发者贡献代码Yarn作为一个社区项目，秉承的一个理念就是: we don't want to work for you, we want to work with you。由此可以看出Yarn的开发者其实是希望更加多的开发者参与到这个项目的开发，而不是只有他们来维护。为了降低开发者为Yarn项目贡献代码的门槛，Yarn v2版本做了以下的一些改变： 从Flow迁移到了现在更加流行的TypeScript作为开发语言，让开发者可以用更加熟悉的技术栈来贡献代码。 采用基于插件（Plugin）的模块化（Modular）代码架构，让开发者不用搞懂Yarn的核心代码就可以通过实现插件的方式来为Yarn添加新的功能。而且Yarn的核心功能也是由不同的内置插件实现的，这点和Webpack的设计思想如出一辙，因此开发者可以很容易就搞懂每个功能是如何实现的。 v2都有什么新的特性说完了为什么要开发v2版本之后，我们再来看一下它都有什么新的特性。 可读性更高的输出日志虽然相对于其他替代方案（例如npm）Yarn的输出日志的可读性算是比较高的了，可是它还是存在各种各样的问题，例如当输出信息特别多的时候，开发者很难在一大堆输出中找到有用的内容，而且输出日志的颜色并没有起到帮助用户快速识别出重要信息的作用，甚至还会对日志的阅读造成一定的干扰。基于这些原因，v2版本对输出日志进行了一些改进，我们先来看一下它大概变成了什么样子了：由上面的输出内容我们可以看到现在每一行日志的开头添加了一个错误号码（error code），不同的错误号码代表的意思可以在这个文档中找到。这些错误号码可以让开发者快速定位错误并且可以更加方便地搜索到修复错误的办法。除了新增错误号码，输出日志在颜色上也有很大的改进，例如上面输出中会用鲜艳的颜色来突出依赖的名称以及它的版本号，这样可以更加方便开发者获取有用的信息。 Yarn dlxyarn dlx的功能和npx类似。dlx是download and execute的简称，这个命令会在本地创建一个临时的环境来下载指定的依赖，依赖下载完成后，它会在当前的工作目录（cwd）中执行这个依赖包含的可执行二进制文件，这个临时的空间会在命令完成后被删除，所以这些操作都是一次性的。 yarn dlx这个命令不会改变当前项目的package.json的内容，而且它只可以执行远端的脚本而不能执行本地的脚本（本地脚本可以用yarn run来执行），所以它相对于npx有更高的安全性。 由于v2版本默认开启了Plug’n’Play的功能，当你使用了一次yarn dlx命令执行某个远端脚本后，这个脚本的依赖会被缓存到本地环境中，这样当它被再次执行的时候它就不需要下载依赖了，所以它的速度会变得很快。 更好的workspaces支持v2版本一个最大的改变就是将workspaces变成了一等公民（first-class citizen），这样就可以更好地支持monorepo的开发了。v2版本对workspaces的支持体现在以下这些方面： yarn add 添加交互模式（interactive mode）假如你要在项目的某个workspace中引入某个依赖，你可能要考虑其他workspaces是否也用到了这个依赖，而且要避免引入不兼容的版本。v2版本中，你可以使用-i参数来让yarn add命令进入到交互模式，这样yarn就会帮你检查这个依赖有没有在其他workspaces中被使用，并且会让你选择是要复用其他workspaces中的依赖版本还是使用另外的版本。 一次更新所有workspaces某个依赖的版本v2版本新加了一个yarn up命令。这个命令和yarn upgrade命令类似，都是用来更新某个依赖的版本的。和yarn upgrade不同的是它可以同时更新所有workspaces的该依赖的版本，而不用切换到各个workspace中运行更新命令。这个命令同样具有交互模式-i来让你确认在不同workspace进行的具体操作。 自动发布关联的workspaces有参与过monorepo开发的同学们一定会遇到过这样的问题：当某个包（workspace）发布了新的版本之后，发布其它相关联的包十分麻烦。如果你在项目中使用的是Lerna，当你发布一个包的新版本的时候，你要么所有的包都要发布新的版本，要么你得自己手动来管理其他包的版本发布。虽然自己来管理其它包的发布也是可以的，可是人为的东西肯定会存在疏忽，而且多人协作的项目会让人很头疼。为了解决这个问题，Yarn v2版本采取了和Lerna以及其他类似工具完全不同的解决方案，它把这部分逻辑放在了一个单独的叫做version的插件中。version插件允许你将一部分包版本管理工作分发给你的代码贡献者，而且它还提供了一个友好的交互界面来让你十分容易地管理关联包的发布： 在多个workspaces中运行相同的命令在同一个项目的不同workspaces中运行同一个命令是很常见的情形，Yarn v2版本提供了一个新的yarn workspaces foreach命令来让你在多个workspaces中运行同一个命令，这个命令是由它内置的workspace-tools插件支持的，例如以下命令会在所有的workspaces中运行build命令： 1yarn workspaces foreach run build 给所有workspaces添加约束（contraints）有时候你希望同一个项目的所有workspaces都要遵循某些规则，例如所有的workspaces都不能使用underscore作为依赖又或者所有workspaces依赖的某个包版本要互相兼容等。v2版本有一个新的概念叫做约束（Constraints），这里的约束是对项目内各个workspaces的package.json进行的约束，就像ESLint对JS文件进行约束一样，它会在workspaces的package.json破坏了某些规则之后给你错误提示并且可以帮你修复其中一部分错误。 Yarn的约束规则是用Prolog语法来编写的。想要为你的workspaces添加约束，你首先得引入constraints插件： 1yarn plugin import constraints 然后在项目的根目录定义一个存放约束规则的constraints.pro文件，最后在这个文件中定义你想要的约束条件，例如以下的约束条件会禁止所有的workspaces将underscore作为依赖： 1gen_enforced_dependency(WorkspaceCwd, 'underscore', null, DependencyType) :-2 workspace_has_dependency(WorkspaceCwd, 'underscore', _, DependencyType). 约束规则定义完后可以使用yarn constraints check命令来校验项目的workspaces是否满足定义的约束规则，当有错误发生时，可以使用yarn constraints fix命令自动修复那些可以被自动修复的错误。 像搜索数据库一样查询workspaces的依赖信息yarn constraints query命令可以查询项目中的workspaces用到的依赖信息，例如以下命令会输出各个workspace使用到的lodash版本信息： 1$my-project: yarn constraints query \"workspace_has_dependency(Cwd, 'lodash', Range, _).\"2➤ YN0000: ┌ Cwd = 'packages/backend'3➤ YN0000: └ Range = '4.17.0'4➤ YN0000: ┌ Cwd = 'packages/frontend'5➤ YN0000: └ Range = '4.17.0'6➤ YN0000: Done with warnings in 0.03s 个人感觉上面的依赖查询很像在MySQL数据库里面用SELECT语法查询数据库，是一个十分强大而且有用的功能。 依赖零安装 （Zero-Installs）依赖零安装更像是一个理念而不是一个功能，它的思路是希望我们每次在使用git更新完代码后，不需要再次使用yarn install命令来更新本地仓库的依赖来提高开发效率和避免一些问题的发生。它的具体做法是让开发者将本地的依赖包也提交到远端的git仓库中，看到这里你可能会想：“不就是将node_modules也提交吗？这个做法很蠢吧！”。确实如果直接将node_modules提交到远端仓库的话，每次提交都是一个噩梦，因为node_modules的文件很多（几万个文件很常见），首先你上传和下载代码的速度会变得很慢，其次很影响别人对你的代码进行review。为了解决这个问题，v2版本默认开启了Plug’n’Play + zip loading的功能，这个功能开启后你的项目将不再存在node_modules文件夹，所有的依赖都会被压缩成一个文件放在特定的地方，由于压缩后的包体积很小，而且包的数量不会很多，所以就不会存在以上说到的node_modules存在的问题。 可是为什么要做到依赖零安装呢？这是因为它有以下的好处： 更好的开发体验 你每次使用git pull, git checkout, git rebase这些命令更新完你的代码后无需使用yarn install进行依赖的安装，这样可以避免一些问题的出现，例如别人更新了某个依赖的版本后，如果你没有进行对应的更新的话，你的代码会挂。 代码review的时候可以更清楚哪些依赖发生了改变。 更快，更简单，更稳定的CI部署 由于每次部署代码的时候，yarn install占用的时间都是一个大头，去掉这个步骤后部署速度将会大大提升。 不会存在本地运行没问题，发布线上环境的时候挂掉了的问题。 不用你在CI文件里面进行一些安装依赖的配置。 想要看一下pnp + zip loading实际效果的同学可以看一下yarn v2版本的代码 ，你可以看到它就是在自己仓库的.yarn/cache目录下存放了它所有的依赖： 添加新的协议Yarn v2版本添加了两个新的协议：patch和portal协议。不知道什么是协议的同学可以看一下官网介绍，它大概是用来告诉yarn，定义在package.json文件里面的依赖是如何解析的。 Patch协议我们日常开发中有时候会需要更改某个依赖的原代码来做一些试验性的东西，这个时候就可以使用这个patch协议了。我们先来看一下怎么使用： 1{2 \"dependencies\": {3 \"left-pad\": \"patch:left-pad@1.3.0#./my-patch.patch\"4 }5} 上面的package.json中定义了left-pad这个依赖是如何解析的，我们可以看到left-pad的解析其实就用到了patch协议，它表示项目中用到的left-pad代码是1.3.0这个版本的代码叠加上./my-patch.patch这个补丁，所谓的补丁就是我们自己对left-pad这个库的代码的更改，和git的diff文件类似。 Portal协议Portal协议和原有的link协议类似。它的作用是告诉yarn项目中的某个依赖指向本地文件系统的某个软链接（symlink），其实和yarn link的作用是差不多的。和link协议不同的是，portal指向的是一些包（package），也就是有package.json文件的那种文件夹，而且yarn会去解析这个包中的transitive dependencies。关于portal协议和link协议的更具体的区别可以看官方文档。 范式化shell脚本（Normalized shell）v2版本对Windows开发环境有了更好的兼容。你之前可能会遇到这样一个问题：你在package.json定义的script命令在OSX系统中可以运行，可是在windows电脑上却会报错。出现这个问题的原因是你在package.json中定义的script最终是通过Yarn创建一个子进程来执行的，而子进程的shell环境在Windows和OSX环境是不一样的（例如文件路径的写法就不一样）。为了解决这个问题，Yarn v2自带一个简单shell解析器（interpreter），这个解析器是用来兼容Windows和OSX shell环境的区别的，它覆盖了90%常用的shell脚本写法，所以正常来说你定义的shell脚本在Windows环境和OSX环境在这个解析器的兼容下都可以正常运行： 1{2 \"scripts\": {3 \"redirect\": \"node ./something.js &gt; hello.md\",4 \"no-cross-env\": \"NODE_ENV=prod webpack\"5 }6} 模块化代码架构在前面已经提到Yarn v2版本已经转变为一个模块化的架构，并且它支持用户自定义Plugin去增强它的功能。用户自定义的插件可以获取到Yarn解析出的dependency tree信息以及一些其他的上下文信息，因此很容易就可以实现一些诸如Lerna，Femoto和Patch-Package的库。 想要感受下Yarn的插件是怎么实现的同学可以看一下官方实现的typescript插件。这个typescript插件对于用Typescript开发的同学来说十分有用，它可以在你使用yarn add命令添加依赖的时候同时也添加这个依赖对应的@types/包，这样你就可以避免很多手动的工作了。更多和插件的相关的内容可以查看这个教程。 其他更新除了上面的提到的新的属性外，v2版本还有以下这些更新： Peer dependencies也可以在yarn link里面使用了 Lockfile的格式变为了标准的YAML格式 包只能依赖那些在package.json声明的依赖，不允许require那些没有声明的依赖 范式化了配置文件 … 想要查看v2版本所有更新内容的朋友可以看Maël Nison的文章 - Introducing Yarn 2或者直接查看它的change log。 Yarn的未来计划 v1最后一个版本v1.22已经发布，作者从此不会再在v1的代码上添加任何新的功能了。Yarn所有的新功能都只会在v2版本的代码库上开发。 v1的代码仓库将会被从yarnpkg/yarn迁移到yarnpkg/legacy，这个仓库会继续开放一定的时间用来修复一些bug，然后会在一两年后achieve掉。v2版本的代码由于历史遗留问题不会迁移到yarnpkg/yarn，而且会在未来很长的一段时间保留在yarnpkg/berry。 v1的官方网站会被搬到legacy.yarnpkg.com，yarnpkg.com官网的内容已经是v2版本next.yarnpkg.com的内容了。 npm仓库中，legacy标签指向的是最新的v1版本代码，latest标签会继续指向v1的最新版本的代码几周，然后指向v2的代码。berry标签将会一直指向v2版本的最新版本。 大概在今年4月的时候，Node 14版本的Docker镜像可能会默认自带v2版本，这样你就可以直接在容器里使用v2的功能了。 参考文献 Yarn berry官方文档 Yarn 2 - Reinventing package management - Maël Nison aka @arcanis at @ReactEurope 2019 Introducing Yarn 2! 个人技术动态欢迎关注公众号进击的大葱一起学习成长","link":"/2020/02/17/yarnv2/"},{"title":"窥探现代浏览器架构-三","text":"前言本文是笔者对Mario Kosaka写的inside look at modern web browser系列文章的翻译。这里的翻译不是指直译，而是结合个人的理解将作者想表达的意思表达出来，而且会尽量补充一些相关的内容来帮助大家更好地理解。 渲染进程里面发生的事这篇文章是探究Chrome内部工作原理的四集系列文章中的第三篇。之前我们分别探讨了Chrome的多进程架构以及导航的过程都发生了什么。在本篇文章中，我们将要窥探一下渲染进程在渲染页面的时候具体都发生了什么事情。 渲染进程会影响到Web性能的很多方面。页面渲染的时候发生的东西实在太多了，本篇文章只能作一个大体的介绍。如果你想要了解更多相关的内容，Web Fundamentals的Performance栏目有很多资源可以查看。 渲染进程处理页面内容渲染进程负责标签（tab）内发生的所有事情。在渲染进程里面，主线程（main thread）处理了绝大多数你发送给用户的代码。如果你使用了web worker或者service worker，相关的代码将会由工作线程（worker thread）处理。合成（compositor）以及光栅（raster）线程运行在渲染进程里面用来高效流畅地渲染出页面内容。 渲染进程的主要任务是将HTML，CSS，以及JavaScript转变为我们可以进程交互的网页内容。 渲染进程里面有：一个主线程（main thread），几个工作线程（worker threads），一个合成线程（compositor thread）以及一个光栅线程（raster thread） 解析构建DOM前面文章提到，渲染进程在导航结束的时候会收到来自浏览器进程提交导航（commit navigation）的消息，在这之后渲染进程就会开始接收HTML数据，同时主线程也会开始解析接收到的文本数据（text string）并把它转化为一个DOM（Document Object Model）对象 DOM对象既是浏览器对当前页面的内部表示，也是Web开发人员通过JavaScript与网页进行交互的数据结构以及API。 如何将HTML文档解析为DOM对象是在HTML标准中定义的。不过在你的web开发生涯中，你可能从来没有遇到过浏览器在解析HTML的时候发生错误的情景。这是因为浏览器对HTML的错误容忍度很大。举些例子：如果一个段落缺失了闭合p标签（&lt;/p&gt;），这个页面还是会被当做为有效的HTML来处理；Hi! &lt;b&gt;I’m &lt;i&gt;Chrome&lt;/b&gt;!&lt;/i&gt; (闭合b标签写在了闭合i标签的前面) ，虽然有语法错误，不过浏览器会把它处理为Hi! &lt;b&gt;I’m &lt;i&gt;Chrome&lt;/i&gt;&lt;/b&gt;&lt;i&gt;!&lt;/i&gt;。如果你想知道浏览器是如何对这些错误进行容错处理的，可以参考HTML规范里面的An introduction to error handling and strange cases in the parser内容。 子资源加载除了HTML文件，网站通常还会使用到一些诸如图片，CSS样式以及JavaScript脚本等子资源。这些文件会从缓存或者网络上获取。主线程会按照在构建DOM树时遇到各个资源的循序一个接着一个地发起网络请求，可是为了提升效率，浏览器会同时运行“预加载扫描”（preload scanner）程序。如果在HTML文档里面存在诸如&lt;img&gt;或者&lt;link&gt;这样的标签，预加载扫描程序会在HTML解析器生成的token里面找到对应要获取的资源，并把这些要获取的资源告诉浏览器进程里面的网络线程。 主线程会解析HTML内容并且构建出DOM树 JavaScript会阻塞HTML的解析过程当HTML解析器碰到script标签的时候，它会停止HTML文档的解析从而转向JavaScript代码的加载，解析以及执行。为什么要这样做呢？因为script标签中的JavaScript可能会使用诸如document.write()这样的代码改变文档流（document）的形状，从而使整个DOM树的结构发生根本性的改变（HTML规范里面的overview of the parsing model部分有很好的示意图）。因为这个原因，HTML解析器不得不等JavaScript执行完成之后才能继续对HTML文档流的解析工作。如果你想知道JavaScipt的执行过程都发生了什么，V8团队有很多关于这个话题的讨论以及博客。 给浏览器一点如何加载资源的提示Web开发者可以通过很多方式告诉浏览器如何才能更加优雅地加载网页需要用到的资源。如果你的JavaScript不会使用到诸如document.write()的方式去改变文档流的内容的话，你可以为script标签添加一个async或者defer属性来使JavaScript脚本进行异步加载。当然如果能满足到你的需求，你也可以使用JavaScript Module。同时&lt;link rel=&quot;preload&quot;&gt;资源预加载可以用来告诉浏览器这个资源在当前的导航肯定会被用到，你想要尽快加载这个资源。更多相关的内容，你可阅读Resource Prioritization - Getting the Browser to Help You这篇文章。 样式计算 - Style calculation拥有了DOM树我们还不足以知道页面的外貌，因为我们通常会为页面的元素设置一些样式。主线程会解析页面的CSS从而确定每个DOM节点的计算样式（computed style）。计算样式是主线程根据CSS样式选择器（CSS selectors）计算出的每个DOM元素应该具备的具体样式，你可以打开devtools来查看每个DOM节点对应的计算样式。 主线程解析CSS来确定每个元素的计算样式 即使你的页面没有设置任何自定义的样式，每个DOM节点还是会有一个计算样式属性，这是因为每个浏览器都有自己的默认样式表。因为这个样式表的存在，页面上的h1标签一定会比h2标签大，而且不同的标签会有不同的magin和padding。如果你想知道Chrome的默认样式是长什么样的，你可以直接查看代码。 布局 - Layout前面这些步骤完成之后，渲染进程就已经知道页面的具体文档结构以及每个节点拥有的样式信息了，可是这些信息还是不能最终确定页面的样子。举个例子，假如你现在想通过电话告诉你的朋友你身边的一幅画的内容：“画布上有一个红色的大圆圈和一个蓝色的正方形”，单凭这些信息你的朋友是很难知道这幅画具体是什么样子的，因为他不知道大圆圈和正方形具体在页面的什么位置，是正方形在圆圈前面呢还是圆圈在正方形的前面。 你站在一幅画面前通过电话告诉你朋友画上的内容 渲染网页也是同样的道理，只知道网站的文档流以及每个节点的样式是远远不足以渲染出页面内容的，还需要通过布局（layout）来计算出每个节点的几何信息（geometry）。布局的具体过程是：主线程会遍历刚刚构建的DOM树，根据DOM节点的计算样式计算出一个布局树（layout tree）。布局树上每个节点会有它在页面上的x，y坐标以及盒子大小（bounding box sizes）的具体信息。布局树长得和先前构建的DOM树差不多，不同的是这颗树只有那些可见的（visible）节点信息。举个例子，如果一个节点被设置为了display:none，这个节点就是不可见的就不会出现在布局树上面（visibility:hidden的节点会出现在布局树上面，你可以思考一下这是为什么）。同样的，如果一个伪元素（pseudo class）节点有诸如p::before{content:&quot;Hi!&quot;}这样的内容，它会出现在布局上，而不存在于DOM树上。 主线程会遍历每个DOM tree节点的计算样式信息来生成一棵布局树 即使页面的布局十分简单，布局这个过程都是非常复杂的。例如页面就是简单地从上而下展示一个又一个段落，这个过程就很复杂，因为你需要考虑段落中的字体大小以及段落在哪里需要进行换行之类的东西，它们都会影响到段落的大小以及形状，继而影响到接下来段落的布局。 浏览器得考虑段落是不是要换行 如果考虑到CSS的话将会更加复杂，因为CSS是一个很强大的东西，它可以让元素悬浮（float）到页面的某一边，还可以遮挡住页面溢出的（overflow）元素，还可以改变内容的书写方向，所以单是想一下你就知道布局这个过程是一个十分艰巨和复杂的任务。对于Chrome浏览器，我们有一整个负责布局过程的工程师团队。如果你想知道他们工作的具体内容，他们在BlinkOn Conference上面的相关讨论被录制了下来，有时间的话你可以去看一下。 绘画 - Paint知道了DOM节点以及它的样式和布局其实还是不足以渲染出页面来的。为什么呢？举个例子，假如你现在想对着一幅画画一幅一样的画，你已经知道了画布上每个元素的大小，形状以及位置，你还是得思考一下每个元素的绘画顺序，因为画布上的元素是会互相遮挡的（z-index）。 一个人拿着画笔站在画布前面，在思考着是先画一个圆还是先画一个正方形 举个例子，如果页面上的某些元素设置了z-index属性，绘制元素的顺序就会影响到页面的正确性。 单纯按照HTML布局的顺序绘制页面的元素是错误的，因为元素的z-index元素没有被考虑到 在绘画这个步骤中，主线程会遍历之前得到的布局树（layout tree）来生成一系列的绘画记录（paint records）。绘画记录是对绘画过程的注释，例如“首先画背景，然后是文本，最后画矩形”。如果你曾经在canvas画布上有使用过JavaScript绘制元素，你可能会觉着这个过程不是很陌生。 主线程遍历布局树来生成绘画记录 高成本的渲染流水线（rendering pipeline）更新关于渲染流水线有一个十分重要的点就是流水线的每一步都要使用到前一步的结果来生成新的数据，这就意味着如果某一步的内容发生了改变的话，这一步后面所有的步骤都要被重新执行以生成新的记录。举个例子，如果布局树有些东西被改变了，文档上那些被影响到的部分的绘画顺序是要重新生成的。 DOM+Style，布局以及绘画树 如果你的页面元素有动画效果（animating），浏览器就不得不在每个渲染帧的间隔中通过渲染流水线来更新页面的元素。我们大多数显示器的刷新频率是一秒钟60次（60fps），如果你在每个渲染帧的间隔都能通过流水线移动元素，人眼就会看到流畅的动画效果。可是如果流水线更新时间比较久，动画存在丢帧的状况的话，页面看起来就会很“卡顿”。 流水线更新没有赶上屏幕刷新，动画就有点卡 即使你的渲染流水线更新是和屏幕的刷新频率保持一致的，这些更新是运行在主线程上面的，这就意味着它可能被同样运行在主线程上面的JavaScript代码阻塞。 某些动画帧被JavaScript阻塞了 对于这种情况，你可以将要被执行的JavaScript操作拆分为更小的块然后通过requestAnimationFrame这个API把他们放在每个动画帧中执行。想知道更多关于这方面的信息的话，可以参考Optimize JavaScript Execution。当然你还可以将JavaScript代码放在WebWorkers中执行来避免它们阻塞主线程。 在动画帧上运行一小段JavaScript代码 合成如何绘制一个页面？到目前为止，浏览器已经知道了关于页面以下的信息：文档结构，元素的样式，元素的几何信息以及它们的绘画顺序。那么浏览器是如何利用这些信息来绘制出页面来的呢？将以上这些信息转化为显示器的像素的过程叫做光栅化（rasterizing）。 可能一个最简单的做法就是只光栅化视口内（viewport）的网页内容。如果用户进行了页面滚动，就移动光栅帧（rastered frame）并且光栅化更多的内容以补上页面缺失的部分。Chrome的第一个版本其实就是这样做的。然而，对于现代的浏览器来说，它们往往采取一种更加复杂的叫做合成（compositing）的做法。 最简单的光栅化过程 什么是合成合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程（compositor thread）里面合并成一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。页面的动画效果实现也是类似，将页面上的层进行移动并构建出一个新的帧即可。 你可以通过Layers panel在DevTools查看你的网站是如何被浏览器分成不同的层的。 页面合成过程 页面分层为了确定哪些元素需要放置在哪一层，主线程需要遍历渲染树来创建一棵层次树（Layer Tree）（在DevTools中这一部分工作叫做“Update Layer Tree”）。如果页面的某些部分应该被放置在一个单独的层上面（滑动菜单）可是却没有的话，你可以通过使用will-change CSS属性来告诉浏览器对其分层。 主线程遍历布局树来生成层次树 你可能会想要给页面上所有的元素一个单独的层，然而当页面的层超过一定的数量后，层的合成操作要比在每个帧中光栅化页面的一小部分还要慢，因此衡量你应用的渲染性能是十分重要的一件事情。想要获取关于这方面的更多信息，可以参考文章Stick to Compositor-Only Properties and Manage Layer Count。 在主线程之外光栅化和合成页面一旦页面的层次树创建出来并且页面元素的绘制顺序确定后，主线程就会向合成线程（compositor thread）提交这些信息。然后合成线程就会光栅化页面的每一层。因为页面的一层可能有整个网页那么大，所以合成线程需要将它们切分为一块又一块的小图块（tiles）然后将图块发送给一系列光栅线程（raster threads）。光栅线程会栅格化每个图块并且把它们存储在GPU的内存中。 光栅线程创建图块的位图并发送给GPU 合成线程可以给不同的光栅线程赋予不同的优先级（prioritize），进而使那些在视口中的或者视口附近的页面可以先被光栅化。为了响应用户对页面的放大和缩小操作，页面的图层（layer）会为不同的清晰度配备不同的图块。 当图层上面的图块都被栅格化后，合成线程会收集图块上面叫做绘画四边形（draw quads）的信息来构建一个合成帧（compositor frame）。 绘画四边形：包含图块在内存的位置以及图层合成后图块在页面的位置之类的信息。 合成帧：代表页面一个帧的内容的绘制四边形集合。 上面的步骤完成之后，合成线程就会通过IPC向浏览器进程（browser process）提交（commit）一个渲染帧。这个时候可能有另外一个合成帧被浏览器进程的UI线程（UI thread）提交以改变浏览器的UI。这些合成帧都会被发送给GPU从而展示在屏幕上。如果合成线程收到页面滚动的事件，合成线程会构建另外一个合成帧发送给GPU来更新页面。 合成线程构建出合成帧，合成帧会被发送给浏览器进程然后再发送给GPU 合成的好处在于这个过程没有涉及到主线程，所以合成线程不需要等待样式的计算以及JavaScript完成执行。这也就是为什么说只通过合成来构建页面动画是构建流畅用户体验的最佳实践的原因了。如果页面需要被重新布局或者绘制的话，主线程一定会参与进来的。 总结在这篇文章中，我们探讨了从解析HTML文件到合成页面整个的渲染流水线。希望你读完后，可以自己去看一些关于页面性能优化的文章了。 在接下来也是最后一篇本系列的文章中，我们将要查看合成线程更多的细节，来了解一下当用户在页面移动鼠标（mouse move）以及进行点击（click）的时候浏览器会做些什么事情。 个人技术动态欢迎关注公众号进击的大葱一起学习成长","link":"/2020/01/08/%E7%AA%A5%E6%8E%A2%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84-%E4%B8%89/"},{"title":"React Hook测试指南","text":"在React为什么需要Hook中我们探讨了React为什么需要引入Hook这个属性，在React Hook实战指南中我们深入了解了各种Hook的详细用法以及会遇到的问题，在本篇文章中我将带大家了解一下如何通过为自定义hook编写单元测试来提高我们的代码质量，它会包含下面的内容： 什么是单元测试 单元测试的定义 为什么需要编写单元测试 单元测试需要注意什么 如何对自定义Hook进行单元测试 Jest React-hooks-testing-library 例子 什么是单元测试单元测试的定义要理解单元测试，我们先来给测试下个定义。用最简单的话来说测试就是：我们给被测试对象一些输入（input），然后看看这个对象的输出结果（output）是不是符合我们的预期（match with expected result）。而在软件工程里面有很多不同类型的测试，例如单元测试（unit test），功能测试（functional test），性能测试（performance test）和集成测试（integration test）等。不同种类的测试的主要区别是被测试的对象和评判指标不一样。对于单元测试，被测试的对象是我们源代码的独立单元（individual unit），在面向过程编程语言（procedural programming）里面，单元就是我们封装的方法（function），在面向对象的编程语言（object-oriented programming）里面单元是类（class）的方法（method），我们一般不推荐将某个类或者某个模块直接作为单元测试的单元，因为这会使被测试的逻辑过于庞大，而且问题出现时不容易进行定位。 为什么需要编写单元测试了解了单元测试的定义后，我们再来探讨一下为什么我们要在代码里面进行单元测试。 我们之所以要在项目中编写单元测试，主要是因为对代码进行单元测试有下面这些好处： 提高代码质量单元测试可以提高我们的代码质量主要体现在它可以在我们开发某个功能的时候提前帮我们发现自己编写的代码的bug。举个例子，假如A同学写了一个叫做useOptions的hook它接受一个叫做options的参数，这个参数既可以是一个对象也可以是一个数组。A同学自己开发的过程中他只试过给useOptions传对象而没有试过给它传数组。同一个项目的B同学在使用useOptions的时候给它传了个数组发现代码挂了，这个时候B同学就得找A同学确认并等待A同学修复这个问题，这不但会影响B同学的开发进度而且还会让B同学觉得A同学不靠谱，或者觉得A同学的代码很烂。如果A同学有对useOptions进行单元测试的话，这个悲剧可能就不会发生了，因为A同学在为useOptions编写单元测试的时候就考虑了options为数组的情况，并且在B同学使用之前就修复了这个问题。因此编写单元测试可以让我们在开发的过程中提前考虑到很多后面使用才会发现的问题，进而提高我们的代码质量。 方便代码重构和新功能添加编写单元测试的过程其实是我们给代码编写使用说明书的过程（specification）。这个使用说明书十分重要，它相当于代码生产者（producer）与代码消费者（consumer）之间的合约（contract），生产者需要保证在消费者使用代码没错的前提下代码要有使用说明书上面的效果。这其实会对代码生产者起到一定的制约作用，因为生产者必须保证无论是给原来的代码添加新的功能还是对它进行重构，它都要满足原来使用说明书上的要求。 继续上面那个例子，A同学和B同学都在项目的1.0.0版本中使用了useOptions这个hook，虽然useOptions没有编写单元测试，可是代码是没有bug的（最起码没有被发现）。后面项目需要进行2.0.0版本的升级了，这时候A同学需要为useOptions添加新的功能，A同学在改动了useOptions的代码后，在自己使用到的地方（对象作为参数的地方）做了测试，没有发现bug。在A同学自测完代码后，并将这个更改集成（integration）到了项目的master分支上。后面B同学在更新完A同学的代码后，发现自己的代码出现了一些问题，这个时候B同学很可能就会手忙脚乱，并且可能需要花费一段时间才能定位到原来是A同学对useOptions的改动影响到他的功能，这除了会影响到项目的进度外还会让A同学和B同学的关系进一步恶化。这个悲剧同样也是可以通过编写单元测试来避免的，试想一下假如A同学有给useOptions编写配套的使用说明书（单元测试），A同学在改动完代码后，它的代码是通过不了使用说明书的检查的，因为它的改动改变了useOptions之前定义好的外部行为，这个时候A同学就会提前修复自己的代码进而避免了B同学后面的苦恼。通过这个例子大家可能还是没有体会到单元测试对于我们平时产品迭代或者代码重构的重要性，可是你试想一下在一个比较大的项目中是有很多个A同学和B同学的，也有成千上万个useOptions函数，当真的发生类似问题的时候bug将会更难被定位和修复，如果我们大部分的代码都有单元测试的话，无论是对代码增加新的功能还是对原来的代码进行重构我们都会更有信心。 完善我们代码的设计在软件工程里面有个概念叫做测试驱动开发（Test-driven Development），它鼓励我们在实际开始编码之前先为我们的代码编写测试用例。这样做的目的是让我们在开发之前就以代码使用者的角度去评判我们的代码设计。如果我们的代码设计很糟糕，我们就会发现我们很难为它们编写详尽的单元测试用例，相反如果我们的代码设计得很好（低耦合高内聚），各个函数的参数和功能都设计得十分合理，我们就十分容易就为它们编写对应的单元测试。我们要记住一句话：高质量的代码一定是可以被测试的（testable）。那么为什么是在还没开始写代码之前就编写测试用例呢？这是因为如果我们在代码写完之后再编写测试的话，即使我们发现代码设计得再不合理，我们也没有动力去改了，因为对设计的改动可能会让我们重写所有的代码，所以我们需要在实际编码之前进行单元测试的编写，因为这个时候的改代码阻力是最小的。 提供文档功能我们在为代码编写单元测试的时候实际上是在为代码编写一个个使用例子，因此别的开发者在使用我们代码的时候可以通过我们的单元测试来快速掌握我们定义的各种函数的用法。另外教大家一个实用的技巧：如果我们发现某个库的文档不是很全面的话，可以通过查看这个库的单元测试来快速掌握这个库的用法。 单元测试需要注意的问题隔离性上面我们说到单元测试是对代码独立的单元进行测试，这个独立的意思不是说这个函数（单元）不会调用另外一个函数（单元），而是说我们在测试这个函数的时候如果它有调用到其它的函数我们就需要mock它们，从而将我们的测试逻辑只放在被测试函数的逻辑上，不会受到其它依赖函数的影响。举个例子我们现在要测试以下函数： 1async function fetchUserDetails(userId) {2 const userDetail = await fetch(`https://myserver.com/users/${userId}`)3 return userDetail4} 在测试fetchUserDetails时我们就需要mock fetch这个函数了，因为我们现在测试的函数是fetchUserDetails，我们只需要确定在外界调用fetchUserDetails的时候fetch会被调用，并且调用的参数是“https://myserver.com/users/${userId}”就行了，至于fetch函数如何发请求和处理返回来的数据都是fetch函数自己的事，我们不应该在测试fetchUserDetails的时候关心这个问题。 单元测试要注意隔离性的另外一个原因是它可以保证当测试案例失败的时候我们可以十分容易定位到问题的所在。以上面的代码为例，如果我们没有mock fetch函数，一旦我们的测试失败，我们很难分清是fetchUserDetails逻辑错了还是fetch的逻辑错了。 可重复性我们编写的所有单元测试用例一定不能依赖外部的运行环境，否则我们的单元测试将不具备可重复性（repeatable）。所谓的可重复性就是：如果我们的单元测试用例现在是可以通过的，那么在代码不发生变动和测试用例没有改变的前提下它将是一直可以通过的。举个测试用例不具备可重复性的例子，假如你将项目的单元测试数据全部放在数据库里面，你今天运行项目的测试用例是可以通过的，而第二天其他人无意改了数据库的数据，这个时候你的测试用例就通过不了了，我们就说这些测试用例不具备可重复性，出现这个问题的主要原因是它们使用了外部的依赖作为测试条件。由此可见要使我们的测试用例具备可重复性的一个关键点是在编写单元测试的时候避免外部依赖，这些外部依赖包括数据库，网络请求和本地文件系统等。 另外一个影响到测试用例可重复性的一个重要的却容易被忽略的因素是：不同单元测试用例之间共用了一些测试数据，某个测试用例对测试数据的更改可能会影响其它测试用例的正确执行。因此我们在编写单元测试用例的时候一定要避免不同测试用例之间共用一些测试数据，尽量将每个测试用例隔离起来。 提高代码覆盖率在单元测试里面有个概念叫做代码覆盖率（test coverage），它表明我们代码被测试的程度。举个例子假如我们有一个100行的函数，在我们运行完所有的为这个函数编写的单元测试用例之后，如果测试框架告诉我们这个函数的覆盖率是80%，这表明我们的测试用例代码只覆盖了这个函数的80行代码，还有一些代码分支（if/else, switch, while）没有被执行到。如果我们想通过单元测试来提高我们代码质量的话，我们就需要保证我们代码的覆盖率足够大，尽量让被测试的函数的每一种被执行情况都被覆盖到（覆盖率100%），特别是一些异常的情况应该也要被覆盖到（例如参数错误，调用第三方依赖报错等），这样我们才能及早地发现代码的bug并进行修复。 测试用例运行时间要短我在上面说到单元测试是可以帮助我们更好地进行代码迭代和重构的，要做到这点其实要求我们在每次代码归并的时候对被merge的代码进行一些自动化检测（CI），这就包括项目单元测试用例的运行。试想一下在一个比较大型的项目里面单元测试用例的数量往往是很多的，少则几百个，多则上千个，如果全部运行所有测试用例的时间需要十几分钟甚至一两小时，这就会影响到代码集成的进度。为了避免这个问题，我们就需要确保每个单元测试用例执行的时间不能过长，例如避免在测试代码里面进行一些耗时的计算等。 如何对自定义Hook进行单元测试在React Hook实战指南中我们提到Hook就是一些函数，所以对Hook进行单元测试其实是对一个函数进行测试，只不过这个函数和普通函数的区别是它拥有React给它赋予的特殊功能。在讲如何对Hook进行测试之前我们先来了解一下我们要用到的测试框架Jest和hook测试库react-hook-testing-library。 JestJest是Facebook开源的一个单元测试框架，它的使用率和知名度都非常高，一些著名的开源项目例如webpack, babel和react等都是使用Jest来进行单元测试的，由于这篇文章的重点不是Jest的使用，所以我在这里将不为大家做具体的介绍，这里主要介绍一下我们常用到的Jest API： 常用APIit/testit/test函数是用来定义测试用例（test case）的，它的函数签名是it(description, fn?, timeout?)，description参数是对这个测试用例的一个简短的描述，fn是一个运行我们实际测试逻辑的函数，而timeout则是这个测试用例的超时时间。下面是一个简单的例子： 1import sum from 'somewhere/sum'23it('test if sum work for positive numbers', () =&gt; {4 const result = sum(1, 2)5 expect(result).toEqual(3)6}) describedescribe函数是用来给测试用例分组用的，它的函数签名是describe(description, fn)，description是用来描述这个分组的，而fn函数里面则可以定义内嵌的分组（nested）或者是一些测试用例（it），下面是一个简单的例子： 1import sum from 'somewhere/sum'23describe('test sum', () =&gt; {4 it('work for positive numbers', () =&gt; {5 const result = sum(1, 2)6 expect(result).toEqual(3)7 })89 it('work for negative numbers', () =&gt; {10 const result = sum(-1, -2)11 expect(result).toEqual(-3)12 })13}) expect我们在刚开始的时候就提到所谓的测试就是要比较被测试对象的输出和我们期待的输出是不是一致的，也就涉及到一个比较的过程，在Jest框架中我们可以通过expect函数来访问一系列matcher来进行这个比较的过程，例如上面的expect(sum).toEqual(3)就是一个用matcher来判断输出结果是不是我们想要的值的过程。关于更加详细的matcher信息大家可以参考jest的官方文档。 mock在Jest框架中用来进行mock的方法有很多，主要用到的是jest.fn()和jest.spyOn()。 jest.fnjest.fn会生成一个mock函数，这个函数可以用来代替源代码中被使用的第三方函数。jest.fn生成的函数上面有很多属性，我们也可以通过一些matcher来对这个函数的调用情况进行一些断言，下面是一个简单的例子： 1// somewhere/functionWithCallback.js2export const functionWithCallback = (callback) =&gt; {3 callback(1, 2, 3)4}56// somewhere/functionWithCallback.spec.js7import { functionWithCallback } from 'somewhere/functionWithCallback'89describe('Test functionWithCallback', () =&gt; {10 it('if callback is invoked', () =&gt; {11 const callback = jest.fn()12 functionWithCallback(callback)1314 expect(callback.mock.calls.length).toEqual(1)15 })16}) jest.spyOn我们源代码中的函数可能使用了另外一个文件或者node_modules中安装的一些依赖，这些依赖可以使用jest.spyOn来进行mock，下面是一个简单的例子： 1// somewhere/sum.js2import { validateNumber } from 'somewhere/validates'34export default (n1, n2) =&gt; {5 validateNumber(n1)6 validateNumber(n2)78 return n1 + n29}1011// somewhere/sum.spec.js12import sum from 'somewhere/sum'13import * as validates from 'somewhere/validates'1415it('work for positive numbers', () =&gt; {16 // mock validateNumber17 const validateNumberMock = jest.spyOn(validates, 'validateNumber')18 19 const result = sum(1, 2)20 expect(result).toEqual(3)2122 // restore original implementation23 validateNumberMock.mockRestore()24}) 我们在上面测试代码中引入了源代码使用到的依赖somewhere/validates，这个时候就可以通过jest.spyOn来mock这个依赖export的一些方法了，例如validateNumber。被mock的函数会在源代码被执行的时候使用，例如上面sum执行的时候使用到的validateNumber就是我们在sum.spec.js里面定义的validateNumberMock。这样我们除了可以保证validateNumber不会影响到我们对sum函数逻辑的测试，还可以在外面对validateNumberMock进行一些断言（assertion）来验证sum逻辑的正确性。还有一点需要注意的是，我在测试用例执行完之后调用了mockRestore这个函数，这个函数会恢复validateNumber函数原来的实现，从而避免这个测试用例对validate文件的更改影响到其它测试用例的正确执行。 项目引入jest了解完jest的一些基本API之后我们再来看一下如何在我们的项目里面引入jest。 安装依赖首先使用下面命令安装jest 1yarn add -D jest 如果你项目使用的是Typescript，则还需要安装ts-jest作为依赖： 1yarn add -D ts-jest 配置jest安装完jest后需要在package.json文件里面配置一下: 1{ 2 \"jest\": {3 \"transform\": {4 \"^.+\\\\.tsx?$\": \"ts-jest\"5 },6 \"testRegex\": \"(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.(jsx?|tsx?)$\",7 \"moduleDirectories\": [8 \"node_modules\",9 \"src\"10 ],11 \"moduleFileExtensions\": [12 \"ts\",13 \"tsx\",14 \"js\",15 \"jsx\",16 \"json\",17 \"node\"18 ]19 }20} 上面各个配置项的意思分别是： transform: 告诉jest，你的ts或者tsx文件需要使用ts-jest来进行转换。 testRegex: 告诉jest哪些文件是需要被作为测试代码进行执行的，从上面的正则表达式我们可以看出文件名中有test和spec的文件将会被作为测试用例执行。 moduleDirectories: 告诉jest在执行测试用例代码的时候，代码用到的dependencies应该去哪些目录进行resolve，在这里jest会去node_modules和src（或者你自己的源代码根目录）里面进行resolve，这个应该要和你项目的webpack.config.js的resolve部分配置保持一致。 moduleFileExtensions: 告诉jest在找不到对应文件的时候应该尝试哪些文件后缀。 React hooks testing libraryReact-hooks-testing-library，是一个专门用来测试React hook的库。我们知道虽然hook是一个函数，可是我们却不能用测试普通函数的方法来测试它们，因为它们的实际运行会涉及到很多React运行时（runtime）的东西，因此很多人为了测试自己的hook会编写一些TestComponent来运行它们，这种方法十分不方便而且很难覆盖到所有的情景。为了简化开发者测试hook的流程，React社区有人开发了这个叫做react-hooks-testing-library的库来允许我们像测试普通函数一样测试我们定义的hook，这个库其实背后也是将我们定义的hook运行在一个TestComponent里面，只不过它封装了一些简易的API来简化我们的测试。在开始使用这个库之前，我们先来看一下它对外暴露的一些常用的API。 常用APIrenderHookrenderHook这个函数顾名思义就是用来渲染hook的，它会在调用的时候渲染一个专门用来测试的TestComponent来使用我们的hook。renderHook的函数签名是renderHook(callback, options?)，它的第一个参数是一个callback函数，这个函数会在TestComponent每次被重新渲染的时候调用，因此我们可以在这个函数里面调用我们想要测试的hook。renderHook的第二个参数是一个可选的options，这个options可以带两个属性，一个是initialProps，它是TestComponent的初始props参数，并且会被传递给callback函数用来调用hook。options的另外一个属性是wrapper，它用来指定TestComponent的父级组件（Wrapper Component），这个组件可以是一些ContextProvider等用来为TestComponent的hook提供测试数据的东西。 renderHook的返回值是RenderHookResult对象，这个对象会有下面这些属性： result：result是一个对象，它包含两个属性，一个是current，它保存的是renderHook callback的返回值，另外一个属性是error，它用来存储hook在render过程中出现的任何错误。 rerender: rerender函数是用来重新渲染TestComponent的，它可以接收一个newProps作为参数，这个参数会作为组件重新渲染时的props值，同样renderHook的callback函数也会使用这个新的props来重新调用。 unmount: unmount函数是用来卸载TestComponent的，它主要用来覆盖一些useEffect cleanup函数的场景。 act这函数和React自带的test-utils的act函数是同一个函数，我们知道组件状态更新的时候（setState），组件需要被重新渲染，而这个重渲染是需要React进行调度的，因此是个异步的过程，我们可以通过使用act函数将所有会更新到组件状态的操作封装在它的callback里面来保证act函数执行完之后我们定义的组件已经完成了重新渲染。 安装直接把react-hooks-testing-library作为我们的项目devDependencies： 1yarn add -D @testing-library/react-hooks 注意：要使用react-hooks-testing-library我们要确保我们安装了16.9.0版本及其以上的react和react-test-renderer： 1yarn add react@^16.9.02yarn add -D react-test-renderer@^16.9.0 例子现在就让我们看一个简单的同时使用Jest和react-hooks-testing-library来测试hook的例子，假如我们在项目里面定义了一个叫做useCounter的Hook: 1// somewhere/useCounter.js2import { useState, useCallback } from 'react'34function useCounter() {5 const [count, setCount] = useState(0)67 const increment = useCallback(() =&gt; setCount(x =&gt; x + 1), [])8 const decrement = useCallback(() =&gt; setCount(x =&gt; x - 1), [])910 return {count, increment, decrease}11} 在上面的代码中我定义了一个叫做useCounter的hook，这个hook是用来封装一个叫做count的状态并且对外暴露对count进行操作的一些updater包括increment和decrement。如果大家对useState和useCallback不够熟悉的话可以看一下我的上一篇文章React Hook实战指南。接着就让我们编写这个hook的测试用例： 1// somewhere/useCounter.spec.js2import { renderHook, act } from '@testing-library/react-hooks'3import useCounter from 'somewhere/useCounter'45describe('Test useCounter', () =&gt; {6 describe('increment', () =&gt; {7 it('increase counter by 1', () =&gt; {8 const { result } = renderHook(() =&gt; useCounter())910 act(() =&gt; {11 result.current.increment()12 })1314 expect(result.current.count).toBe(1)15 })16 })1718 describe('decrement', () =&gt; {19 it('decrease counter by 1', () =&gt; {20 const { result } = renderHook(() =&gt; useCounter())2122 act(() =&gt; {23 result.current.decrement()24 })2526 expect(result.current.count).toBe(-1)27 })28})29}) 上面的代码中我们写了一个测试大组（describe）Test useCounter并在这个大组里面定义了两个测试小组分别用来测试useCounter返回的increment和decrement方法。我们具体看一下描述为increase counter by 1的测试用例的代码，首先我们要用renderHook函数来渲染要被测试的hook，这里我们需要将useCounter的返回值作为callback函数的返回值，这是因为我们需要在外面拿到这个hook的返回结果{count, increment, decrement}。接着我们使用act函数来调用改变组件状态count的increment函数，act函数完成之后我们的组件也就完成了重渲染，后面就可以判断更新后的count是不是我们想要的结果了。 总结在本篇文章中我给大家介绍了什么叫做单元测试，为什么我们需要在自己的项目里面引入单元测试以及教大家如何使用Jest和react-hooks-testing-library来测试我们自定义的hook。 这篇文章是我的React hook系列文章的最后一篇了，后面我还会持续为大家分享一些和hook相关的内容，大家敬请期待。 参考文献 https://jestjs.io/ https://react-hooks-testing-library.com/ 个人技术动态欢迎关注公众号进击的大葱一起学习成长","link":"/2020/07/22/React-Hook%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97/"},{"title":"Svelte 3 初学者完全指南","text":"React, Vue和Angular差不多占据了Web开发的大部分江山，可是最近半年Svelte开始逐渐吸引越来越多人的眼球。这个Svelte框架到底有什么过人之处呢？本文将会为大家分析一下Svelte火起来的原因，并且通过使用Svelte去搭建一个简单的书店应用（bookshop）来帮助大家快速入门这门框架。 Svelte为什么会火?要想知道Svelte为什么会火，首先得看看React和Vue这些框架存在什么问题。 big runtime - 大的运行时React和Vue都是基于runtime的框架。所谓基于runtime的框架就是框架本身的代码也会被打包到最终的bundle.js并被发送到用户浏览器。当用户在你的页面进行各种操作改变组件的状态时，框架的runtime会根据新的组件状态（state）计算（diff）出哪些DOM节点需要被更新，从而更新视图。那么这些runtime代码到底有多大呢，可以看一些社区的统计数据: Name Size Ember 2.2.0 435K Ember 1.13.8 486K Angular 2 566K Angular 2 + Rx 766K Angular 1.4.5 143K Vue 2.4.2 58.8K Inferno 1.2.2 48K Preact 7.2.0 16K React 0.14.5 + React DOM 133K React 0.14.5 + React DOM + Redux 139K React 16.2.0 + React DOM 97.5K 从上面的表格可以看出常用的框架中，最小的Vue都有58k，React更有97.5k。换句话说如果你使用了React作为开发的框架，即使你的业务代码很简单，你的首屏bundle size都要100k起步。当然100k不算很大，可是事物都是相对的，相对于大型的管理系统来说100k肯定不算什么，可是对于那些首屏加载时间敏感的应用（例如淘宝，京东主页），100k的bundle size在一些网络环境不好的情况或者手机端真的会影响用户体验。那么如何减少框架的runtime代码大小呢？要想减少runtime代码的最有效的方法就是压根不用runtime。其实回想一下Web开发的历史，很早之前在用Jquery和Bootstrap一把梭的时候，我们的代码不就是不包含runtime的吗？当数据变化时直接通过JavaScript去改变原生DOM节点，没有框架那一系列diff和调度（React Fiber）的过程。这时你可能会问，要减少bundle size真的要回到那个刀耕火种的时代吗？有没有那种既可以让我用接近React和Vue的语法编写代码，同时又不包含框架runtime的办法。这恰恰就是Svelte要做的东西，它采用了Compiler-as-framework的理念，将框架的概念放在编译时而不是运行时。你编写的应用代码在用诸如Webpack和Rollup等工具打包的时候会被直接转换为JavaScript对DOM节点的原生操作，从而让bundle.js不包含框架的runtime。那么Svelte到底可以将bundle size减少多少呢？以下是RealWorld这个项目的统计：由上面的图表可以看出实现相同功能的应用，Svelte的bundle size大小是Vue的1/4，是React的1/20！单纯从这个数据来看，Svelte这个框架对bundle size的优化真的很大。 低效的Virtual DOM Diff什么？Virtual DOM不是一直都很高效的吗？其实Virtual DOM高效是一个误解。说Virtual DOM高效的一个理由就是它不会直接操作原生的DOM节点，因为这个很消耗性能。当组件状态变化时它会通过某些diff算法去计算出本次数据更新真实的视图变化，然后只改变“需要改变”的DOM节点。用过React的人可能都会体会到React并没有想象中那么高效，框架有时候会做很多无用功，这体现在很多组件会被“无缘无故”进行重渲染（re-render）。注意这里说的re-render和对原生DOM进行操作是两码事！所谓的re-render是你定义的class Component的render方法被重新执行，或者你的组件函数被重新执行。组件被重渲染是因为Vitual DOM的高效是建立在diff算法上的，而要有diff一定要将组件重渲染才能知道组件的新状态和旧状态有没有发生改变，从而才能计算出哪些DOM需要被更新。你可能会说React Fiber不是出来了吗，这个应该不是问题了吧？其实Fiber这个架构解决的问题是不让组件的重渲染和reconcile的过程阻塞主线程的执行，组件重渲染的问题依然存在，而且据反馈，React Hooks出来后组件的重渲染更加频繁了。正是因为框架本身很难避免无用的渲染，React才允许你使用一些诸如shouldComponentUpdate，PureComponent和useMemo的API去告诉框架哪些组件不需要被重渲染，可是这也就引入了很多模板代码（boilerplate）。如果大家想了解更多关于Virtual DOM存在的问题，可以看一下virtual dom is pure overhead这篇文章。 那么如何解决Vitual DOM算法低效的问题呢？最有效的解决方案就是不用Virtual DOM！其实作为一个框架要解决的问题是当数据发生改变的时候相应的DOM节点会被更新（reactive），Virtual DOM需要比较新老组件的状态才能达到这个目的，而更加高效的办法其实是数据变化的时候直接更新对应的DOM节点： 1if (changed.name) {2 text.data = name;3} 这就是Svelte采用的办法。Svelte会在代码编译的时候将每一个状态的改变转换为对应DOM节点的操作，从而在组件状态变化的时候快速高效地对DOM节点进行更新。根据js framework benchmark的统计，Svelte在对一些大列表操作的时候性能比React和Vue都要好。 什么是Svelte?Svelte是由RollupJs的作者Rich Harris编写的编译型框架，没了解过RollupJs的同学可以去它官网了解一下，它其实是一个类似于Webpack的打包工具。Svelte这个框架具有以下特点： 和React，Vue等现代Web框架的用法很相似，它可以允许开发者快速开发出具有流畅用户体验的Web应用。 不使用Virtual DOM，也不是一个runtime的库。 基于Compiler as framework的理念，会在编译的时候将你的应用转换为原生的DOM操作。 默认就支持类似于CSS modules的CSS scope功能，让你避免CSS样式冲突的困扰。 原生支持CSS animation。 极其容易的组件状态管理（state management），减少开发者的模板代码编写（boilerplate less）。 支持反应式定义（Reactive statement）。 极其容易的应用全局状态管理，框架本身自带全局状态，类似于React的Redux和Vue的Vuex。 支持context，避免组件的props drilling。 Svelte这个框架与Vue和React之间最大的区别是它除了管理组件的状态和追踪他们的渲染，还有很多其他有用的功能。例如它原生支持CSS scope和CSS animation。如果你用React或者Vue是需要引入第三方库来实现同样的功能的，而第三方依赖的引入会给开发者增加学习和维护的成本。 用Svelte搭建一个Bookshop应用接下来我们会从头开始搭建一个基于Svelte框架的简单书店应用bookshop，通过这个demo，希望大家可以理解Svelte的一些基本概念和掌握它的一些基本用法并能够使用Svelte去搭建更加复杂的应用。 应用功能Bookshop应用支持以下功能： 管理员录入新图书 展示书店图书列表 将图书加到购物车 展示购物车的数据信息 对学习者的技术要求 掌握html，css和javascript的基础用法 有过React或者Vue的相关开发经验最佳 项目的源代码可以在我的github仓库找到。 项目搭建首先在我们的本地开发环境新建一个项目文件夹： 1mkdir svelte-bookshop 接着用svelte官方的脚手架去初始化我们的应用： 1npx degit sveltejs/template svelte-bookshop2cd svelte-bookshop34yarn5yarn dev degit这个命令会将github上面的项目文件直接拷贝到某个本地文件夹，这里使用到的svelte/tempalte模板项目的github地址是这个。以上命令成功运行后，访问http://localhost:5000你会看到如下界面：界面很简单就是展示一个hello world，接着让我们看一下生成的项目目录结构：生成的代码主要包含以下文件目录结构： rollup.config.js，这个是rollup的配置文件，类似于webpack.config.js，里面指定了项目的入口文件是src/main.js。 src文件夹，这个文件夹用来存储我们的项目源代码，现在只有一个项目的主入口文件main.js和一个组件文件App.svelte。 public文件夹，这个文件夹是用来存储项目的静态文件（index.html, global.css和favicon.png）和rollup编译生成的静态文件（build文件夹底下的bundle.js和bundle.css以及它们各自的source map）。 接着让我们具体看一下src文件夹底下的各个文件内容 src/App.svelte1&lt;script&gt;2 export let name;3&lt;/script&gt;45&lt;main&gt;6 &lt;h1&gt;Hello {name}!&lt;/h1&gt;7 &lt;p&gt;Visit the &lt;a href=\"https://svelte.dev/tutorial\"&gt;Svelte tutorial&lt;/a&gt; to learn how to build Svelte apps.&lt;/p&gt;8&lt;/main&gt;910&lt;style&gt;11 main {12 text-align: center;13 padding: 1em;14 max-width: 240px;15 margin: 0 auto;16 }1718 h1 {19 color: #ff3e00;20 text-transform: uppercase;21 font-size: 4em;22 font-weight: 100;23 }2425 @media (min-width: 640px) {26 main {27 max-width: none;28 }29 }30&lt;/style&gt; 这个文件定义了一个叫做App的Svelte组件，这里要注意App.svelte文件内并没有定义组件的名称，组件的名称是由它的文件名确定的。Svelte组件的文件名都是以.svelte结尾的，一个组件文件通常会包含以下三部分内容： &lt;script&gt;标签，和组件相关的任何JavaScript代码都可以放在这里，例如组件的状态定义或者一些异步Ajax请求。在这个App.svelte文件里面没有定义局部的组件状态，而是定义并export了一个name变量。对于Svelte框架，export一个变量就是将这个变量指定为当前组件的一个外部参数 - props。这种做法和React里面的将props作为组件的第一个参数的区别很大，可能大家一开始有点不习惯，不过后面习惯了，你可能也会爱上这种写法的。 &lt;style&gt;标签，和组件相关的CSS代码会放在这里。注意这里的CSS是局部生效的（scope），也就是说App.svelte中的h1标签的样式只会对App组件内的h1标签生效，而对项目其他的包括这个组件的子节点的h1标签失效。具体可以用浏览器的调试工具看一下h1标签的实际样式就明白了: 由上图可以看出Svelte在生成代码的时候会用一些随机的哈希值将组件的样式和其它组件的样式区别开来。 组件的HTML标签。组件的HTML标签可以直接在文件中写出来，例如App组件的HTML部分是：1&lt;main&gt;2 &lt;h1&gt;Hello {name}!&lt;/h1&gt;3 &lt;p&gt;Visit the &lt;a href=\"https://svelte.dev/tutorial\"&gt;Svelte tutorial&lt;/a&gt; to learn how to build Svelte apps.&lt;/p&gt;4&lt;/main&gt; App组件最外层是一个main标签，main标签里面有一个h1标签和p标签，其中h1标签里面是一个Hello字符串加一个用花括号包裹的插入字符串（interpolation），在React JSX里面的写法应该是Hello ${name}，它们都表示这个位置的字符串就是name这个变量的内容。至于这个name变量就是我们在上面用export定义的外部参数。 总的来说Svelte会将所有和组件相关的JavaScript，CSS和HTML代码都放在同一个文件里面，这个做法有点像Vue，不过和Vue相比它的模板代码更少。 src/main.js1import App from './App.svelte';23const app = new App({4 target: document.body,5 props: {6 name: 'world'7 }8});910export default app; 这个文件内容很简单，就是将刚刚定义的App组件挂载到目标节点body上，而且为App组件提供了值为world的name参数。这段代码的作用和React中的ReactDOM.render函数一样。 接着让我们看一下生成的静态代码是什么样子的。 public/build/bundle.js先看生成的JavaScript主文件bundle.js，由于原文件比较大，我只截取了其中比较关键的一部分： 1/* src/App.svelte generated by Svelte v3.16.4 */23const file = \"src/App.svelte\";45function create_fragment(ctx) {6 let main;7 let h1;8 let t0;9 let t1;10 let t2;11 let t3;12 let p;13 let t4;14 let a;15 let t6;1617 const block = {18 c: function create() {19 main = element(\"main\");20 h1 = element(\"h1\");21 t0 = text(\"Hello \");22 t1 = text(/*name*/ ctx[0]);23 t2 = text(\"!\");24 t3 = space();25 p = element(\"p\");26 t4 = text(\"Visit the \");27 a = element(\"a\");28 a.textContent = \"Svelte tutorial\";29 t6 = text(\" to learn how to build Svelte apps.\");30 attr_dev(h1, \"class\", \"svelte-1tky8bj\");31 add_location(h1, file, 5, 1, 46);32 attr_dev(a, \"href\", \"https://svelte.dev/tutorial\");33 add_location(a, file, 6, 14, 83);34 add_location(p, file, 6, 1, 70);35 attr_dev(main, \"class\", \"svelte-1tky8bj\");36 add_location(main, file, 4, 0, 38);37 },38 l: function claim(nodes) {39 throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");40 },41 m: function mount(target, anchor) {42 insert_dev(target, main, anchor);43 append_dev(main, h1);44 append_dev(h1, t0);45 append_dev(h1, t1);46 append_dev(h1, t2);47 append_dev(main, t3);48 append_dev(main, p);49 append_dev(p, t4);50 append_dev(p, a);51 append_dev(p, t6);52 },53 p: function update(ctx, dirty) {54 if (dirty[0] &amp; /*name*/ 1) set_data_dev(t1, /*name*/ ctx[0]);55 },56 i: noop,57 o: noop,58 d: function destroy(detaching) {59 if (detaching) detach_dev(main);60 }61 };6263 dispatch_dev(\"SvelteRegisterBlock\", {64 block,65 id: create_fragment.name,66 type: \"component\",67 source: \"\",68 ctx69 });7071 return block;72} 这段代码对应的就是我们刚刚定义的App组件，create_fragment方法会接受一个上下文对象ctx参数并返回一个代表组件的block对象。 block这个对象主要包含以下四个重要的方法c（create），m（mount），p（update）和d（destroy）。 c（create）1function create() {2 main = element(\"main\");3 h1 = element(\"h1\");4 t0 = text(\"Hello \");5 t1 = text(/*name*/ ctx[0]);6 t2 = text(\"!\");7 t3 = space();8 p = element(\"p\");9 t4 = text(\"Visit the \");10 a = element(\"a\");11 a.textContent = \"Svelte tutorial\";12 t6 = text(\" to learn how to build Svelte apps.\");13 attr_dev(h1, \"class\", \"svelte-1tky8bj\");14 add_location(h1, file, 5, 1, 46);15 attr_dev(a, \"href\", \"https://svelte.dev/tutorial\");16 add_location(a, file, 6, 14, 83);17 add_location(p, file, 6, 1, 70);18 attr_dev(main, \"class\", \"svelte-1tky8bj\");19 add_location(main, file, 4, 0, 38);20} 这个函数的功能是生成（create）和App组件相关的一些原生DOM节点，并为它们添加一些元数据（meta data）。 m（mount）1function mount(target, anchor) {2 insert_dev(target, main, anchor);3 append_dev(main, h1);4 append_dev(h1, t0);5 append_dev(h1, t1);6 append_dev(h1, t2);7 append_dev(main, t3);8 append_dev(main, p);9 append_dev(p, t4);10 append_dev(p, a);11 append_dev(p, t6);12} 这个函数的功能是挂载c函数生成的那些DOM节点。 p（update）1function update(ctx, dirty) {2 if (dirty[0] &amp; /*name*/ 1) set_data_dev(t1, /*name*/ ctx[0]);3} p函数会在ctx上下文更新的时候去更新对应DOM节点的属性。大概就是当上下文变化的时候，检查一下name这个变量有没有变化，如果发生变化则更新DOM节点。 d（destroy）1function destroy(detaching) {2 if (detaching) detach_dev(main);3} d函数是用来删除App组件的。 看完Svelte生成的代码后，我想你对我在文章开头说的Compiler-as-framework等概念应该有了更加深刻的认识，Svelte和React（Vue也类似）不一样的是，React应用在打包完之后，还保留了如React.createElement，setState等框架函数的调用代码，而Svelte编译完之后，框架代码会被转化为操作原生DOM节点的代码。 大概了解了项目的组织结构后，让我们开始正式搭建书店bookshop应用。 组件定义HTML markup首先让我们创建一个展示书本具体信息的卡片组件，在src文件夹底下新建一个BookCard.svelte文件，里面定义一下卡片组件的HTML markup： 1// src/BookCard.svelte2&lt;div&gt;3 &lt;h1&gt;title&lt;/h1&gt;4 &lt;div&gt;price&lt;/div&gt;5 &lt;div&gt;description&lt;/div&gt;6 &lt;button&gt;添加到购物车&lt;/button&gt;7&lt;/div&gt; 然后在App.svelte组件里面使用BookCard组件: 1// src/App.svelte2&lt;script&gt;3 import BookCard from \"./BookCard.svelte\";4&lt;/script&gt;56&lt;style&gt;7 ...8&lt;/style&gt;910&lt;main&gt;11 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;12 &lt;section&gt;13 &lt;BookCard /&gt;14 &lt;/section&gt;15&lt;/main&gt; 使用自定义的组件的方法很简单：先在script标签里面导入新定义的组件BookCard，然后将该组件写在App组件的HTML markup里面，语法和JSX一样的。这时候再查看页面的内容： CSSBookCard组件虽然出来了，我们得定义一些CSS让它变得更好看一点： 1// src/BookCard.svelte2&lt;style&gt;3 .card {4 text-align: left;5 border-radius: 5px;6 box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);7 padding: 10px;8 }910 h1 {11 font-size: 20px;12 }1314 h2 {15 font-size: 15px;16 color: #999;17 }1819 button {20 background-color: #ff3e00;21 color: white;22 border-radius: 5px;23 cursor: pointer;24 border: none;25 }26&lt;/style&gt;2728&lt;div class=\"card\"&gt;29 &lt;h1&gt;title&lt;/h1&gt;30 &lt;h2&gt;price&lt;/h2&gt;31 &lt;p&gt;description&lt;/p&gt;32 &lt;button&gt;添加到购物车&lt;/button&gt;33&lt;/div&gt; 给组件定义样式的方法就是新建一个style标签然后把该组件相关的样式写在这个标签内，注意这里的样式只会对组件内的元素有效，不会影响到其他组件的样式的。加完样式后，界面应该会变成这个样子： props定义书本的具体信息应该是由传入的props指定的。Svelte组件的props要用export来指明，指明的props变量可以直接被组件使用： 1// src/BookCard.svelte2&lt;script&gt;3 export let title;4 export let price;5 export let description;6&lt;/script&gt;78&lt;style&gt;9...10&lt;/style&gt;1112&lt;div class=\"card\"&gt;13 &lt;h1&gt;title&lt;/h1&gt;14 &lt;h2&gt;price&lt;/h2&gt;15 &lt;p&gt;description&lt;/p&gt;16 &lt;button&gt;添加到购物车&lt;/button&gt;17&lt;/div&gt; 变量使用定义和引入的变量可以在组件的HTML markup中直接使用，具体用法是在Markup中用花括号（curly braces）引用该变量，具体代码时： 1// src/BookCard.svelte2&lt;script&gt;3 export let title;4 export let price;5 export let description;6&lt;/script&gt;78&lt;style&gt;9...10&lt;/style&gt;1112&lt;div class=\"card\"&gt;13 &lt;h1&gt;{title}&lt;/h1&gt;14 &lt;h2&gt;${price}&lt;/h2&gt;15 &lt;p&gt;{description}&lt;/p&gt;16 &lt;button&gt;添加到购物车&lt;/button&gt;17&lt;/div&gt; 组件参数传递然后在父级组件App中，将BookCard需要的参数传给该组件： 1// src/App.svelte2&lt;script&gt;3 ...4 let title = \"JavaScript高级编程\";5 let price = 99.0;6 let description = \"一起来学习JavaScript啊\";7&lt;/script&gt;89&lt;style&gt;10 ...11&lt;/style&gt;1213&lt;main&gt;14 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;15 &lt;section&gt;16 &lt;BookCard title={title} price={price} description={description} /&gt;17 &lt;/section&gt;18&lt;/main&gt; 这时候书本卡片的内容应该是传入的参数了：对于组件参数传递，Svelte还提供了以下更加方便的写法： 1// src/App.svelte2&lt;main&gt;3 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;4 &lt;section&gt;5 &lt;BookCard {title} {price} {description} /&gt;6 &lt;/section&gt;7&lt;/main&gt; 录入书本信息作为一个书店，管理员应该可以录入新的图书，所以我们给App组件添加一个简单的表单来让用户录入数据： 1// src/App.svelte2&lt;script&gt;3 ...4&lt;/script&gt;56&lt;style&gt;7 ....8&lt;/style&gt;910&lt;main&gt;11 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;12 &lt;section&gt;13 &lt;h2&gt;Add new book&lt;/h2&gt;14 &lt;label for=\"title\"&gt;Title&lt;/label&gt;15 &lt;input type=\"text\" id=\"title\" value={title} /&gt;16 &lt;label for=\"price\"&gt;Price&lt;/label&gt;17 &lt;input type=\"number\" id=\"price\" value={price} /&gt;18 &lt;label for=\"description\"&gt;Description&lt;/label&gt;19 &lt;textarea rows=\"3\" id=\"description\" value={description} /&gt;20 &lt;/section&gt;21 &lt;section&gt;22 &lt;BookCard {title} {price} {description} /&gt;23 &lt;/section&gt;24&lt;/main&gt; 我们为App组件新建了一些input标签，并指定这些input标签的值为我们之前定义的变量，这时候我们试着改变输入框的内容：虽然输入框的初始值是变量对应的值，可是变量的值并不会随着输入框的值的改变而改变，也就是它们的值没有”绑定起来“，要想实现双向数据绑定，我们可以给输入框添加一个监听事件。 事件绑定我们可以使用on关键字加事件名称给DOM添加事件监听器，以下代码将会监听input输入框的input事件： 1&lt;script&gt;2 ...3 let title = \"JavaScript高级编程\";4 ...56 function handleTitleChange(event) {7 title = event.target.value;8 }9&lt;/script&gt;1011&lt;style&gt;12 ...13&lt;/style&gt;1415&lt;main&gt;16 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;17 &lt;section&gt;18 &lt;h2&gt;Add new book&lt;/h2&gt;19 &lt;label for=\"title\"&gt;Title&lt;/label&gt;20 &lt;input type=\"text\" id=\"title\" value={title} on:input={handleTitleChange} /&gt;21 ...22 &lt;/section&gt;23&lt;/main&gt; 这时候我们再改变input的值，会发现卡片里面的内容也发生了改变，说明我们成功改变了title变量的值： 自动数据双向绑定可是如果每一个input标签都要手动添加一个事件监听的话我们的代码会有很多模板代码，为了解决这个问题，Svelte允许我们直接用bind关键字加要绑定的属性进行双向数据绑定： 1// src/App.svelte2&lt;script&gt;3 ...4 let title = \"JavaScript高级编程\";5 let price = 99.0;6 let description = \"一起来学习JavaScript啊\";7&lt;/script&gt;89&lt;style&gt;10 ...11&lt;/style&gt;1213&lt;main&gt;14 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;15 &lt;section&gt;16 &lt;h2&gt;Add new book&lt;/h2&gt;17 &lt;label for=\"title\"&gt;Title&lt;/label&gt;18 &lt;input type=\"text\" id=\"title\" bind:value={title} /&gt;19 &lt;label for=\"price\"&gt;Price&lt;/label&gt;20 &lt;input type=\"number\" id=\"price\" bind:value={price} /&gt;21 &lt;label for=\"description\"&gt;Description&lt;/label&gt;22 &lt;textarea rows=\"3\" id=\"description\" bind:value={description} /&gt;23 &lt;/section&gt;24 ...25&lt;/main&gt; 这时候我们就可以把各个变量的初始值去掉： 1// src/App.svelte2&lt;script&gt;3 let title = \"\";4 let price = 0;5 let description = \"\";6&lt;/script&gt; 这时候我们页面的输入框和所有变量都”绑定“起来了： 展示书本列表我们的书店应该不止一本书，要用一个数组把所有的书本存起来： 1// src/App.svelte2&lt;script&gt;3 ...4 let books = [];5 ...6&lt;/script&gt; 接着我们再为刚刚新增的表单添加一个提交按钮，用户填完书本的信息后点击提交会新建一个book对象，新建的book对象会被加到books列表中去： 1&lt;script&gt;2 ...3 let books = [];45 function handleAddBook() {6 books = books.concat({ title, price, description });7 title = \"\";8 price = 0;9 description = \"\";10 }11 ...12&lt;/script&gt;1314&lt;style&gt;15 ...16 button {17 background-color: #ff3e00;18 color: white;19 border-radius: 5px;20 cursor: pointer;21 border: none;22 }23 ...24&lt;/style&gt;2526&lt;main&gt;27 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;28 &lt;section&gt;29 &lt;h2&gt;Add new book&lt;/h2&gt;30 &lt;label for=\"title\"&gt;Title&lt;/label&gt;31 &lt;input type=\"text\" id=\"title\" bind:value={title} /&gt;32 &lt;label for=\"price\"&gt;Price&lt;/label&gt;33 &lt;input type=\"number\" id=\"price\" bind:value={price} /&gt;34 &lt;label for=\"description\"&gt;Description&lt;/label&gt;35 &lt;textarea rows=\"3\" id=\"description\" bind:value={description} /&gt;36 &lt;div&gt;37 &lt;button on:click={handleAddBook}&gt;add book&lt;/button&gt;38 &lt;/div&gt;39 &lt;/section&gt;40 ...41&lt;/main&gt; 展示列表数据我们可以使用each语法块去展示books列表的数据： 1// src/App.svelte2&lt;script&gt;3 ....45 let books = [];67 function handleAddBook() {8 books = books.concat({ title, price, description });9 title = \"\";10 price = 0;11 description = \"\";12 }13&lt;/script&gt;1415&lt;main&gt;16 ...17 &lt;section&gt;18 {#each books as book}19 &lt;BookCard20 title={book.title}21 price={book.price}22 description={book.description} /&gt;23 {/each}24 &lt;/section&gt;25&lt;/main&gt; 你也可以直接在each块定义的时候解构出被递归对象里面的内容，上面的代码变为： 1// src/App.svelte2 ...3 &lt;section&gt;4 {#each books as { title, price, description }}5 &lt;BookCard {title} {price} {description} /&gt;6 {/each}7 &lt;/section&gt;8 ... 代码更改完后，你的页面就可以录入新书并展示书的列表了： 购物车功能首先我们要为BookCard这个组件的按钮添加一个点击事件：用户点击书本卡片按钮的时候这本书会被加到购物车中。要实现这个效果我们可以为BookCard按钮定义一个handleAddBook的参数，这个参数由外面组件来提供，handleAddBook函数会在用户点击BookCard按钮的时候被调用并将该书添加购物车中。代码如下： 1// src/BookCard.svelte2&lt;script&gt;3 ...4 export let handleAddToCart;5&lt;/script&gt;67&lt;style&gt;8 ...9&lt;/style&gt;1011&lt;div class=\"card\"&gt;12 &lt;h1&gt;{title}&lt;/h1&gt;13 &lt;h2&gt;${price}&lt;/h2&gt;14 &lt;p&gt;{description}&lt;/p&gt;15 &lt;button on:click={() =&gt; handleAddToCart(title)}&gt;添加到购物车&lt;/button&gt;16&lt;/div&gt; 1// src/App.svelte2&lt;script&gt;3 ...4 let booksInCart = [];56 function handleAddToCart(title) {7 let bookNeededToBeAdded = books.find(book =&gt; book.title == title);8 booksInCart = booksInCart.concat(bookNeededToBeAdded);9 }10&lt;/script&gt;1112&lt;style&gt;13 ...14&lt;/style&gt;1516&lt;main&gt;17 ...18 &lt;section&gt;19 &lt;h2&gt;购物车&lt;/h2&gt;20 {#each booksInCart as { title, price }}21 &lt;div&gt;名称: {title}, 价钱: {price}&lt;/div&gt;22 {/each}23 &lt;/section&gt;24 &lt;section&gt;25 &lt;h2&gt;书单&lt;/h2&gt;26 {#each books as { title, price, description }}27 &lt;BookCard {title} {price} {description} {handleAddToCart} /&gt;28 {/each}29 &lt;/section&gt;30&lt;/main&gt; 这时候我们就可以看到我们的购物车了： 条件判断Svelte可以用if语法块根据不同条件展示不同的内容，我们可以在购物车为空的时候给用户展示一个空的状态： 1// src/App.svelte2...3&lt;section&gt;4 &lt;h2&gt;购物车&lt;/h2&gt;5 {#if booksInCart.length === 0}6 &lt;p&gt;购物车空的哦~&lt;/p&gt;7 {:else}8 {#each booksInCart as { title, price }}9 &lt;div&gt;名称: {title}, 价钱: {price}&lt;/div&gt;10 {/each}11 {/if}12&lt;/section&gt;13... 这时候界面变为： 展示购物车统计信息我们再为书店添加一个帮用户统计购物车的书本的功能，可以展示现在购物车里面的书本总数和总金额，代码如下: 1// src/App.svelte2&lt;script&gt;3 ...4 let booksInCart = [];56 let booksNumInCart = booksInCart.length;7 let totalCheckoutPrice = booksInCart.reduce(8 (sum, book) =&gt; sum + book.price,9 010 );11 ...12&lt;/script&gt;1314...15&lt;section&gt;16 &lt;h2&gt;购物车&lt;/h2&gt;17 &lt;div&gt;书本总数：{booksNumInCart}&lt;/div&gt;18 &lt;div&gt;订单金额：{totalCheckoutPrice}&lt;/div&gt;19 ...20&lt;/section&gt;21... 这时候我们操作界面却发现购物车的数据变化时统计数据竟然没有变化：数据没有变化的原因是我们每次添加书本到购物车的时候没有手动地去改变booksNumInCart和totalCheckoutPrice的值。不过如果需要在购物车数据发生变化的时候手动维护统计数据的话，代码会变得很丑陋。 反应式定义对于这种情况，Svelte提供了反应式定义（Reactive assignment）的方法来表示这种联动的数据，具体做法就是用$符号定义变量而不是let，以下是代码： 1&lt;script&gt;2 ...3 let booksInCart = [];45 $: booksNumInCart = booksInCart.length;6 $: totalCheckoutPrice = booksInCart.reduce(7 (sum, book) =&gt; sum + book.price,8 09 );10 ...11&lt;/script&gt; 这样当booksInCart这个数据发生改变的时候，booksNumInCart和totalCheckoutPrice这个两个变量就会自动被重新计算。这时候我们再对界面进行操作的话，会发现统计数据会随着购物车的数据变化而自动发生改变： 总结我们的简易书店系统（bookshop）大概就实现了这些功能，现在来总结一下在开发项目的时候覆盖到的Svelte框架基础知识： 组件定义 - component definition 变量使用 - using variables props定义和参数传递 - props definition and passing 事件监听 - event listening 数据绑定 - data binding 条件判断 - if condition 列表数据展示 - each block 其实Svelte框架还有很多我没有提到的有用的功能特性，例如： 事件传递 - event forwarding 生命周期函数 - life-cycle functions 全局状态管理 - stores 上下文管理 - context CSS 动画 - css animation … 由于文章篇幅的限制我在这里没有覆盖Svelte所有的属性，大家兴趣可以看一下svelte的官方教程。 我个人对Svelte框架的一些看法个人觉得由于Virtual DOM的各种问题，Compiler as framework这个思路应该是前端框架发展的一个趋势。Svelte目前实现的功能虽然已经非常不错了，可是就目前来说我觉得它还有以下问题： Scalability - 可扩展性。React和Vue等框架自带的runtime虽然会增加首屏加载的bundle.js，可是当项目变得越来越大的时候，框架的runtime在bundle.js里面占据的比例也会越来越小，相反由于Svelte生成的代码的封装性没有React和Vue的好，它在大型项目中会不会堆积很多重复的代码呢？这个时候我们就得考虑一下是不是存在一个Svelte生成的代码大于React和Vue生成的代码的阈值了。这个问题现在还没有具体的答案，只能等后人实践的时候给出答案了，大家有兴趣可以看一下作者在github上面的讨论。 Ecosystem - 生态。作为一个最近才火起来的框架，Svelte的生态还远远不及已经普及那么多年的React和Vue，这也是我觉得就目前来说Svelte还撼动不了React和Vue的地位的原因。不过Svelte会不会因为它的先进性而迎来生态大爆发呢？我们可以拭目以待。 不过有一点可以肯定的是，Svelte由于在一些不复杂的项目中生成的代码远远比React，Vue和Angular小的优势会在一些性能不那么好的嵌入式操作系统中大放异彩。 学习Svelte有用的链接 作者的Rethinking reactivity演讲 Svelte官网 Svelte github仓库 个人技术动态欢迎关注公众号进击的大葱一起学习成长","link":"/2019/12/17/Svelte-3-%E5%88%9D%E5%AD%A6%E8%80%85%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"},{"title":"React Hook实践指南","text":"在React为什么需要Hook这篇文章中我们探讨了React开发团队为什么要为Function Component添加Hook的原因，在本篇文章中我将会为大家提供一份较为全面的React Hook实践指南，其中包括以下方面的内容： 什么是React Hook 常用Hook介绍 useState useEffect useRef useCallback useMemo useContext useReducer 自定义Hook 什么是React HookReact Hook是React 16.8版本之后添加的新属性，用最简单的话来说，React Hook就是一些React提供的内置函数，这些函数可以让Function Component和Class Component一样能够拥有组件状态（state）以及进行副作用（side effect）。 常用Hook介绍接下来我将会为大家介绍一些常用的Hook，对于每一个Hook，我都会覆盖以下方面的内容： 作用 用法 注意事项 useState作用useState理解起来非常简单，和Class Component的this.state一样，都是用来管理组件状态的。在React Hook没出来之前，Function Component也叫做Functional Stateless Component（FSC），这是因为Function Component每次执行的时候都会生成新的函数作用域所以同一个组件的不同渲染（render）之间是不能够共用状态的，因此开发者一旦需要在组件中引入状态就需要将原来的Function Component改成Class Component，这使得开发者的体验十分不好。useState就是用来解决这个问题的，它允许Function Component将自己的状态持久化到React运行时（runtime）的某个地方（memory cell），这样在组件每次重新渲染的时候都可以从这个地方拿到该状态，而且当该状态被更新的时候，组件也会重渲染。 用法1const [state, setState] = useState(initialState) useState接收一个initialState变量作为状态的初始值，返回值是一个数组。返回数组的第一个元素代表当前state的最新值，第二个元素是一个用来更新state的函数。这里要注意的是state和setState这两个变量的命名不是固定的，应该根据你业务的实际情况选择不同的名字，可以是text和setText，也可以是width和setWidth这类的命名。（对上面数组解构赋值不熟悉的同学可以看下MDN的介绍）。 我们在实际开发中，一个组件可能不止一个state，如果组件有多个state，则可以在组件内部多次调用useState，以下是一个简单的例子： 1import React, { useState } from 'react'2import ReactDOM from 'react-dom'34const App = () =&gt; {5 const [counter, setCounter] = useState(0)6 const [text, setText] = useState('')78 const handleTextChange = (event) =&gt; {9 setText(event.target.value)10 }1112 return (13 &lt;&gt;14 &lt;div&gt;Current counter: {counter}&lt;/div&gt;15 &lt;button16 onClick={() =&gt; setCounter(counter + 1)}17 &gt;18 Increase counter19 &lt;/button&gt;20 &lt;input21 onChange={handleTextChange}22 value={text}23 /&gt;24 &lt;/&gt;25 )26}2728ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) 和Class Component的this.setState API类似，setCounter和setText都可以接收一个函数为参数，这个函数叫做updater，updater接收的参数是当前状态的最新值，返回值是下一个状态。例如setCounter的参数可以改成一个函数： 1&lt;button2 onClick={() =&gt; {3 setCounter(counter =&gt; counter + 1)4 }}5&gt;6 Increase counter7&lt;/button&gt; useState的initialState也可以是一个用来生成状态初始值的函数，这种做法主要是避免组件每次渲染的时候initialState需要被重复计算。下面是个简单的例子： 1const [state, setState] = useState(() =&gt; {2 const initialState = someExpensiveComputation(props)3 return initialState4}) 注意事项setState是全量替代Function Component的setState和Class Component的this.setState函数的一个重要区别是this.setState函数是将当前设置的state浅归并（shallowly merge）到旧state的操作。而setState函数则是将新state直接替换旧的state（replace）。因此我们在编写Function Component的时候，就要合理划分state，避免将没有关系的状态放在一起管理，例如下面这个是不好的设计： 1const [state, setState] = useState({ left: 0, top: 0, width: 0, height: 0 }) 在上面代码中，由于我们将互不关联的DOM位置信息{left: 0, top: 0}和大小信息{width: 0, height: 0}绑定在同一个state，所以我们在更新任意一个状态的时候也要维护一下另外一个状态： 1const handleContainerResize = ({ width, height }) =&gt; {2 setState({...state, width, height})3}45const handleContainerMove = ({ left, top }) =&gt; {6 setState({...state, left, top})7} 这种写法十分不方便而且容易引发bug，更加合理的做法应该是将位置信息和大小信息放在两个不同的state里面，这样可以避免更新某个状态的时候要手动维护另一个状态： 1// separate state into position and size states2const [position, setPosition] = useState({ left: 0, top: 0 })3const [size, setSize] = useState({ width: 0, height: 0})45const handleContainerResize = ({ width, height }) =&gt; {6 setSize({width, height})7}89const handleContainerMove = ({ left, top }) =&gt; {10 setPosition({left, top})11} 如果你确实要将多个互不关联的状态放在一起的话，建议你使用useReducer来管理你的状态，这样你的代码会更好维护。 设置相同的state值时setState会bailing out of update如果setState接收到的新的state和当前的state是一样的（判断方法是Object.is），React将不会重新渲染子组件或者触发side effect。这里要注意的是虽然React不会渲染子组件，不过它还是会重新渲染当前的组件的，如果你的组件渲染有些很耗性能的计算的话，可以考虑使用useMemo来优化性能。 setState没有回调函数无论是useState还是Class Component的this.setState都是异步调用的，也就是说每次组件调用完它们之后都不能拿到最新的state值。为了解决这个问题，Class Component的this.setState允许你通过一个回调函数来获取到最新的state值，用法如下： 1this.setState(newState, state =&gt; {2 console.log(\"I get new state\", state)3}) 而Function Component的setState函数不存在这么一个可以拿到最新state的回调函数，不过我们可以使用useEffect来实现相同的效果，具体可以参见StackOverflow的这个讨论。 useEffect作用useEffect是用来使Function Component也可以进行副作用的。那么什么是副作用呢？我们可以先来看看维基百科的定义： In computer science, an operation, function or expression is said to have a side effect if it modifies some state variable value(s) outside its local environment, that is to say has an observable effect besides returning a value (the main effect) to the invoker of the operation. 通俗来说，函数的副作用就是函数除了返回值外对外界环境造成的其它影响。举个例子，假如我们每次执行一个函数，该函数都会操作全局的一个变量，那么对全局变量的操作就是这个函数的副作用。而在React的世界里，我们的副作用大体可以分为两类，一类是调用浏览器的API，例如使用addEventListener来添加事件监听函数等，另外一类是发起获取服务器数据的请求，例如当用户卡片挂载的时候去异步获取用户的信息等。在Hook出来之前，如果我们需要在组件中进行副作用的话就需要将组件写成Class Component，然后在组件的生命周期函数里面写副作用，这其实会引起很多代码设计上的问题，具体大家可以查看我的上篇文章React为什么需要Hook。Hook出来之后，开发者就可以在Function Component中使用useEffect来定义副作用了。虽然useEffect基本可以覆盖componentDidMount， componentDidUpdate，componentWillUnmount等生命周期函数组合起来使用的所有场景，但是useEffect和生命周期函数的设计理念还是存在本质上的区别的，如果一味用生命周期函数的思考方式去理解和使用useEffect的话，可能会引发一些奇怪的问题，大家有兴趣的话，可以看看React核心开发Dan写的这篇文章：A Complete Guide to useEffect，里面阐述了使用useEffect的一个比较正确的思考方式（mental model）。 用法1useEffect(effect, dependencies?) useEffect的第一个参数effect是要执行的副作用函数，它可以是任意的用户自定义函数，用户可以在这个函数里面操作一些浏览器的API或者和外部环境进行交互，这个函数会在每次组件渲染完成之后被调用，例如下面是一个简单的例子： 1import React, { useState, useEffect } from 'react'2import ReactDOM from 'react-dom'34const UserDetail = ({ userId }) =&gt; {5 const [userDetail, setUserDetail] = useState({})67 useEffect(() =&gt; {8 fetch(`https://myapi/users/${userId}`)9 .then(response =&gt; response.json())10 .then(user =&gt; setUserDetail(userDetail))11 })1213 return (14 &lt;div&gt;15 &lt;div&gt;User Name: {userDetail.name}&lt;/div&gt;16 &lt;/div&gt;17 )18}1920ReactDOM.render(&lt;UserDetail /&gt;, document.getElementById('root')) 上面定义的获取用户详情信息的副作用会在UserDetail组件每次完成渲染后执行，所以当该组件第一次挂载的时候就会向服务器发起获取用户详情信息的请求然后更新userDetail的值，这里的第一次挂载我们可以类比成Class Component的componentDidMount。可是如果试着运行一下上面的代码的话，你会发现代码进入了死循环：组件会不断向服务端发起请求。出现这个死循环的原因是useEffect里面调用了setUserDetail，这个函数会更新userDetail的值，从而使组件重渲染，而重渲染后useEffect的effect继续被执行，进而组件再次重渲染。。。为了避免重复的副作用执行，useEffect允许我们通过第二个参数dependencies来限制该副作用什么时候被执行：指明了dependencies的副作用，只有在dependencies数组里面的元素的值发生变化时才会被执行，因此如果要避免上面的代码进入死循环我们就要将userId指定为我们定义的副作用的dependencies： 1import React, { useState, useEffect } from 'react'2import ReactDOM from 'react-dom'34const UserDetail = ({ userId }) =&gt; {5 const [userDetail, setUserDetail] = useState({})67 useEffect(() =&gt; {8 fetch(`https://myapi/users/${userId}`)9 .then(response =&gt; response.json())10 .then(user =&gt; setUserDetail(userDetail))11 }, [userId])1213 return (14 &lt;div&gt;15 &lt;div&gt;User Name: ${userDetail.name}&lt;/div&gt;16 &lt;/div&gt;17 )18}1920ReactDOM.render(&lt;UserDetail /&gt;, document.getElementById('root')) 除了发起服务端的请求外，我们往往还需要在useEffect里面调用浏览器的API，例如使用addEventListener来添加浏览器事件的监听函数等。我们一旦使用了addEventListener就必须在合适的时候调用removeEventListener来移除对事件的监听，否则会有性能问题，useEffect允许我们在副作用函数里面返回一个cleanup函数，这个函数会在组件重新渲染之前被执行，我们可以在这个返回的函数里面移除对事件的监听，下面是一个具体的例子： 1import React, { useEffect } from 'react'2import ReactDOM from 'react-dom'34const WindowScrollListener = () =&gt; {5 useEffect(() =&gt; {6 const handleWindowScroll = () =&gt; console.log('yean, window is scrolling!')7 window.addEventListener('scroll', handleWindowScroll)89 // this is clean up function10 return () =&gt; {11 window.removeEventListener(handleWindowScroll)12 }13 }, [])1415 return (16 &lt;div&gt;17 I can listen to the window scroll event!18 &lt;/div&gt;19 )20}2122ReactDOM.render(&lt;WindowScrollListener /&gt;, document.getElementById('root')) 上面的代码中我们会在WindowScrollListener组件首次渲染完成后注册一个监听页面滚动事件的函数，并在组件下一次渲染前移除该监听函数。由于我们指定了一个空数组作为这个副作用的dependencies，所以这个副作用只会在组件首次渲染时被执行一次，而它的cleanup函数只会在组件unmount时才被执行，这就避免了频繁注册页面监听函数从而影响页面的性能。 注意事项避免使用“旧的”变量我们在实际使用useEffect的过程中可能遇到最多的问题就是我们的effect函数被调用的时候，拿到的某些state, props或者是变量不是最新的变量而是之前旧的变量。出现这个问题的原因是：我们定义的副作用其实就是一个函数，而JS的作用域是词法作用域，所以函数使用到的变量值是它被定义时就确定的，用最简单的话来说就是，useEffect的effect会记住它被定义时的外部变量的值，所以它被调用时使用到的值可能不是最新的值。解决这个问题的办法有两种，一种是将那些你希望每次effect被调用时拿到的都是最新值的变量保存在一个ref里面，并且在每次组件渲染的时候更新该ref的值： 1const [someState, setSomeState] = useState()2const someStateRef = useRef()34someStateRef.current = someState56useEffect(() =&gt; {7 ...8 const latestSomeState = someStateRef.current9 console.log(latestSomeState)10}, [otherDependencies...]) 这种做法虽然不是很优雅，不过可以解决我们的问题，如果你没有了解过useRef用法的话，可以查看本篇文章useRef这部分内容。解决这个问题的另外一个做法是将副作用使用到的所有变量都加到effect的dependencies中去，这也是比较推荐的做法。在实际开发中我们可以使用facebook自家的eslint-plugin-react-hooks的exhaustive-deps规则来进行编码约束，在你的项目加上这个约束之后，在代码开发阶段eslint就会告诉你要将someState放到useEffect的dependencies中去，这样就可以不使用useRef来存储someState的值了，例如下面代码： 1const [someState, setSomeState] = useState()23useEffect(() =&gt; {4 ...5 console.log(someState)6}, [otherDependencies..., someState]) useRef作用useRef是用来在组件不同渲染之间共用一些数据的，它的作用和我们在Class Component里面为this赋值是一样的。 用法1const refObject = useRef(initialValue) useRef接收initialValue作为初始值，它的返回值是一个ref对象，这个对象的.current属性就是该数据的最新值。使用useRef的一个最简单的情况就是在Function Component里面存储对DOM对象的引用，例如下面这个例子： 1import { useRef, useEffect } from 'react'2import ReactDOM from 'react-dom'34const AutoFocusInput = () =&gt; {5 const inputRef = useRef(null)67 useEffect(() =&gt; {8 // auto focus when component mount9 inputRef.current.focus()10 }, [])1112 return (13 &lt;input ref={inputRef} type='text' /&gt;14 )15}1617ReactDOM.render(&lt;AutoFocusInput /&gt;, document.getElementById('root')) 在上面代码中inputRef其实就是一个{current: inputDomInstance}对象，只不过它可以保证在组件每次渲染的时候拿到的都是同一个对象。 注意事项更新ref对象不会触发组件重渲染useRef返回的ref object被重新赋值的时候不会引起组件的重渲染，如果你有这个需求的话请使用useState来存储数据。 useCallback作用随着Hook的出现，开发者开始越来越多地使用Function Component来开发需求。当开发者在定义Function Component的时候往往需要在函数体内定义一些内嵌函数（inline function），这些内嵌函数会在组件每次重新渲染的时候被重新定义，如果它们作为props传递给了子组件的话，即使其它props的值没有发生变化，它都会使子组件重新渲染，而无用的组件重渲染可能会产生一些性能问题。每次重新生成新的内嵌函数还有另外一个问题就是当我们把内嵌函数作为dependency传进useEffect的dependencies数组的话，因为该函数频繁被重新生成，所以useEffect里面的effect就会频繁被调用。为了解决上述问题，React允许我们使用useCallback来记住（memoize）当前定义的函数，并在下次组件渲染的时候返回之前定义的函数而不是使用新定义的函数。 用法1const memoizedCallback = useCallback(callback, dependencies) useCallback接收两个参数，第一个参数是需要被记住的函数，第二个参数是这个函数的dependencies，只有dependencies数组里面的元素的值发生变化时useCallback才会返回新定义的函数，否则useCallback都会返回之前定义的函数。下面是一个简单的使用useCallback来优化子组件频繁被渲染的例子： 1import React, { useCallback } from 'react'2import useSearch from 'hooks/useSearch'3import ReactDOM from 'react-dom'45// this list may contain thousands of items, so each re-render is expensive6const HugeList = ({ items, onClick }) =&gt; {7 return (8 &lt;div&gt;9 {10 items.map((item, index) =&gt; (11 &lt;div12 key={index}13 onClick={() =&gt; onClick(index)}14 &gt;15 {item}16 &lt;/div&gt;17 ))18 }19 &lt;/div&gt;20 )21}2223const MemoizedHugeList = React.memo(HugeList)2425const SearchApp = ({ searchText }) =&gt; {26 const handleClick = useCallback(item =&gt; {27 console.log('You clicked', item)28 }, [])29 const items = useSearch(searchText)3031 return (32 &lt;MemoizedHugeList33 items={items}34 onClick={handleClick}35 /&gt;36 )37}3839ReactDOM.render(&lt;SearchApp /&gt;, document.getElementById('root')) 上面的例子中我定义了一个HugeList组件，由于这个组件需要渲染一个大的列表（items），所以每次重渲染都是十分消耗性能的，因此我使用了React.memo函数来让该组件只有在onClick函数和items数组发生变化的时候才被渲染，如果大家对React.memo不是很熟悉的话，可以看看我写的这篇文章。接着我在SearchApp里面使用MemoizedHugeList，由于要避免该组件的重复渲染，所以我使用了useCallback来记住定义的handleClick函数，这样在组件后面渲染的时候，handleClick变量指向的都是同一个函数，所以MemorizedHugeList只有在items发生变化时才会重新渲染。这里要注意的是由于我的handleClick函数没有使用到任何的外部依赖所以它的dependencies才是个空数组，如果你的函数有使用到外面的依赖的话，记得一定要将该依赖放进useCallback的dependencies参数中，不然会有bug发生。 注意事项避免在函数里面使用“旧的”变量和useEffect类似，我们也需要将所有在useCallback的callback中使用到的外部变量写到dependencies数组里面，不然我们可能会在callback调用的时候使用到“旧的”外部变量的值。 不是所有函数都要使用useCallback Performance optimizations are not free. They ALWAYS come with a cost but do NOT always come with a benefit to offset that cost. 任何优化都会有代价，useCallback也是一样的。当我们在Function Component里面调用useCallback函数的时候，React背后要做一系列计算才能保证当dependencies不发生变化的时候，我们拿到的是同一个函数，因此如果我们滥用useCallback的话，并不会带来想象中的性能优化，反而会影响到我们的性能，例如下面这个例子就是一个不好的使用useCallback的例子： 1import React, { useCallback } from 'react'2import ReactDOM from 'react-dom'34const DummyButton = () =&gt; {5 const handleClick = useCallback(() =&gt; {6 console.log('button is clicked')7 }, [])89 return (10 &lt;button onClick={handleClick}&gt;11 I'm super dummy12 &lt;/button&gt;13 )14}1516ReactDOM.render(&lt;DummyButton /&gt;, document.getElementById('root')) 上面例子使用的useCallback没有起到任何优化代码性能的作用，因为上面的代码执行起来其实相当于下面的代码： 1import React, { useCallback } from 'react'2import ReactDOM from 'react-dom'34const DummyButton = () =&gt; {5 const inlineClick = () =&gt; {6 console.log('button is clicked')7 }8 const handleClick = useCallback(inlineClick, [])910 return (11 &lt;button onClick={handleClick}&gt;12 I'm super dummy13 &lt;/button&gt;14 )15}1617ReactDOM.render(&lt;DummyButton /&gt;, document.getElementById('root')) 从上面的代码我们可以看出，即使我们使用了useCallback函数，浏览器在执行DummyButton这个函数的时候还是需要创建一个新的内嵌函数inlineClick，这和不使用useCallback的效果是一样的，而且除此之外，优化后的代码由于还调用了useCallback函数，所以它消耗的计算资源其实比没有优化之前还多，而且由于useCallback函数内部存储了一些额外的变量（例如之前的dependencies）所以它消耗的内存资源也会更多。因此我们并不能一味地将所有的内嵌函数使用useCallback来包裹，只对那些真正需要被记住的函数使用useCallback。 useMemo作用useMemo和useCallback的作用十分类似，只不过它允许你记住任何类型的变量（不只是函数）。 用法1const memoizedValue = useMemo(() =&gt; valueNeededToBeMemoized, dependencies) useMemo接收一个函数，该函数的返回值就是需要被记住的变量，当useMemo的第二个参数dependencies数组里面的元素的值没有发生变化的时候，memoizedValue使用的就是上一次的值。下面是一个例子： 1import React, { useMemo } from 'react'2import ReactDOM from 'react-dom'34const RenderPrimes = ({ iterations, multiplier }) =&gt; {5 const primes = React.useMemo(() =&gt; calculatePrimes(iterations, multiplier), [6 iterations,7 multiplier8 ])910 return (11 &lt;div&gt;12 Primes! {primes}13 &lt;/div&gt;14 )15}1617ReactDOM.render(&lt;RenderPrimes /&gt;, document.getElementById('root')) 上面的例子中calculatePrimes是用来计算素数的，因此每次调用它都需要消耗大量的计算资源。为了提高组件渲染的性能，我们可以使用useMemo来记住计算的结果，当iterations和multiplier保持不变的时候，我们就不需要重新执行calculatePrimes函数来重新计算了，直接使用上一次的结果即可。 注意事项不是所有的变量要包裹在useMemo里面和useCallback类似，我们只将那些确实有需要被记住的变量使用useMemo来封装，切记不能滥用useMemo，例如下面就是一个滥用useMemo的例子： 1import React, { useMemo } from 'react'2import ReactDOM from 'react-dom'34const DummyDisplay = () =&gt; {5 const items = useMemo(() =&gt; ['1', '2', '3'], [])6 7 return (8 &lt;&gt;9 {10 items.map(item =&gt; &lt;div key={item}&gt;{item}&lt;/div&gt;)11 }12 &lt;/&gt;13 )14}1516ReactDOM.render(&lt;DummyDisplay /&gt;, document.getElementById('root')) 上面的例子中直接将items定义在组件外面会更好： 1import React from 'react'2import ReactDOM from 'react-dom'34const items = ['1', '2', '3']56const DummyDisplay = () =&gt; { 7 return (8 &lt;&gt;9 {10 items.map(item =&gt; &lt;div key={item}&gt;{item}&lt;/div&gt;)11 }12 &lt;/&gt;13 )14}1516ReactDOM.render(&lt;DummyDisplay /&gt;, document.getElementById('root')) useContext作用我们知道React中组件之间传递参数的方式是props，假如我们在父级组件中定义了某些状态，而这些状态需要在该组件深层次嵌套的子组件中被使用的话就需要将这些状态以props的形式层层传递，这就造成了props drilling的问题。为了解决这个问题，React允许我们使用Context来在父级组件和底下任意层次的子组件之间传递状态。在Function Component中我们可以使用useContext Hook来使用context。 用法1const value = useContext(MyContext) useContext接收一个context对象为参数，该context对象是由React.createContext函数生成的。useContext的返回值是当前context的值，这个值是由最邻近的&lt;MyContext.Provider&gt;来决定的。一旦在某个组件里面使用了useContext这就相当于该组件订阅了这个context的变化，当最近的&lt;MyContext.Provider&gt;的context值发生变化时，使用到该context的子组件就会被触发重渲染，且它们会拿到context的最新值。下面是一个具体的例子： 1import React, { useContext, useState } from 'react'2import ReactDOM from 'react-dom'34// define context5const NumberContext = React.createContext()67const NumberDisplay = () =&gt; {8 const [currentNumber, setCurrentNumber] = useContext(NumberContext)910 const handleCurrentNumberChange = () =&gt; {11 setCurrentNumber(Math.floor(Math.random() * 100))12 }1314 return (15 &lt;&gt;16 &lt;div&gt;Current number is: {currentNumber}&lt;/div&gt;17 &lt;button onClick={handleCurrentNumberChange}&gt;Change current number&lt;/button&gt;18 &lt;/&gt;19 )20}2122const ParentComponent = () =&gt; {23 const [currentNumber, setCurrentNumber] = useState({})2425 return (26 &lt;NumberContext.Provider value={[currentNumber, setCurrentNumber]}&gt;27 &lt;NumberDisplay /&gt;28 &lt;/NumberContext.Provider&gt;29 )30}3132ReactDOM.render(&lt;ParentComponent /&gt;, document.getElementById('root')) 注意事项避免无用渲染我们在上面已经提到如果一个Function Component使用了useContext(SomeContext)的话它就订阅了这个SomeContext的变化，这样当SomeContext.Provider的value发生变化的时候，这个组件就会被重新渲染。这里有一个问题就是，我们可能会把很多不同的数据放在同一个context里面，而不同的子组件可能只关心这个context的某一部分数据，当context里面的任意值发生变化的时候，无论这些组件用不用到这些数据它们都会被重新渲染，这可能会造成一些性能问题。下面是一个简单的例子： 1import React, { useContext, useState } from 'react'2import ExpensiveTree from 'somewhere/ExpensiveTree'3import ReactDOM from 'react-dom'45const AppContext = React.createContext()67const ChildrenComponent = () =&gt; {8 const [appContext] = useContext(AppContext)9 const theme = appContext.theme1011 return (12 &lt;div&gt;13 &lt;ExpensiveTree theme={theme} /&gt;14 &lt;/div&gt;15 )16}1718const App = () =&gt; {19 const [appContext, setAppContext] = useState({ theme: { color: 'red' }, configuration: { showTips: false }})2021 return (22 &lt;AppContext.Provider value={[appContext, setAppContext]}&gt;23 &lt;ChildrenComponent /&gt;24 &lt;/AppContext.Provider&gt;25 )26}2728ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) 在上面的例子中，ChildrenComponent只使用到了appContext的.theme属性，可是当appContext其它属性例如configuration被更新时，ChildrenComponent也会被重新渲染，而ChildrenComponent调用了一个十分耗费性能的ExpensiveTree组件，所以这些无用的渲染会影响到我们页面的性能，解决上面这个问题的方法有下面三种： 拆分Context这个方法是最被推荐的做法，和useState一样，我们可以将不需要同时改变的context拆分成不同的context，让它们的职责更加分明，这样子组件只会订阅那些它们需要订阅的context从而避免无用的重渲染。例如上面的代码可以改成这样： 1import React, { useContext, useState } from 'react'2import ExpensiveTree from 'somewhere/ExpensiveTree'3import ReactDOM from 'react-dom'45const ThemeContext = React.createContext()6const ConfigurationContext = React.createContext()78const ChildrenComponent = () =&gt; {9 const [themeContext] = useContext(ThemeContext)1011 return (12 &lt;div&gt;13 &lt;ExpensiveTree theme={themeContext} /&gt;14 &lt;/div&gt;15 )16}1718const App = () =&gt; {19 const [themeContext, setThemeContext] = useState({ color: 'red' })20 const [configurationContext, setConfigurationContext] = useState({ showTips: false })2122 return (23 &lt;ThemeContext.Provider value={[themeContext, setThemeContext]}&gt;24 &lt;ConfigurationContext.Provider value={[configurationContext, setConfigurationContext]}&gt;25 &lt;ChildrenComponent /&gt;26 &lt;/ConfigurationContext.Provider&gt;27 &lt;/ThemeContext.Provider&gt;28 )29}3031ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) 拆分你的组件，使用memo来优化消耗性能的组件如果出于某些原因你不能拆分context，你仍然可以通过将消耗性能的组件和父组件的其他部分分离开来，并且使用memo函数来优化消耗性能的组件。例如上面的代码可以改为： 1import React, { useContext, useState } from 'react'2import ExpensiveTree from 'somewhere/ExpensiveTree'3import ReactDOM from 'react-dom'45const AppContext = React.createContext()67const ExpensiveComponentWrapper = React.memo(({ theme }) =&gt; {8 return (9 &lt;ExpensiveTree theme={theme} /&gt;10 )11})1213const ChildrenComponent = () =&gt; {14 const [appContext] = useContext(AppContext)15 const theme = appContext.theme1617 return (18 &lt;div&gt;19 &lt;ExpensiveComponentWrapper theme={theme} /&gt;20 &lt;/div&gt;21 )22}2324const App = () =&gt; {25 const [appContext, setAppContext] = useState({ theme: { color: 'red' }, configuration: { showTips: false }})2627 return (28 &lt;AppContext.Provider value={[appContext, setAppContext]}&gt;29 &lt;ChildrenComponent /&gt;30 &lt;/AppContext.Provider&gt;31 )32}3334ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) 不拆分组件，也可以使用useMemo来优化当然我们也可以不拆分组件使用useMemo来将上面的代码进行优化，代码如下： 1import React, { useContext, useState, useMemo } from 'react'2import ExpensiveTree from 'somewhere/ExpensiveTree'3import ReactDOM from 'react-dom'45const AppContext = React.createContext()67const ChildrenComponent = () =&gt; {8 const [appContext] = useContext(AppContext)9 const theme = appContext.theme1011 return useMemo(() =&gt; (12 &lt;div&gt;13 &lt;ExpensiveTree theme={theme} /&gt;14 &lt;/div&gt;15 ),16 [theme]17 )18}1920const App = () =&gt; {21 const [appContext, setAppContext] = useState({ theme: { color: 'red' }, configuration: { showTips: false }})2223 return (24 &lt;AppContext.Provider value={[appContext, setAppContext]}&gt;25 &lt;ChildrenComponent /&gt;26 &lt;/AppContext.Provider&gt;27 )28}2930ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) useReducer作用useReducer用最简单的话来说就是允许我们在Function Component里面像使用redux一样通过reducer和action来管理我们组件状态的变换（state transition）。 用法1const [state, dispatch] = useReducer(reducer, initialArg, init?) useReducer和useState类似，都是用来管理组件状态的，只不过和useState的setState不一样的是，useReducer返回的dispatch函数是用来触发某些改变state的action而不是直接设置state的值，至于不同的action如何产生新的state的值则在reducer里面定义。useReducer接收的三个参数分别是： reducer: 这是一个函数，它的签名是(currentState, action) =&gt; newState，从它的函数签名可以看出它会接收当前的state和当前dispatch的action为参数，然后返回下一个state,也就是说它负责状态转换（state transition）的工作。 initialArg：如果调用者没有提供第三个init参数，这个参数代表的是这个reducer的初始状态，如果init参数有被指定的话，initialArg会被作为参数传进init函数来生成初始状态。 init: 这是一个用来生成初始状态的函数，它的函数签名是(initialArg) =&gt; initialState，从它的函数签名可以看出它会接收useReducer的第二个参数initialArg作为参数，并生成一个初始状态initialState。下面是useReducer的一个简单的例子：1import React, { useState, useReducer } from 'react'23let todoId = 145const reducer = (currentState, action) =&gt; {6 switch(action.type) {7 case 'add':8 return [...currentState, {id: todoId++, text: action.text}]9 case 'delete':10 return currentState.filter(({ id }) =&gt; action.id !== id)11 default:12 throw new Error('Unsupported action type')13 }14}1516const Todo = ({ id, text, onDelete }) =&gt; {17 return (18 &lt;div&gt;19 {text}20 &lt;button21 onClick={() =&gt; onDelete(id)}22 &gt;23 remove24 &lt;/button&gt;25 &lt;/div&gt;26 )27}2829const App = () =&gt; {30 const [todos, dispatch] = useReducer(reducer, [])31 const [text, setText] = useState('')3233 return (34 &lt;&gt;35 {36 todos.map(({ id, text }) =&gt; {37 return (38 &lt;Todo39 text={text}40 key={id}41 id={id}42 onDelete={id =&gt; {43 dispatch({ type: 'delete', id })44 }}45 /&gt;46 )47 })48 }49 &lt;input onChange={event =&gt; setText(event.target.value)} /&gt;50 &lt;button51 onClick={() =&gt; {52 dispatch({ type: 'add', text })53 setText('')54 }}55 &gt;56 add todo57 &lt;/button&gt;58 &lt;/&gt;59 )60}6162ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) 注意事项useReducer vs useStateuseReducer和useState都可以用来管理组件的状态，它们之间最大的区别就是，useReducer将状态和状态的变化统一管理在reducer函数里面，这样对于一些复杂的状态管理会十分方便我们debug，因为它对状态的改变是封闭的。而由于useState返回的setState可以直接在任意地方设置我们状态的值，当我们组件的状态转换逻辑十分复杂时，它将很难debug，因为它是开放的状态管理。总体的来说，在useReducer和useState如何进行选择的问题上我们可以参考以下这些原则： 下列情况使用useState state的值是JS原始数据类型（primitives），如number, string和boolean等 state的转换逻辑十分简单 组件内不同的状态是没有关联的，它们可以使用多个独立的useState来单独管理 下列情况使用useReducer state的值是object或者array state的转换逻辑十分复杂, 需要使用reducer函数来统一管理 组件内多个state互相关联，改变一个状态时也需要改变另外一个，将他们放在同一个state内使用reducer来统一管理 状态定义在父级组件，不过需要在深层次嵌套的子组件中使用和改变父组件的状态，可以同时使用useReducer和useContext两个hook，将dispatch方法放进context里面来避免组件的props drilling 如果你希望你的状态管理是可预测的（predictable）和可维护的（maintainable），请useReducer 如果你希望你的状态变化可以被测试，请使用useReducer自定义Hook上面介绍了React内置的常用Hook的用法，接着我们看一下如何编写我们自己的Hook。作用自定义Hook的目的是让我们封装一些可以在不同组件之间共用的非UI逻辑来提高我们开发业务代码的效率。什么是自定义Hook之前我们说过Hook其实就是一个函数，所以自定义Hook也是一个函数，只不过它在内部使用了React的内置Hook或者其它的自定义Hook。虽然我们可以任意命名我们的自定义Hook，可是为了另其它开发者更容易理解我们的代码以及方便一些开发工具例如eslint-plugin-react-hooks来给我们更好地提示，我们需要将我们的Hook以use作为开头，并且使用驼峰发进行命名，例如useLocation，useLocalStorage和useQueryString等等。例子下面举一个最简单的自定义hook的例子：1import React, { useState, useCallback } from 'react'2import ReactDOM from 'react-dom'34const useCounter = () =&gt; {5 const [counter, setCounter] = useState(0)6 7 const increase = useCallback(() =&gt; setCounter(counter =&gt; ++counter), [])8 const decrease = useCallback(() =&gt; setCounter(counter =&gt; --counter), [])910 return {11 counter,12 increase,13 decrease14 }15}1617const App = () =&gt; {18 const { counter, increase, decrease } = useCounter()1920 return (21 &lt;&gt;22 &lt;div&gt;Counter: {counter}&lt;/div&gt;23 &lt;button onClick={increase}&gt;increase&lt;/button&gt;24 &lt;button onClick={decrease}&gt;decrease&lt;/button&gt;25 &lt;/&gt;26 )27}2829ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) 总结在本篇文章中我给大家介绍了React一些常用的内置Hook以及如何定义我们自己的Hook。React Hook总的来说是一个十分强大的功能，合理地使用它可以提高我们代码的复用率和业务代码的开发效率，不过它也有很多隐藏的各式各样的坑，大家在使用中一定要多加防范，我的个人建议是大家尽量使用eslint-plugin-react-hooks插件来辅助开发，因为它真的可以在我们开发的过程中就帮我们发现代码存在的问题，不过有时候想方设法来去掉它的警告确实是很烦人的：）。 在这个系列的下一篇文章中我将教大家如何测试我们自定义的Hook来提高我们的代码质量，大家敬请期待。 参考文献 When to useMemo and useCallback Preventing rerenders with React.memo and useContext hook React Hook Reference useReducer vs useState in React 个人技术动态欢迎关注公众号进击的大葱一起学习成长","link":"/2020/07/15/React-Hook%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"前端开发技巧","slug":"前端开发技巧","link":"/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"},{"name":"ECMAScript","slug":"ECMAScript","link":"/tags/ECMAScript/"},{"name":"2019","slug":"2019","link":"/tags/2019/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Hook","slug":"Hook","link":"/tags/Hook/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"GraphQL","slug":"GraphQL","link":"/tags/GraphQL/"},{"name":"CSS-in-JS","slug":"CSS-in-JS","link":"/tags/CSS-in-JS/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"yarn","slug":"yarn","link":"/tags/yarn/"},{"name":"testing","slug":"testing","link":"/tags/testing/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"hook","slug":"hook","link":"/tags/hook/"},{"name":"Svelte","slug":"Svelte","link":"/tags/Svelte/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"}]}