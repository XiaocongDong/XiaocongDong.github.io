{"pages":[{"title":"about","text":"大家好，我是董小聪。我2016年毕业于北京邮电大学通信工程本科专业。大学前三年过得浑浑噩噩，直到大三才主动去学习编程。刚开始做的是网络虚拟化相关的工作，在思科中国实习的时候参与了OpenDaylight控制器的研发，用的是Java。后面大学毕业去了美国硅谷工作了一年，在那一年里做了很多大大小小的项目，写过NodeJS也玩过Python。后面却鬼使神差回国做了前端，现在正努力成为一个全面的全栈开发。 我个人觉得其实没有太大必要区分前端后端，我更看重的是Software Engineer这个称号。我个人认为软件工程师就是利用程序去实现和创造一些有价值的东西，程序员的核心价值并不是他掌握了多少语言，能够使用多少工具，而是他自己分析问题和解决问题的能力，或者说系统设计能力(System Design)。 我的梦想是通过自己的努力去改变别人，这就是改变世界。","link":"/about/index.html"}],"posts":[{"title":"JavaScript小技巧 - 数组篇","text":"本文整理了一些在日常工作可以用到的JavaScript数组小技巧 去重巧用Set特性 1const arr = [1, 2, 2, 3, 4, 7, 7]2const uniqueArr = [...new Set(arr)]3console.log(uniqueArr)4// [1, 2, 3, 4, 7] 某一个位置插入元素改变原数组 1const arr = [1, 2, 3, 5, 6, 7]2arr.splice(3, 0, 4)3console.log(arr)4// [1, 2, 3, 4, 5, 6, 7] 不改变原数组 1const arr = [1, 2, 4, 5]2const indexNeededToInsert = 23const newArr = [...arr.slice(0, indexNeededToInsert), 3, ...arr.slice(indexNeededToInsert)]45console.log(newArr)6// [1, 2, 3, 4, 5]7console.log(arr)8// [1, 2, 4, 5] 删除某一个位置的元素不改变原数组 1const arr = [1, 2, 3, 4, 5]2const indexToBeRemoved = 33const filteredArr = arr.filter((_, index) =&gt; index !== indexToBeRemoved)4console.log(filteredArr)5// [1, 2, 3, 5]6console.log(arr)7// [1, 2, 3, 4, 5] 改变原数组 1const arr = [1, 2, 3, 4, 5]2const indexToBeRemoved = 33arr.splice(indexToBeRemoved, 1)4console.log(arr)5// [1, 2, 3, 5] 获取数组最后一个元素改变原数组 1const arr = [1, 2, 3, 4, 5]2const lastElement = arr.pop()3console.log(lastElement)4// 55console.log(arr)6// [1, 2, 3, 4] 不改变原数组 1const arr = [1, 2, 3, 4, 5]2const lastElement = arr.slice(-1)[0]3console.log(lastElement)4// 55console.log(arr)6// [1, 2, 3, 4, 5] slice第一个参数如果是负数表示从后面开始数起的第几个元素，-1表示倒数第一个元素。 清空数组1const arr = [1, 2, 3, 4, 5]2arr.length = 03console.log(arr)4// []5console.log(arr[0])6// undefined 生成一定长度的数组1const newArr = new Array(10)2console.log(newArr)3// [ &lt;10 empty items&gt; ] 两个数组的交集1const arr1 = [1, 2, 3, 4]2const arr2 = [2, 3]3const intersectedArr = arr1.filter(item1 =&gt; arr2.includes(item1))4console.log(intersectedArr)5// [2, 3] 合并多个数组1const arr1 = [1, 2, 3]2const arr2 = [4, 5, 6]3const arr3 = [7, 8, 9]4const mergedArr = [...arr1, ...arr2, ...arr3]5console.log(mergedArr)6// [1, 2, 3, 4, 5, 6, 7, 8, 9] 移除数组的虚假(falsy)值1const mixedArr = [0, “blue”, “”, NaN, 9, true, undefined, “white”, false]2const trueArr = mixedArr.filter(Boolean);3console.log(trueArr)4// [“blue”, 9, true, “white”] 求和1const nums = [1, 2, 3, 4, 5]2const sum = nums.reduce((currSum, num) =&gt; currSum + num)3console.log(sum)4// 15","link":"/2019/12/11/JavaScript%E5%B0%8F%E6%8A%80%E5%B7%A7-%E6%95%B0%E7%BB%84%E7%AF%87/"},{"title":"几个提高效率的console APIs","text":"console.log我相信写过JavaScript人一定都有接触过，它可谓是我们debug的灵丹妙药。可是除了log方法，你知道console还有很多可以帮你快速提高代码debug效率（逼格）的方法吗？ console.log | console.info | console.debug | console.warn | console.error使用场景输出不同类型（level）的内容。 用法这几个方法用起来都差不多，只不过输出结果可能会存在颜色上的区别：注意console.debug如果没有输出可以将log level中的verbose选上（chrome）: 替换字符串 - string substitution使用场景呈现输出时的上下文信息（context）。 用法现在支持以下替换字符串： 替换字符串 描述 %o 或者 %O JavaScript 对象，可以是整数、字符串或是 JSON 数据。 %d或者%i 整数。 %s 字符串。 %f 浮点数。 为输出添加CSS样式使用场景让内容更加结构化而且可以极大地提高逼格。 用法使用%c为某部分的输出内容定义样式： console.assert使用场景条件性输出。有些信息你可能只想在某些条件不满足的时候才进行输出，这个时候你可以用这种方法而不是加多个if判断。 用法1console.assert(condition, ...data) 注意只有condition是false的时候data才会被输出： console.table使用情景以表格的形式输出数据。这个方法最适用的场景我觉得是对象的数组，因为他可以让你一目了然地看到数组内对象各个属性的值。 用法 console.group使用情景当你有大量的内容要输出到界面上时，可以使用console.group方法为输出的内容添加一定的缩进来更好地整理这些内容。 用法这里要记住的是每个group都需要手动地调用groupEnd来退出。 console.trace使用情景追踪函数的执行栈。当你想知道一个函数具体是怎样被调用的时，可以使用console.trace这个函数去追踪它的执行栈。 用法 console.count使用场景统计代码的执行次数。 用法你还可以使用label去区分不同的统计类型： console.time使用场景记录代码执行的耗时，以毫秒（ms）为单位。 用法1console.time(timerName) 参考网站 https://developer.mozilla.org/en-US/docs/Web/API/Console https://medium.com/javascript-in-plain-english/mastering-js-console-log-like-a-pro-1c634e6393f9","link":"/2019/12/23/%E5%87%A0%E4%B8%AA%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84consoleAPIs/"},{"title":"详解ECMAScript2019/ES10新属性","text":"每年都有一些新的属性进入ECMA262标准，今年发布的ECMAScript2019/ES10同样也有很多新的特性，本文将会挑选一些普通开发者会用到的新属性进行深入的解读。 Array.prototype.flat() The flat() method creates a new array with all sub-array elements concatenated into it recursively up to the specified depth. – MDN 简单来说flat这个函数就是按照一定的深度depth将一个深层次嵌套的数组拍扁, 例子: 1const nestedArr = [1, 2, [3, 4, [5, 6, [7, [8], 9]]], 10]2console.log(nestedArr.flat())3// [1, 2, 3, 4, [5, 6, [7, [8], 9]], 10]4console.log(nestedArr.flat(2))5// [1, 2, 3, 4, 5, 6, [7, [8], 9], 10]6console.log(nestedArr.flat(3))7// [1, 2, 3, 4, 5, 6, 7, [8], 9, 10]8console.log(nestedArr.flat(4))9// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]10console.log(nestedArr.flat(Infinity))11// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 由上面的例子可以看出flat会按照指定的深度depth将一个数组扁平化，如果需要将数组完全拍扁变成一维数组，则指定depth为无限大，即是Infinity，相反如果不指定深度，其默认值是1。 Array.prototype.flatMap() The flatMap() method first maps each element using a mapping function, then flattens the result into a new array. It is identical to a map() followed by a flat() of depth 1, but flatMap() is often quite useful, as merging both into one method is slightly more efficient. – MDN 简单来说flatMap等于一个数组先调用完map函数再调用flat函数将其扁平化，扁平化的深度固定为1，先通过一个简单的例子感受一下: 1const myArr = [1, 2, 3]2myArr3 .map(n =&gt; [n * n]) // [[1], [4], [9]]4 .flat() // [1, 4, 9]56// 用flatMap可以一步到位7myArr.flatMap(n =&gt; [n * n]) // [1, 4, 9] 从上面的例子来看flatMap如果只是将flat和map做了一个简单的组合好像可有可无，其实不然，flatMap有个强大的功能是可以在map的时候添加和删除元素，这个无论是map还是filter都没有这个功能。 要想删除某一个元素只需要在mapper函数里面返回一个空的数组[], 而增加元素只需在mapper函数里面返回一个长度大于1的数组，具体可以看下面的例子： 1// 假如我们想要删除掉原数组里面所有的负数，同时将单数转换为一个复数和12const a = [5, 4, -3, 20, 17, -33, -4, 18]3// |\\ \\ x | | \\ x x |4// [4,1, 4, 20, 16,1, 18]5a.flatMap(n =&gt;6 (n &lt; 0) ? []: // 删除负数7 (n % 2 == 0) ? [n] : // 保留复数8 [n - 1, 1] // 单数变为一个复数和19)10// [4, 1, 4, 20, 20, 16, 1, 18] Object.fromEntries() The Object.fromEntries() method transforms a list of key-value pairs into an object. – MDN fromEntries方法将一个iterable对象返回的一系列键值对(key-value pairs)转换为一个object。先看一个简单的例子理解一下: 1// key-value pairs数组2const entriesArr = [['k1', 1], ['k2', 2]]3console.log(Object.fromEntries(entriesArr)4// {k1: 1, k2: 2}56const entriesMap = new Map([7 ['k1', 1],8 ['k2', 2]9]) // {\"k1\" =&gt; 1, \"k2\" =&gt; 2}10console.log(Object.fromEntries(entriesMap))11// {k1: 1, k2: 2} 再来看一个自定义的iterable对象例子深入理解一下: 1const iteratorObj = {2 [Symbol.iterator]: function () {3 const entries = [['k1', 1], ['k2', 2]]4 let cursor = 056 return {7 next() {8 const done = entries.length === cursor9 10 return {11 value: done ? undefined : entries[cursor++],12 done13 }14 }15 }16 }17}18Object.fromEntries(iteratorObj) // {k1: 1, k2: 2} 这个方法有一个用途就是对object的key进行filter，举个例子: 1const studentMap = {2 student1: {grade: 80},3 student2: {grade: 50},4 student3: {grade: 100}5}6const goodStudentMap = Object.fromEntries(7 Object8 .entries(studentMap)9 .filter(([_, meta]) =&gt; meta.grade &gt;= 60)10)11console.log(goodStudentMap)12// {student1: {grade: 80}, student3: {grade: 100}} String.prototype.trimStart这个方法很简单，就是返回一个将原字符串开头的空格字符去掉的新的字符串，例子: 1const greeting = ' Hello world! '2console.log(greeting.trimStart())3// 'Hello world! ' 这个方法还有一个别名函数，叫做trimLeft，它们具有一样的功能。 String.prototype.trimEnd这个方法和trimStart类似，只不过是将原字符串结尾的空格字符去掉，例子: 1const greeting = ' Hello world! '2console.log(greeting.trimEnd())3// ' Hello world!' 这个方法也有一个别名函数，叫做trimRight, 它们也具有一样的功能。 Symbol.prototype.description The read-only description property is a string returning the optional description of Symbol objects. – MDN ECMAScript2019给Symbol对象添加了一个可选的description属性，这个属性是个只读属性，看看例子: 1console.log(Symbol('desc').description)2// desc3console.log(Symbol.for('desc').description)4// desc56// 一些内置的Symbol也有这个属性7console.log(Symbol.iterator.description)8// Symbol.iterator910// 如果初始化时没有带description，这个属性会返回一个undefined，因为这样才说这个属性是可选的11console.log(Symbol().description)12// undefined1314// 这个属性是只读的，不能被设置15Symbol.iterator.description = 'mess it'16console.log(Symbol.iterator.description)17// Symbol.iterator 这个新的属性只要是为了方便开发者调试，不能通过比较两个Symbol对象的description来确定这两个Symbol是不是同一个Symbol: 1var s1 = Symbol(\"desc\")2var s2 = Symbol(\"desc\")3console.log(s1.description === s2.description)4// true5console.log(s1 === s2)6// false try catch optional bindingECMAScript2019之后，你写try…catch时如果没必要时可以不用声明error： 1// ECMAScript2019之前，你一定要在catch里面声明error，否则会报错2try {3 ...4} catch (error) {56}7// 可是有时候，你确实用不到这个error对象，于是你会写这样的代码8try {9 ...10} catch (_) {11 ...12}1314// ECMAScript2019后，你可以直接这样写了15try {16 ...17} catch {18 ...19} 虽然这个新属性可以让你省略掉error，可是我觉得开发者应该避免使用这个属性，因为在我看来所有的错误都应该被处理，至少应该被console.error出来，否则可能会有一些潜在的bug，举个例子： 1let testJSONObj2try {3 testJSONObj = JSON.prase(testStr)4} catch {5 testJSONObj = {}6}7console.log(testJSONObj) 以上代码中无论testStr是不是一个合法的JSON字符串，testJSONObj永远都是一个空对象，因为JSON.parse函数名写错了，而你又忽略了错误处理，所以你永远不会知道这个typo。 稳定的排序 Array.prototype.sortECMAScript2019后Array.sort一定是个稳定的排序。什么是稳定排序？所谓的稳定排序就是：假如没排序之前有两个相同数值的元素a[i]和a[j]，而且i在j前面，即i &lt; j，经过排序后元素a[i]依然排在a[j]元素的前面，也就是说稳定的排序不会改变原来数组里面相同数值的元素的先后关系。看个例子： 1var users = [2 {name: 'Sean', rating: 14},3 {name: 'Ken', rating: 14},4 {name: 'Jeremy', rating: 13}5]6users.sort((a, b) =&gt; a.rating - b.rating)7// 非稳定的排序结果可能是8// [9// {name: 'Jeremy', rating: 13}, 10// {name: 'Ken', rating: 14}, 11// {name: 'Sean', rating: 14}12// ]13// 虽然Sean和Ken具有同样的rating，可是非稳定的排序不能保证他们两个的顺序在排序后保持不变1415// ECMAScript2019后，Array.sort将是一个稳定的排序，也就是说它可以保证Sean和Ken两个人的顺序在排序后不变16// [17// {name: 'Jeremy', rating: 13}, 18// {name: 'Sean', rating: 14}, 19// {name: 'Ken', rating: 14}20// ] 改进Function.prototype.toString()ECMAScript2019之前，调用function的toString方法会将方法体里面的空格字符省略掉，例如: 1function hello() {2 console.log('hello word')3}45console.log(hello.toString())6//'function hello() {\\nconsole.log('hello word')\\n}' ECMAScript2019之后，要求一定要返回函数源代码（保留空格字符）或者一个标准的占位符例如native code，所以ECMAScript2019之后，以上的输出会变为： 1console.log(hello.toString())2//\"function hello() {3// console.log('hello word')4//}\"","link":"/2019/12/05/ECMAScript2019-ES10%E6%96%B0%E5%B1%9E%E6%80%A7/"},{"title":"窥探现代浏览器架构(一)","text":"前言本文是笔者对Mario Kosaka写的inside look at modern web browser系列文章的翻译。这里的翻译不是指直译，而是结合个人的理解将作者想表达的意思表达出来，而且会尽量补充一些相关的内容来帮助大家更好地理解。 CPU，GPU，内存和多进程架构在这个4集系列教程里面，我将会从Chrome浏览器的高层次架构（high-level architecture）开始说起，一直深入讲到页面渲染流水线（rendering pipeline）的具体细节。如果你想知道浏览器是怎么把你编写的代码转变成一个可用的网站，或者你不知道为什么一些特定的代码写法可以提高网站的性能的，那你就来对地方了，这篇文章就是为你准备的。 作为本系列文章的第一篇，我们会先了解一些关键的计算机术语以及Chrome浏览器的多进程架构。 计算机的核心 - CPU和GPU要想理解浏览器的运行环境，我们先要搞明白一些计算机组件以及它们的作用。 CPU首先我们要说的是计算机的大脑 - CPU（Central Processing Unit）。CPU是计算机里面的一块芯片，上面有一个或者多个核心（core）。我们可以把CPU的一个核心（core）比喻成一个办公室工人，他功能强大，上知天文下知地理，琴棋书画无所不能，它可以串行地一件接着一件处理交给它的任务。很久之前的时候大多数CPU只有一个核心，不过在现在的硬件设备上CPU通常会有多个核心，因为多核心CPU可以大大提高手机和电脑的运算能力。 四个CPU核心愉快地在各自工位上一个接着一个地处理交给它们的任务 GPU图形处理器 - 或者说GPU（Graphics Processing Unit）是计算机的另外一个重要组成部分。和功能强大的CPU核心不一样的是，单个GPU核心只能处理一些简单的任务，不过它胜在数量多，单片GPU上会有很多很多的核心可以同时工作，也就是说它的并行计算能力是非常强的。图形处理器（GPU）顾名思义一开始就是专门用来处理图形的，所以在说到图形使用GPU（using）或者GPU支持（backed）时，人们就会联想到图形快速渲染或者流畅的用户体验相关的概念。最近几年来，随着GPU加速概念的流行，在GPU上单独进行的计算也变得越来越多了。 每个GPU核心手里只有一个扳手，这就说明它的能力是非常有限的，可是它们人多啊！ 当你在手机或者电脑上打开某个应用程序的时候，背后其实是CPU和GPU支撑着这个应用程序的运行。通常来说，你的应用要通过操作系统提供的一些机制才能跑在CPU和GPU上面。 计算机的三层架构，最下层是硬件机器，操作系统夹在中间，最上层是运行的应用 在进程和线程上执行程序在深入到浏览器的架构之前我们还得了解一下进程（process）和线程（thread）的相关概念。进程可以看成正在被执行的应用程序（executing program）。而线程是跑在进程里面的，一个进程里面可能有一个或者多个线程，这些线程可以执行任何一部分应用程序的代码。 进程就像一个大鱼缸，而线程就是浴缸里面畅游的鱼儿 当你启动一个应用程序的时候，操作系统会为这个程序创建一个进程同时还为这个进程分配一片私有的内存空间，这片空间会被用来存储所有程序相关的数据和状态。当你关闭这个程序的时候，这个程序对应的进程也会随之消失，进程对应的内存空间也会被操作系统释放掉。 进程使用系统分配的内存空间去存储应用的数据 有时候为了满足功能的需要，创建的进程会叫系统创建另外一些进程去处理其它任务，不过新建的进程会拥有全新的独立的内存空间而不是和原来的进程共用内存空间。如果这些进程需要通信，它们要通过IPC机制（Inter Process Communication）来进行。很多应用程序都会采取这种多进程的方式来工作，因为进程和进程之间是互相独立的它们互不影响，换句话来书，如果其中一个工作进程（worker process）挂掉了其他进程不会受到影响，而且挂掉的进程还可以重启。 不同的进程通过IPC来通信 浏览器架构那么浏览器是怎么使用进程和线程来工作的呢？其实大概可以分为两种架构，一种是单进程架构，也就是只启动一个进程，这个进程里面有多个线程工作。第二种是多进程架构，浏览器会启动多个进程，每个进程里面有多个线程，不同进程通过IPC进行通信。 单进程和多进程浏览器的架构图 上面的图表架构其实包含了浏览器架构的具体实现了，在现实中其实并没有一个大家都遵循的浏览器实现标准，所以不同浏览器的实现方式可能会完全不一样。 为了更好地在本系列文章中展开论述，我们主要讨论最新的Chrome浏览器架构，它采用的是多进程架构，以下是架构图： Chrome的多进程架构图，多个渲染进程的卡片（render process）是用来表明Chrome会为每一个tab创建一个渲染进程。 Chrome浏览器会有一个浏览器进程（browser process），这个进程会和其他进程一起协作来实现浏览器的功能。对于渲染进程（renderer process），Chrome会尽可能为每一个tab甚至是页面里面的每一个iframe都分配一个单独的进程。 各个进程如何分工合作呢？以下是各个进程具体负责的工作内容： 进程 负责的工作 Browser 负责浏览器的“Chrome”部分， 包括导航栏，书签， 前进和后退按钮。同时这个进程还会控制那些我们看不见的部分，包括网络请求的发送以及文件的读写。 Renderer 负责tab内和网页展示相关的所有工作。 Plugin 控制网页使用的所有插件，例如flash插件。 GPU 负责独立于其它进程的GPU任务。它之所以被独立为一个进程是因为它要处理来自于不同tab的渲染请求并把它在同一个界面上画出来。 不同的进程负责浏览器不同部分的界面内容 除了上面列出来的进程，Chrome还有很多其他进程在工作，例如扩展进程（Extension Process）和工具进程（utility process）。如果你想看一下你的Chrome浏览器现在有多少个进程在跑可以点击浏览器右上角的更多按钮，选择更多工具和任务管理器：在弹出的窗口里面你会看到正在工作的进程列表，以及每个进程使用的CPU和内存状况。 Chrome多进程架构的好处那么为什么Chrome会采取多进程架构工作呢？ 其中一个好处是多进程可以使浏览器具有很好的容错性。对于大多数简单的情景来说，Chrome会为每个tab单独分配一个属于它们的渲染进程（render process）。举个例子，假如你有三个tab，你就会有三个独立的渲染进程。当其中一个tab的崩溃时，你可以随时关闭这个tab并且其他tab不受到影响。可是如果所有的tab都跑在同一个进程的话，它们就会有连带关系，一个挂全部挂。 不同的tab会有不同的渲染进程来负责 Chrome采用多进程架构的另外一个好处就是可以提供安全性和沙盒性（sanboxing）。因为操作系统可以提供方法让你限制每个进程拥有的能力，所以浏览器可以让某些进程不具备某些特定的功能。例如，由于tab渲染进程可能会处理来自用户的随机输入，所以Chrome限制了它们对系统文件随机读写的能力。 不过多进程架构也有它不好的地方，那就是进程的内存消耗。由于每个进程都有各自独立的内存空间，所以它们不能像存在于同一个进程的线程那样共用内存空间，这就造成了一些基础的架构（例如V8 JavaScript引擎）会在不同进程的内存空间同时存在的问题，这些重复的内容会消耗更多的内存。所以为了节省内存，Chrome会限制被启动的进程数目，当进程数达到一定的界限后，Chrome会将访问同一个网站的tab都放在一个进程里面跑。 节省更多的内存 - Chrome的服务化同样的优化方法也可以被使用在浏览器进程（browser process）上面。Chrome浏览器的架构正在发生一些改变，目的是将和浏览器本身（Chrome）相关的部分拆分为一个个不同的服务，服务化之后，这些功能既可以放在不同的进程里面运行也可以合并为一个单独的进程运行。 这样做的主要原因是让Chrome在不同性能的硬件上有不同的表现。当Chrome运行在一些性能比较好的硬件时，浏览器进程相关的服务会被放在不同的进程运行以提高系统的稳定性。相反如果硬件性能不好，这些服务就会被放在同一个进程里面执行来减少内存的占用。其实在这次架构变化之前，Chrome在Android上面已经开始采取类似的做法了。 Chrome将浏览器相关的服务放在同一个进程里面运行和放在不同的进程运行的区别 单帧渲染进程 - 网站隔离（Site Isolation）网站隔离（Site Isolation）是最近Chrome浏览器启动的功能，这个功能会为网站内不同站点的iframe分配一个独立的渲染进程。之前说过Chrome会为每个tab分配一个单独的渲染进程，可是如果一个tab只有一个进程的话不同站点的iframe都会跑在这个进程里面，这也意味着它们会共享内存，这就有可能会破坏同源策略。同源策略是浏览器最核心的安全模型，它可以禁止网站在未经同意的情况下去获取另外一个站点的数据，因此绕过同源策略是很多安全攻击的主要目的。而进程隔离（proces isolation）是隔离网站最好最有效的办法了。再加上CPU存在Meltdown和Spectre的隐患，网站隔离变得势在必行。因此在Chrome 67版本之后，桌面版的Chrome会默认开启网站隔离功能，这样每一个跨站点的iframe都会拥有一个独立的渲染进程。 网站隔离功能会让跨站的iframe拥有独立的进程 网站隔离技术汇聚了我们工程师好几年的研发努力，它其实远远没有想象中那样只是为不同站点的iframe分配一个独立的渲染进程那么简单，因为它从根本上改变了各个iframe之间的通信方式。网站隔离后，对于有iframe的网站，当用户打开右边的devtool时，Chrome浏览器其实要做很多幕后工作才能让开发者感觉不出这和之前的有什么区别，这其实是很难实现的。对于一些很简单的功能，例如在devtool里面用Ctrl + F键在页面搜索某个关键词，Chrome都要遍历多个渲染进程去完成。所以我们的浏览器工程师在网站隔离这个功能发布后都感叹这是一个里程碑式的成就。 总结在本篇文章中，我们探讨了浏览器高层次的架构设计以及多进程架构的带来的好处。同时我们还讨论了服务化和网站隔离这些和浏览器多进程架构息息相关的技术。在下一篇文章中我们要开始深入了解这些进程和线程是如何呈现我们的网站页面的了。","link":"/2019/12/25/%E7%AA%A5%E6%8E%A2%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84-%E4%B8%80/"},{"title":"Svelte 3 初学者完全指南","text":"React, Vue和Angular差不多占据了Web开发的大部分江山，可是最近半年Svelte开始逐渐吸引越来越多人的眼球。这个Svelte框架到底有什么过人之处呢？本文将会为大家分析一下Svelte火起来的原因，并且通过使用Svelte去搭建一个简单的书店应用（bookshop）来帮助大家快速入门这门框架。 Svelte为什么会火?要想知道Svelte为什么会火，首先得看看React和Vue这些框架存在什么问题。 big runtime - 大的运行时React和Vue都是基于runtime的框架。所谓基于runtime的框架就是框架本身的代码也会被打包到最终的bundle.js并被发送到用户浏览器。当用户在你的页面进行各种操作改变组件的状态时，框架的runtime会根据新的组件状态（state）计算（diff）出哪些DOM节点需要被更新，从而更新视图。那么这些runtime代码到底有多大呢，可以看一些社区的统计数据: Name Size Ember 2.2.0 435K Ember 1.13.8 486K Angular 2 566K Angular 2 + Rx 766K Angular 1.4.5 143K Vue 2.4.2 58.8K Inferno 1.2.2 48K Preact 7.2.0 16K React 0.14.5 + React DOM 133K React 0.14.5 + React DOM + Redux 139K React 16.2.0 + React DOM 97.5K 从上面的表格可以看出常用的框架中，最小的Vue都有58k，React更有97.5k。换句话说如果你使用了React作为开发的框架，即使你的业务代码很简单，你的首屏bundle size都要100k起步。当然100k不算很大，可是事物都是相对的，相对于大型的管理系统来说100k肯定不算什么，可是对于那些首屏加载时间敏感的应用（例如淘宝，京东主页），100k的bundle size在一些网络环境不好的情况或者手机端真的会影响用户体验。那么如何减少框架的runtime代码大小呢？要想减少runtime代码的最有效的方法就是压根不用runtime。其实回想一下Web开发的历史，很早之前在用Jquery和Bootstrap一把梭的时候，我们的代码不就是不包含runtime的吗？当数据变化时直接通过JavaScript去改变原生DOM节点，没有框架那一系列diff和调度（React Fiber）的过程。这时你可能会问，要减少bundle size真的要回到那个刀耕火种的时代吗？有没有那种既可以让我用接近React和Vue的语法编写代码，同时又不包含框架runtime的办法。这恰恰就是Svelte要做的东西，它采用了Compiler-as-framework的理念，将框架的概念放在编译时而不是运行时。你编写的应用代码在用诸如Webpack和Rollup等工具打包的时候会被直接转换为JavaScript对DOM节点的原生操作，从而让bundle.js不包含框架的runtime。那么Svelte到底可以将bundle size减少多少呢？以下是RealWorld这个项目的统计：由上面的图表可以看出实现相同功能的应用，Svelte的bundle size大小是Vue的1/4，是React的1/20！单纯从这个数据来看，Svelte这个框架对bundle size的优化真的很大。 低效的Virtual DOM Diff什么？Virtual DOM不是一直都很高效的吗？其实Virtual DOM高效是一个误解。说Virtual DOM高效的一个理由就是它不会直接操作原生的DOM节点，因为这个很消耗性能。当组件状态变化时它会通过某些diff算法去计算出本次数据更新真实的视图变化，然后只改变“需要改变”的DOM节点。用过React的人可能都会体会到React并没有想象中那么高效，框架有时候会做很多无用功，这体现在很多组件会被“无缘无故”进行重渲染（re-render）。注意这里说的re-render和对原生DOM进行操作是两码事！所谓的re-render是你定义的class Component的render方法被重新执行，或者你的组件函数被重新执行。组件被重渲染是因为Vitual DOM的高效是建立在diff算法上的，而要有diff一定要将组件重渲染才能知道组件的新状态和旧状态有没有发生改变，从而才能计算出哪些DOM需要被更新。你可能会说React Fiber不是出来了吗，这个应该不是问题了吧？其实Fiber这个架构解决的问题是不让组件的重渲染和reconcile的过程阻塞主线程的执行，组件重渲染的问题依然存在，而且据反馈，React Hooks出来后组件的重渲染更加频繁了。正是因为框架本身很难避免无用的渲染，React才允许你使用一些诸如shouldComponentUpdate，PureComponent和useMemo的API去告诉框架哪些组件不需要被重渲染，可是这也就引入了很多模板代码（boilerplate）。如果大家想了解更多关于Virtual DOM存在的问题，可以看一下virtual dom is pure overhead这篇文章。 那么如何解决Vitual DOM算法低效的问题呢？最有效的解决方案就是不用Virtual DOM！其实作为一个框架要解决的问题是当数据发生改变的时候相应的DOM节点会被更新（reactive），Virtual DOM需要比较新老组件的状态才能达到这个目的，而更加高效的办法其实是数据变化的时候直接更新对应的DOM节点： 1if (changed.name) {2 text.data = name;3} 这就是Svelte采用的办法。Svelte会在代码编译的时候将每一个状态的改变转换为对应DOM节点的操作，从而在组件状态变化的时候快速高效地对DOM节点进行更新。根据js framework benchmark的统计，Svelte在对一些大列表操作的时候性能比React和Vue都要好。 什么是Svelte?Svelte是由RollupJs的作者Rich Harris编写的编译型框架，没了解过RollupJs的同学可以去它官网了解一下，它其实是一个类似于Webpack的打包工具。Svelte这个框架具有以下特点： 和React，Vue等现代Web框架的用法很相似，它可以允许开发者快速开发出具有流畅用户体验的Web应用。 不使用Virtual DOM，也不是一个runtime的库。 基于Compiler as framework的理念，会在编译的时候将你的应用转换为原生的DOM操作。 默认就支持类似于CSS modules的CSS scope功能，让你避免CSS样式冲突的困扰。 原生支持CSS animation。 极其容易的组件状态管理（state management），减少开发者的模板代码编写（boilerplate less）。 支持反应式定义（Reactive statement）。 极其容易的应用全局状态管理，框架本身自带全局状态，类似于React的Redux和Vue的Vuex。 支持context，避免组件的props drilling。 Svelte这个框架与Vue和React之间最大的区别是它除了管理组件的状态和追踪他们的渲染，还有很多其他有用的功能。例如它原生支持CSS scope和CSS animation。如果你用React或者Vue是需要引入第三方库来实现同样的功能的，而第三方依赖的引入会给开发者增加学习和维护的成本。 用Svelte搭建一个Bookshop应用接下来我们会从头开始搭建一个基于Svelte框架的简单书店应用bookshop，通过这个demo，希望大家可以理解Svelte的一些基本概念和掌握它的一些基本用法并能够使用Svelte去搭建更加复杂的应用。 应用功能Bookshop应用支持以下功能： 管理员录入新图书 展示书店图书列表 将图书加到购物车 展示购物车的数据信息 对学习者的技术要求 掌握html，css和javascript的基础用法 有过React或者Vue的相关开发经验最佳 项目的源代码可以在我的github仓库找到。 项目搭建首先在我们的本地开发环境新建一个项目文件夹： 1mkdir svelte-bookshop 接着用svelte官方的脚手架去初始化我们的应用： 1npx degit sveltejs/template svelte-bookshop2cd svelte-bookshop34yarn5yarn dev degit这个命令会将github上面的项目文件直接拷贝到某个本地文件夹，这里使用到的svelte/tempalte模板项目的github地址是这个。以上命令成功运行后，访问http://localhost:5000你会看到如下界面：界面很简单就是展示一个hello world，接着让我们看一下生成的项目目录结构：生成的代码主要包含以下文件目录结构： rollup.config.js，这个是rollup的配置文件，类似于webpack.config.js，里面指定了项目的入口文件是src/main.js。 src文件夹，这个文件夹用来存储我们的项目源代码，现在只有一个项目的主入口文件main.js和一个组件文件App.svelte。 public文件夹，这个文件夹是用来存储项目的静态文件（index.html, global.css和favicon.png）和rollup编译生成的静态文件（build文件夹底下的bundle.js和bundle.css以及它们各自的source map）。 接着让我们具体看一下src文件夹底下的各个文件内容 src/App.svelte1&lt;script&gt;2 export let name;3&lt;/script&gt;45&lt;main&gt;6 &lt;h1&gt;Hello {name}!&lt;/h1&gt;7 &lt;p&gt;Visit the &lt;a href=\"https://svelte.dev/tutorial\"&gt;Svelte tutorial&lt;/a&gt; to learn how to build Svelte apps.&lt;/p&gt;8&lt;/main&gt;910&lt;style&gt;11 main {12 text-align: center;13 padding: 1em;14 max-width: 240px;15 margin: 0 auto;16 }1718 h1 {19 color: #ff3e00;20 text-transform: uppercase;21 font-size: 4em;22 font-weight: 100;23 }2425 @media (min-width: 640px) {26 main {27 max-width: none;28 }29 }30&lt;/style&gt; 这个文件定义了一个叫做App的Svelte组件，这里要注意App.svelte文件内并没有定义组件的名称，组件的名称是由它的文件名确定的。Svelte组件的文件名都是以.svelte结尾的，一个组件文件通常会包含以下三部分内容： &lt;script&gt;标签，和组件相关的任何JavaScript代码都可以放在这里，例如组件的状态定义或者一些异步Ajax请求。在这个App.svelte文件里面没有定义局部的组件状态，而是定义并export了一个name变量。对于Svelte框架，export一个变量就是将这个变量指定为当前组件的一个外部参数 - props。这种做法和React里面的将props作为组件的第一个参数的区别很大，可能大家一开始有点不习惯，不过后面习惯了，你可能也会爱上这种写法的。 &lt;style&gt;标签，和组件相关的CSS代码会放在这里。注意这里的CSS是局部生效的（scope），也就是说App.svelte中的h1标签的样式只会对App组件内的h1标签生效，而对项目其他的包括这个组件的子节点的h1标签失效。具体可以用浏览器的调试工具看一下h1标签的实际样式就明白了: 由上图可以看出Svelte在生成代码的时候会用一些随机的哈希值将组件的样式和其它组件的样式区别开来。 组件的HTML标签。组件的HTML标签可以直接在文件中写出来，例如App组件的HTML部分是：1&lt;main&gt;2 &lt;h1&gt;Hello {name}!&lt;/h1&gt;3 &lt;p&gt;Visit the &lt;a href=\"https://svelte.dev/tutorial\"&gt;Svelte tutorial&lt;/a&gt; to learn how to build Svelte apps.&lt;/p&gt;4&lt;/main&gt; App组件最外层是一个main标签，main标签里面有一个h1标签和p标签，其中h1标签里面是一个Hello字符串加一个用花括号包裹的插入字符串（interpolation），在React JSX里面的写法应该是Hello ${name}，它们都表示这个位置的字符串就是name这个变量的内容。至于这个name变量就是我们在上面用export定义的外部参数。 总的来说Svelte会将所有和组件相关的JavaScript，CSS和HTML代码都放在同一个文件里面，这个做法有点像Vue，不过和Vue相比它的模板代码更少。 src/main.js1import App from './App.svelte';23const app = new App({4 target: document.body,5 props: {6 name: 'world'7 }8});910export default app; 这个文件内容很简单，就是将刚刚定义的App组件挂载到目标节点body上，而且为App组件提供了值为world的name参数。这段代码的作用和React中的ReactDOM.render函数一样。 接着让我们看一下生成的静态代码是什么样子的。 public/build/bundle.js先看生成的JavaScript主文件bundle.js，由于原文件比较大，我只截取了其中比较关键的一部分： 1/* src/App.svelte generated by Svelte v3.16.4 */23const file = \"src/App.svelte\";45function create_fragment(ctx) {6 let main;7 let h1;8 let t0;9 let t1;10 let t2;11 let t3;12 let p;13 let t4;14 let a;15 let t6;1617 const block = {18 c: function create() {19 main = element(\"main\");20 h1 = element(\"h1\");21 t0 = text(\"Hello \");22 t1 = text(/*name*/ ctx[0]);23 t2 = text(\"!\");24 t3 = space();25 p = element(\"p\");26 t4 = text(\"Visit the \");27 a = element(\"a\");28 a.textContent = \"Svelte tutorial\";29 t6 = text(\" to learn how to build Svelte apps.\");30 attr_dev(h1, \"class\", \"svelte-1tky8bj\");31 add_location(h1, file, 5, 1, 46);32 attr_dev(a, \"href\", \"https://svelte.dev/tutorial\");33 add_location(a, file, 6, 14, 83);34 add_location(p, file, 6, 1, 70);35 attr_dev(main, \"class\", \"svelte-1tky8bj\");36 add_location(main, file, 4, 0, 38);37 },38 l: function claim(nodes) {39 throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");40 },41 m: function mount(target, anchor) {42 insert_dev(target, main, anchor);43 append_dev(main, h1);44 append_dev(h1, t0);45 append_dev(h1, t1);46 append_dev(h1, t2);47 append_dev(main, t3);48 append_dev(main, p);49 append_dev(p, t4);50 append_dev(p, a);51 append_dev(p, t6);52 },53 p: function update(ctx, dirty) {54 if (dirty[0] &amp; /*name*/ 1) set_data_dev(t1, /*name*/ ctx[0]);55 },56 i: noop,57 o: noop,58 d: function destroy(detaching) {59 if (detaching) detach_dev(main);60 }61 };6263 dispatch_dev(\"SvelteRegisterBlock\", {64 block,65 id: create_fragment.name,66 type: \"component\",67 source: \"\",68 ctx69 });7071 return block;72} 这段代码对应的就是我们刚刚定义的App组件，create_fragment方法会接受一个上下文对象ctx参数并返回一个代表组件的block对象。 block这个对象主要包含以下四个重要的方法c（create），m（mount），p（update）和d（destroy）。 c（create）1function create() {2 main = element(\"main\");3 h1 = element(\"h1\");4 t0 = text(\"Hello \");5 t1 = text(/*name*/ ctx[0]);6 t2 = text(\"!\");7 t3 = space();8 p = element(\"p\");9 t4 = text(\"Visit the \");10 a = element(\"a\");11 a.textContent = \"Svelte tutorial\";12 t6 = text(\" to learn how to build Svelte apps.\");13 attr_dev(h1, \"class\", \"svelte-1tky8bj\");14 add_location(h1, file, 5, 1, 46);15 attr_dev(a, \"href\", \"https://svelte.dev/tutorial\");16 add_location(a, file, 6, 14, 83);17 add_location(p, file, 6, 1, 70);18 attr_dev(main, \"class\", \"svelte-1tky8bj\");19 add_location(main, file, 4, 0, 38);20} 这个函数的功能是生成（create）和App组件相关的一些原生DOM节点，并为它们添加一些元数据（meta data）。 m（mount）1function mount(target, anchor) {2 insert_dev(target, main, anchor);3 append_dev(main, h1);4 append_dev(h1, t0);5 append_dev(h1, t1);6 append_dev(h1, t2);7 append_dev(main, t3);8 append_dev(main, p);9 append_dev(p, t4);10 append_dev(p, a);11 append_dev(p, t6);12} 这个函数的功能是挂载c函数生成的那些DOM节点。 p（update）1function update(ctx, dirty) {2 if (dirty[0] &amp; /*name*/ 1) set_data_dev(t1, /*name*/ ctx[0]);3} p函数会在ctx上下文更新的时候去更新对应DOM节点的属性。大概就是当上下文变化的时候，检查一下name这个变量有没有变化，如果发生变化则更新DOM节点。 d（destroy）1function destroy(detaching) {2 if (detaching) detach_dev(main);3} d函数是用来删除App组件的。 看完Svelte生成的代码后，我想你对我在文章开头说的Compiler-as-framework等概念应该有了更加深刻的认识，Svelte和React（Vue也类似）不一样的是，React应用在打包完之后，还保留了如React.createElement，setState等框架函数的调用代码，而Svelte编译完之后，框架代码会被转化为操作原生DOM节点的代码。 大概了解了项目的组织结构后，让我们开始正式搭建书店bookshop应用。 组件定义HTML markup首先让我们创建一个展示书本具体信息的卡片组件，在src文件夹底下新建一个BookCard.svelte文件，里面定义一下卡片组件的HTML markup： 1// src/BookCard.svelte2&lt;div&gt;3 &lt;h1&gt;title&lt;/h1&gt;4 &lt;div&gt;price&lt;/div&gt;5 &lt;div&gt;description&lt;/div&gt;6 &lt;button&gt;添加到购物车&lt;/button&gt;7&lt;/div&gt; 然后在App.svelte组件里面使用BookCard组件: 1// src/App.svelte2&lt;script&gt;3 import BookCard from \"./BookCard.svelte\";4&lt;/script&gt;56&lt;style&gt;7 ...8&lt;/style&gt;910&lt;main&gt;11 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;12 &lt;section&gt;13 &lt;BookCard /&gt;14 &lt;/section&gt;15&lt;/main&gt; 使用自定义的组件的方法很简单：先在script标签里面导入新定义的组件BookCard，然后将该组件写在App组件的HTML markup里面，语法和JSX一样的。这时候再查看页面的内容： CSSBookCard组件虽然出来了，我们得定义一些CSS让它变得更好看一点： 1// src/BookCard.svelte2&lt;style&gt;3 .card {4 text-align: left;5 border-radius: 5px;6 box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);7 padding: 10px;8 }910 h1 {11 font-size: 20px;12 }1314 h2 {15 font-size: 15px;16 color: #999;17 }1819 button {20 background-color: #ff3e00;21 color: white;22 border-radius: 5px;23 cursor: pointer;24 border: none;25 }26&lt;/style&gt;2728&lt;div class=\"card\"&gt;29 &lt;h1&gt;title&lt;/h1&gt;30 &lt;h2&gt;price&lt;/h2&gt;31 &lt;p&gt;description&lt;/p&gt;32 &lt;button&gt;添加到购物车&lt;/button&gt;33&lt;/div&gt; 给组件定义样式的方法就是新建一个style标签然后把该组件相关的样式写在这个标签内，注意这里的样式只会对组件内的元素有效，不会影响到其他组件的样式的。加完样式后，界面应该会变成这个样子： props定义书本的具体信息应该是由传入的props指定的。Svelte组件的props要用export来指明，指明的props变量可以直接被组件使用： 1// src/BookCard.svelte2&lt;script&gt;3 export let title;4 export let price;5 export let description;6&lt;/script&gt;78&lt;style&gt;9...10&lt;/style&gt;1112&lt;div class=\"card\"&gt;13 &lt;h1&gt;title&lt;/h1&gt;14 &lt;h2&gt;price&lt;/h2&gt;15 &lt;p&gt;description&lt;/p&gt;16 &lt;button&gt;添加到购物车&lt;/button&gt;17&lt;/div&gt; 变量使用定义和引入的变量可以在组件的HTML markup中直接使用，具体用法是在Markup中用花括号（curly braces）引用该变量，具体代码时： 1// src/BookCard.svelte2&lt;script&gt;3 export let title;4 export let price;5 export let description;6&lt;/script&gt;78&lt;style&gt;9...10&lt;/style&gt;1112&lt;div class=\"card\"&gt;13 &lt;h1&gt;{title}&lt;/h1&gt;14 &lt;h2&gt;${price}&lt;/h2&gt;15 &lt;p&gt;{description}&lt;/p&gt;16 &lt;button&gt;添加到购物车&lt;/button&gt;17&lt;/div&gt; 组件参数传递然后在父级组件App中，将BookCard需要的参数传给该组件： 1// src/App.svelte2&lt;script&gt;3 ...4 let title = \"JavaScript高级编程\";5 let price = 99.0;6 let description = \"一起来学习JavaScript啊\";7&lt;/script&gt;89&lt;style&gt;10 ...11&lt;/style&gt;1213&lt;main&gt;14 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;15 &lt;section&gt;16 &lt;BookCard title={title} price={price} description={description} /&gt;17 &lt;/section&gt;18&lt;/main&gt; 这时候书本卡片的内容应该是传入的参数了：对于组件参数传递，Svelte还提供了以下更加方便的写法： 1// src/App.svelte2&lt;main&gt;3 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;4 &lt;section&gt;5 &lt;BookCard {title} {price} {description} /&gt;6 &lt;/section&gt;7&lt;/main&gt; 录入书本信息作为一个书店，管理员应该可以录入新的图书，所以我们给App组件添加一个简单的表单来让用户录入数据： 1// src/App.svelte2&lt;script&gt;3 ...4&lt;/script&gt;56&lt;style&gt;7 ....8&lt;/style&gt;910&lt;main&gt;11 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;12 &lt;section&gt;13 &lt;h2&gt;Add new book&lt;/h2&gt;14 &lt;label for=\"title\"&gt;Title&lt;/label&gt;15 &lt;input type=\"text\" id=\"title\" value={title} /&gt;16 &lt;label for=\"price\"&gt;Price&lt;/label&gt;17 &lt;input type=\"number\" id=\"price\" value={price} /&gt;18 &lt;label for=\"description\"&gt;Description&lt;/label&gt;19 &lt;textarea rows=\"3\" id=\"description\" value={description} /&gt;20 &lt;/section&gt;21 &lt;section&gt;22 &lt;BookCard {title} {price} {description} /&gt;23 &lt;/section&gt;24&lt;/main&gt; 我们为App组件新建了一些input标签，并指定这些input标签的值为我们之前定义的变量，这时候我们试着改变输入框的内容：虽然输入框的初始值是变量对应的值，可是变量的值并不会随着输入框的值的改变而改变，也就是它们的值没有”绑定起来“，要想实现双向数据绑定，我们可以给输入框添加一个监听事件。 事件绑定我们可以使用on关键字加事件名称给DOM添加事件监听器，以下代码将会监听input输入框的input事件： 1&lt;script&gt;2 ...3 let title = \"JavaScript高级编程\";4 ...56 function handleTitleChange(event) {7 title = event.target.value;8 }9&lt;/script&gt;1011&lt;style&gt;12 ...13&lt;/style&gt;1415&lt;main&gt;16 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;17 &lt;section&gt;18 &lt;h2&gt;Add new book&lt;/h2&gt;19 &lt;label for=\"title\"&gt;Title&lt;/label&gt;20 &lt;input type=\"text\" id=\"title\" value={title} on:input={handleTitleChange} /&gt;21 ...22 &lt;/section&gt;23&lt;/main&gt; 这时候我们再改变input的值，会发现卡片里面的内容也发生了改变，说明我们成功改变了title变量的值： 自动数据双向绑定可是如果每一个input标签都要手动添加一个事件监听的话我们的代码会有很多模板代码，为了解决这个问题，Svelte允许我们直接用bind关键字加要绑定的属性进行双向数据绑定： 1// src/App.svelte2&lt;script&gt;3 ...4 let title = \"JavaScript高级编程\";5 let price = 99.0;6 let description = \"一起来学习JavaScript啊\";7&lt;/script&gt;89&lt;style&gt;10 ...11&lt;/style&gt;1213&lt;main&gt;14 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;15 &lt;section&gt;16 &lt;h2&gt;Add new book&lt;/h2&gt;17 &lt;label for=\"title\"&gt;Title&lt;/label&gt;18 &lt;input type=\"text\" id=\"title\" bind:value={title} /&gt;19 &lt;label for=\"price\"&gt;Price&lt;/label&gt;20 &lt;input type=\"number\" id=\"price\" bind:value={price} /&gt;21 &lt;label for=\"description\"&gt;Description&lt;/label&gt;22 &lt;textarea rows=\"3\" id=\"description\" bind:value={description} /&gt;23 &lt;/section&gt;24 ...25&lt;/main&gt; 这时候我们就可以把各个变量的初始值去掉： 1// src/App.svelte2&lt;script&gt;3 let title = \"\";4 let price = 0;5 let description = \"\";6&lt;/script&gt; 这时候我们页面的输入框和所有变量都”绑定“起来了： 展示书本列表我们的书店应该不止一本书，要用一个数组把所有的书本存起来： 1// src/App.svelte2&lt;script&gt;3 ...4 let books = [];5 ...6&lt;/script&gt; 接着我们再为刚刚新增的表单添加一个提交按钮，用户填完书本的信息后点击提交会新建一个book对象，新建的book对象会被加到books列表中去： 1&lt;script&gt;2 ...3 let books = [];45 function handleAddBook() {6 books = books.concat({ title, price, description });7 title = \"\";8 price = 0;9 description = \"\";10 }11 ...12&lt;/script&gt;1314&lt;style&gt;15 ...16 button {17 background-color: #ff3e00;18 color: white;19 border-radius: 5px;20 cursor: pointer;21 border: none;22 }23 ...24&lt;/style&gt;2526&lt;main&gt;27 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;28 &lt;section&gt;29 &lt;h2&gt;Add new book&lt;/h2&gt;30 &lt;label for=\"title\"&gt;Title&lt;/label&gt;31 &lt;input type=\"text\" id=\"title\" bind:value={title} /&gt;32 &lt;label for=\"price\"&gt;Price&lt;/label&gt;33 &lt;input type=\"number\" id=\"price\" bind:value={price} /&gt;34 &lt;label for=\"description\"&gt;Description&lt;/label&gt;35 &lt;textarea rows=\"3\" id=\"description\" bind:value={description} /&gt;36 &lt;div&gt;37 &lt;button on:click={handleAddBook}&gt;add book&lt;/button&gt;38 &lt;/div&gt;39 &lt;/section&gt;40 ...41&lt;/main&gt; 展示列表数据我们可以使用each语法块去展示books列表的数据： 1// src/App.svelte2&lt;script&gt;3 ....45 let books = [];67 function handleAddBook() {8 books = books.concat({ title, price, description });9 title = \"\";10 price = 0;11 description = \"\";12 }13&lt;/script&gt;1415&lt;main&gt;16 ...17 &lt;section&gt;18 {#each books as book}19 &lt;BookCard20 title={book.title}21 price={book.price}22 description={book.description} /&gt;23 {/each}24 &lt;/section&gt;25&lt;/main&gt; 你也可以直接在each块定义的时候解构出被递归对象里面的内容，上面的代码变为： 1// src/App.svelte2 ...3 &lt;section&gt;4 {#each books as { title, price, description }}5 &lt;BookCard {title} {price} {description} /&gt;6 {/each}7 &lt;/section&gt;8 ... 代码更改完后，你的页面就可以录入新书并展示书的列表了： 购物车功能首先我们要为BookCard这个组件的按钮添加一个点击事件：用户点击书本卡片按钮的时候这本书会被加到购物车中。要实现这个效果我们可以为BookCard按钮定义一个handleAddBook的参数，这个参数由外面组件来提供，handleAddBook函数会在用户点击BookCard按钮的时候被调用并将该书添加购物车中。代码如下： 1// src/BookCard.svelte2&lt;script&gt;3 ...4 export let handleAddToCart;5&lt;/script&gt;67&lt;style&gt;8 ...9&lt;/style&gt;1011&lt;div class=\"card\"&gt;12 &lt;h1&gt;{title}&lt;/h1&gt;13 &lt;h2&gt;${price}&lt;/h2&gt;14 &lt;p&gt;{description}&lt;/p&gt;15 &lt;button on:click={() =&gt; handleAddToCart(title)}&gt;添加到购物车&lt;/button&gt;16&lt;/div&gt; 1// src/App.svelte2&lt;script&gt;3 ...4 let booksInCart = [];56 function handleAddToCart(title) {7 let bookNeededToBeAdded = books.find(book =&gt; book.title == title);8 booksInCart = booksInCart.concat(bookNeededToBeAdded);9 }10&lt;/script&gt;1112&lt;style&gt;13 ...14&lt;/style&gt;1516&lt;main&gt;17 ...18 &lt;section&gt;19 &lt;h2&gt;购物车&lt;/h2&gt;20 {#each booksInCart as { title, price }}21 &lt;div&gt;名称: {title}, 价钱: {price}&lt;/div&gt;22 {/each}23 &lt;/section&gt;24 &lt;section&gt;25 &lt;h2&gt;书单&lt;/h2&gt;26 {#each books as { title, price, description }}27 &lt;BookCard {title} {price} {description} {handleAddToCart} /&gt;28 {/each}29 &lt;/section&gt;30&lt;/main&gt; 这时候我们就可以看到我们的购物车了： 条件判断Svelte可以用if语法块根据不同条件展示不同的内容，我们可以在购物车为空的时候给用户展示一个空的状态： 1// src/App.svelte2...3&lt;section&gt;4 &lt;h2&gt;购物车&lt;/h2&gt;5 {#if booksInCart.length === 0}6 &lt;p&gt;购物车空的哦~&lt;/p&gt;7 {:else}8 {#each booksInCart as { title, price }}9 &lt;div&gt;名称: {title}, 价钱: {price}&lt;/div&gt;10 {/each}11 {/if}12&lt;/section&gt;13... 这时候界面变为： 展示购物车统计信息我们再为书店添加一个帮用户统计购物车的书本的功能，可以展示现在购物车里面的书本总数和总金额，代码如下: 1// src/App.svelte2&lt;script&gt;3 ...4 let booksInCart = [];56 let booksNumInCart = booksInCart.length;7 let totalCheckoutPrice = booksInCart.reduce(8 (sum, book) =&gt; sum + book.price,9 010 );11 ...12&lt;/script&gt;1314...15&lt;section&gt;16 &lt;h2&gt;购物车&lt;/h2&gt;17 &lt;div&gt;书本总数：{booksNumInCart}&lt;/div&gt;18 &lt;div&gt;订单金额：{totalCheckoutPrice}&lt;/div&gt;19 ...20&lt;/section&gt;21... 这时候我们操作界面却发现购物车的数据变化时统计数据竟然没有变化：数据没有变化的原因是我们每次添加书本到购物车的时候没有手动地去改变booksNumInCart和totalCheckoutPrice的值。不过如果需要在购物车数据发生变化的时候手动维护统计数据的话，代码会变得很丑陋。 反应式定义对于这种情况，Svelte提供了反应式定义（Reactive assignment）的方法来表示这种联动的数据，具体做法就是用$符号定义变量而不是let，以下是代码： 1&lt;script&gt;2 ...3 let booksInCart = [];45 $: booksNumInCart = booksInCart.length;6 $: totalCheckoutPrice = booksInCart.reduce(7 (sum, book) =&gt; sum + book.price,8 09 );10 ...11&lt;/script&gt; 这样当booksInCart这个数据发生改变的时候，booksNumInCart和totalCheckoutPrice这个两个变量就会自动被重新计算。这时候我们再对界面进行操作的话，会发现统计数据会随着购物车的数据变化而自动发生改变： 总结我们的简易书店系统（bookshop）大概就实现了这些功能，现在来总结一下在开发项目的时候覆盖到的Svelte框架基础知识： 组件定义 - component definition 变量使用 - using variables props定义和参数传递 - props definition and passing 事件监听 - event listening 数据绑定 - data binding 条件判断 - if condition 列表数据展示 - each block 其实Svelte框架还有很多我没有提到的有用的功能特性，例如： 事件传递 - event forwarding 生命周期函数 - life-cycle functions 全局状态管理 - stores 上下文管理 - context CSS 动画 - css animation … 由于文章篇幅的限制我在这里没有覆盖Svelte所有的属性，大家兴趣可以看一下svelte的官方教程。 我个人对Svelte框架的一些看法个人觉得由于Virtual DOM的各种问题，Compiler as framework这个思路应该是前端框架发展的一个趋势。Svelte目前实现的功能虽然已经非常不错了，可是就目前来说我觉得它还有以下问题： Scalability - 可扩展性。React和Vue等框架自带的runtime虽然会增加首屏加载的bundle.js，可是当项目变得越来越大的时候，框架的runtime在bundle.js里面占据的比例也会越来越小，相反由于Svelte生成的代码的封装性没有React和Vue的好，它在大型项目中会不会堆积很多重复的代码呢？这个时候我们就得考虑一下是不是存在一个Svelte生成的代码大于React和Vue生成的代码的阈值了。这个问题现在还没有具体的答案，只能等后人实践的时候给出答案了，大家有兴趣可以看一下作者在github上面的讨论。 Ecosystem - 生态。作为一个最近才火起来的框架，Svelte的生态还远远不及已经普及那么多年的React和Vue，这也是我觉得就目前来说Svelte还撼动不了React和Vue的地位的原因。不过Svelte会不会因为它的先进性而迎来生态大爆发呢？我们可以拭目以待。 不过有一点可以肯定的是，Svelte由于在一些不复杂的项目中生成的代码远远比React，Vue和Angular小的优势会在一些性能不那么好的嵌入式操作系统中大放异彩。 学习Svelte有用的链接 作者的Rethinking reactivity演讲 Svelte官网 Svelte github仓库","link":"/2019/12/17/Svelte-3-%E5%88%9D%E5%AD%A6%E8%80%85%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"前端开发技巧","slug":"前端开发技巧","link":"/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"ECMAScript","slug":"ECMAScript","link":"/tags/ECMAScript/"},{"name":"2019","slug":"2019","link":"/tags/2019/"},{"name":"Svelte","slug":"Svelte","link":"/tags/Svelte/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}