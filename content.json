{"pages":[{"title":"about","text":"大家好，我是董小聪。我2016年毕业于北京邮电大学通信工程本科专业。大学前三年过得浑浑噩噩，直到大三才主动去学习编程。刚开始做的是网络虚拟化相关的工作，在思科中国实习的时候参与了OpenDaylight控制器的研发，用的是Java。后面大学毕业去了美国硅谷工作了一年，在那一年里做了很多大大小小的项目，写过NodeJS也玩过Python。后面却鬼使神差回国做了前端，现在正努力成为一个全面的全栈开发。 我个人觉得其实没有太大必要区分前端后端，我更看重的是Software Engineer这个称号。我个人认为软件工程师就是利用程序去实现和创造一些有价值的东西，程序员的核心价值并不是他掌握了多少语言，能够使用多少工具，而是他自己分析问题和解决问题的能力，或者说系统设计能力(System Design)。 我的梦想是通过自己的努力去改变别人，这就是改变世界。","link":"/about/index.html"}],"posts":[{"title":"JavaScript小技巧 - 数组篇","text":"本文整理了一些在日常工作可以用到的JavaScript数组小技巧 去重巧用Set特性 1const arr = [1, 2, 2, 3, 4, 7, 7]2const uniqueArr = [...new Set(arr)]3console.log(uniqueArr)4// [1, 2, 3, 4, 7] 某一个位置插入元素改变原数组 1const arr = [1, 2, 3, 5, 6, 7]2arr.splice(3, 0, 4)3console.log(arr)4// [1, 2, 3, 4, 5, 6, 7] 不改变原数组 1const arr = [1, 2, 4, 5]2const indexNeededToInsert = 23const newArr = [...arr.slice(0, indexNeededToInsert), 3, ...arr.slice(indexNeededToInsert)]45console.log(newArr)6// [1, 2, 3, 4, 5]7console.log(arr)8// [1, 2, 4, 5] 删除某一个位置的元素不改变原数组 1const arr = [1, 2, 3, 4, 5]2const indexToBeRemoved = 33const filteredArr = arr.filter((_, index) =&gt; index !== indexToBeRemoved)4console.log(filteredArr)5// [1, 2, 3, 5]6console.log(arr)7// [1, 2, 3, 4, 5] 改变原数组 1const arr = [1, 2, 3, 4, 5]2const indexToBeRemoved = 33arr.splice(indexToBeRemoved, 1)4console.log(arr)5// [1, 2, 3, 5] 获取数组最后一个元素改变原数组 1const arr = [1, 2, 3, 4, 5]2const lastElement = arr.pop()3console.log(lastElement)4// 55console.log(arr)6// [1, 2, 3, 4] 不改变原数组 1const arr = [1, 2, 3, 4, 5]2const lastElement = arr.slice(-1)[0]3console.log(lastElement)4// 55console.log(arr)6// [1, 2, 3, 4, 5] slice第一个参数如果是负数表示从后面开始数起的第几个元素，-1表示倒数第一个元素。 清空数组1const arr = [1, 2, 3, 4, 5]2arr.length = 03console.log(arr)4// []5console.log(arr[0])6// undefined 生成一定长度的数组1const newArr = new Array(10)2console.log(newArr)3// [ &lt;10 empty items&gt; ] 两个数组的交集1const arr1 = [1, 2, 3, 4]2const arr2 = [2, 3]3const intersectedArr = arr1.filter(item1 =&gt; arr2.includes(item1))4console.log(intersectedArr)5// [2, 3] 合并多个数组1const arr1 = [1, 2, 3]2const arr2 = [4, 5, 6]3const arr3 = [7, 8, 9]4const mergedArr = [...arr1, ...arr2, ...arr3]5console.log(mergedArr)6// [1, 2, 3, 4, 5, 6, 7, 8, 9] 移除数组的虚假(falsy)值1const mixedArr = [0, “blue”, “”, NaN, 9, true, undefined, “white”, false]2const trueArr = mixedArr.filter(Boolean);3console.log(trueArr)4// [“blue”, 9, true, “white”] 求和1const nums = [1, 2, 3, 4, 5]2const sum = nums.reduce((currSum, num) =&gt; currSum + num)3console.log(sum)4// 15","link":"/2019/12/11/JavaScript%E5%B0%8F%E6%8A%80%E5%B7%A7-%E6%95%B0%E7%BB%84%E7%AF%87/"},{"title":"详解ECMAScript2019/ES10新属性","text":"每年都有一些新的属性进入ECMA262标准，今年发布的ECMAScript2019/ES10同样也有很多新的特性，本文将会挑选一些普通开发者会用到的新属性进行深入的解读。 Array.prototype.flat() The flat() method creates a new array with all sub-array elements concatenated into it recursively up to the specified depth. – MDN 简单来说flat这个函数就是按照一定的深度depth将一个深层次嵌套的数组拍扁, 例子: 1const nestedArr = [1, 2, [3, 4, [5, 6, [7, [8], 9]]], 10]2console.log(nestedArr.flat())3// [1, 2, 3, 4, [5, 6, [7, [8], 9]], 10]4console.log(nestedArr.flat(2))5// [1, 2, 3, 4, 5, 6, [7, [8], 9], 10]6console.log(nestedArr.flat(3))7// [1, 2, 3, 4, 5, 6, 7, [8], 9, 10]8console.log(nestedArr.flat(4))9// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]10console.log(nestedArr.flat(Infinity))11// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 由上面的例子可以看出flat会按照指定的深度depth将一个数组扁平化，如果需要将数组完全拍扁变成一维数组，则指定depth为无限大，即是Infinity，相反如果不指定深度，其默认值是1。 Array.prototype.flatMap() The flatMap() method first maps each element using a mapping function, then flattens the result into a new array. It is identical to a map() followed by a flat() of depth 1, but flatMap() is often quite useful, as merging both into one method is slightly more efficient. – MDN 简单来说flatMap等于一个数组先调用完map函数再调用flat函数将其扁平化，扁平化的深度固定为1，先通过一个简单的例子感受一下: 1const myArr = [1, 2, 3]2myArr3 .map(n =&gt; [n * n]) // [[1], [4], [9]]4 .flat() // [1, 4, 9]56// 用flatMap可以一步到位7myArr.flatMap(n =&gt; [n * n]) // [1, 4, 9] 从上面的例子来看flatMap如果只是将flat和map做了一个简单的组合好像可有可无，其实不然，flatMap有个强大的功能是可以在map的时候添加和删除元素，这个无论是map还是filter都没有这个功能。 要想删除某一个元素只需要在mapper函数里面返回一个空的数组[], 而增加元素只需在mapper函数里面返回一个长度大于1的数组，具体可以看下面的例子： 1// 假如我们想要删除掉原数组里面所有的负数，同时将单数转换为一个复数和12const a = [5, 4, -3, 20, 17, -33, -4, 18]3// |\\ \\ x | | \\ x x |4// [4,1, 4, 20, 16,1, 18]5a.flatMap(n =&gt;6 (n &lt; 0) ? []: // 删除负数7 (n % 2 == 0) ? [n] : // 保留复数8 [n - 1, 1] // 单数变为一个复数和19)10// [4, 1, 4, 20, 20, 16, 1, 18] Object.fromEntries() The Object.fromEntries() method transforms a list of key-value pairs into an object. – MDN fromEntries方法将一个iterable对象返回的一系列键值对(key-value pairs)转换为一个object。先看一个简单的例子理解一下: 1// key-value pairs数组2const entriesArr = [['k1', 1], ['k2', 2]]3console.log(Object.fromEntries(entriesArr)4// {k1: 1, k2: 2}56const entriesMap = new Map([7 ['k1', 1],8 ['k2', 2]9]) // {\"k1\" =&gt; 1, \"k2\" =&gt; 2}10console.log(Object.fromEntries(entriesMap))11// {k1: 1, k2: 2} 再来看一个自定义的iterable对象例子深入理解一下: 1const iteratorObj = {2 [Symbol.iterator]: function () {3 const entries = [['k1', 1], ['k2', 2]]4 let cursor = 056 return {7 next() {8 const done = entries.length === cursor9 10 return {11 value: done ? undefined : entries[cursor++],12 done13 }14 }15 }16 }17}18Object.fromEntries(iteratorObj) // {k1: 1, k2: 2} 这个方法有一个用途就是对object的key进行filter，举个例子: 1const studentMap = {2 student1: {grade: 80},3 student2: {grade: 50},4 student3: {grade: 100}5}6const goodStudentMap = Object.fromEntries(7 Object8 .entries(studentMap)9 .filter(([_, meta]) =&gt; meta.grade &gt;= 60)10)11console.log(goodStudentMap)12// {student1: {grade: 80}, student3: {grade: 100}} String.prototype.trimStart这个方法很简单，就是返回一个将原字符串开头的空格字符去掉的新的字符串，例子: 1const greeting = ' Hello world! '2console.log(greeting.trimStart())3// 'Hello world! ' 这个方法还有一个别名函数，叫做trimLeft，它们具有一样的功能。 String.prototype.trimEnd这个方法和trimStart类似，只不过是将原字符串结尾的空格字符去掉，例子: 1const greeting = ' Hello world! '2console.log(greeting.trimEnd())3// ' Hello world!' 这个方法也有一个别名函数，叫做trimRight, 它们也具有一样的功能。 Symbol.prototype.description The read-only description property is a string returning the optional description of Symbol objects. – MDN ECMAScript2019给Symbol对象添加了一个可选的description属性，这个属性是个只读属性，看看例子: 1console.log(Symbol('desc').description)2// desc3console.log(Symbol.for('desc').description)4// desc56// 一些内置的Symbol也有这个属性7console.log(Symbol.iterator.description)8// Symbol.iterator910// 如果初始化时没有带description，这个属性会返回一个undefined，因为这样才说这个属性是可选的11console.log(Symbol().description)12// undefined1314// 这个属性是只读的，不能被设置15Symbol.iterator.description = 'mess it'16console.log(Symbol.iterator.description)17// Symbol.iterator 这个新的属性只要是为了方便开发者调试，不能通过比较两个Symbol对象的description来确定这两个Symbol是不是同一个Symbol: 1var s1 = Symbol(\"desc\")2var s2 = Symbol(\"desc\")3console.log(s1.description === s2.description)4// true5console.log(s1 === s2)6// false try catch optional bindingECMAScript2019之后，你写try…catch时如果没必要时可以不用声明error： 1// ECMAScript2019之前，你一定要在catch里面声明error，否则会报错2try {3 ...4} catch (error) {56}7// 可是有时候，你确实用不到这个error对象，于是你会写这样的代码8try {9 ...10} catch (_) {11 ...12}1314// ECMAScript2019后，你可以直接这样写了15try {16 ...17} catch {18 ...19} 虽然这个新属性可以让你省略掉error，可是我觉得开发者应该避免使用这个属性，因为在我看来所有的错误都应该被处理，至少应该被console.error出来，否则可能会有一些潜在的bug，举个例子： 1let testJSONObj2try {3 testJSONObj = JSON.prase(testStr)4} catch {5 testJSONObj = {}6}7console.log(testJSONObj) 以上代码中无论testStr是不是一个合法的JSON字符串，testJSONObj永远都是一个空对象，因为JSON.parse函数名写错了，而你又忽略了错误处理，所以你永远不会知道这个typo。 稳定的排序 Array.prototype.sortECMAScript2019后Array.sort一定是个稳定的排序。什么是稳定排序？所谓的稳定排序就是：假如没排序之前有两个相同数值的元素a[i]和a[j]，而且i在j前面，即i &lt; j，经过排序后元素a[i]依然排在a[j]元素的前面，也就是说稳定的排序不会改变原来数组里面相同数值的元素的先后关系。看个例子： 1var users = [2 {name: 'Sean', rating: 14},3 {name: 'Ken', rating: 14},4 {name: 'Jeremy', rating: 13}5]6users.sort((a, b) =&gt; a.rating - b.rating)7// 非稳定的排序结果可能是8// [9// {name: 'Jeremy', rating: 13}, 10// {name: 'Ken', rating: 14}, 11// {name: 'Sean', rating: 14}12// ]13// 虽然Sean和Ken具有同样的rating，可是非稳定的排序不能保证他们两个的顺序在排序后保持不变1415// ECMAScript2019后，Array.sort将是一个稳定的排序，也就是说它可以保证Sean和Ken两个人的顺序在排序后不变16// [17// {name: 'Jeremy', rating: 13}, 18// {name: 'Sean', rating: 14}, 19// {name: 'Ken', rating: 14}20// ] 改进Function.prototype.toString()ECMAScript2019之前，调用function的toString方法会将方法体里面的空格字符省略掉，例如: 1function hello() {2 console.log('hello word')3}45console.log(hello.toString())6//'function hello() {\\nconsole.log('hello word')\\n}' ECMAScript2019之后，要求一定要返回函数源代码（保留空格字符）或者一个标准的占位符例如native code，所以ECMAScript2019之后，以上的输出会变为： 1console.log(hello.toString())2//\"function hello() {3// console.log('hello word')4//}\"","link":"/2019/12/05/ECMAScript2019-ES10%E6%96%B0%E5%B1%9E%E6%80%A7/"},{"title":"Svelte 3 初学者完全指南","text":"React, Vue和Angular差不多占据了Web开发的大部分江山，可是最近半年Svelte开始逐渐吸引越来越多人的眼球。这个Svelte框架到底有什么过人之处呢？本文将会为大家分析一下Svelte火起来的原因，并且通过使用Svelte去搭建一个简单的书店应用（bookshop）来帮助大家快速入门这门框架。 Svelte为什么会火?要想知道Svelte为什么会火，首先得看看React和Vue这些框架存在什么问题。 big runtime - 大的运行时React和Vue都是基于runtime的框架。所谓基于runtime的框架就是框架本身的代码也会被打包到最终的bundle.js并被发送到用户浏览器。当用户在你的页面进行各种操作改变组件的状态时，框架的runtime会根据新的组件状态（state）计算（diff）出哪些DOM节点需要被更新，从而更新视图。那么这些runtime代码到底有多大呢，可以看一些社区的统计数据: Name Size Ember 2.2.0 435K Ember 1.13.8 486K Angular 2 566K Angular 2 + Rx 766K Angular 1.4.5 143K Vue 2.4.2 58.8K Inferno 1.2.2 48K Preact 7.2.0 16K React 0.14.5 + React DOM 133K React 0.14.5 + React DOM + Redux 139K React 16.2.0 + React DOM 97.5K 从上面的表格可以看出常用的框架中，最小的Vue都有58k，React更有97.5k。换句话说如果你使用了React作为开发的框架，即使你的业务代码很简单，你的首屏bundle size都要100k起步。当然100k不算很大，可是事物都是相对的，相对于大型的管理系统来说100k肯定不算什么，可是对于那些首屏加载时间敏感的应用（例如淘宝，京东主页），100k的bundle size在一些网络环境不好的情况或者手机端真的会影响用户体验。那么如何减少框架的runtime代码大小呢？要想减少runtime代码的最有效的方法就是压根不用runtime。其实回想一下Web开发的历史，很早之前在用Jquery和Bootstrap一把梭的时候，我们的代码不就是不包含runtime的吗？当数据变化时直接通过JavaScript去改变原生DOM节点，没有框架那一系列diff和调度（React Fiber）的过程。这时你可能会问，要减少bundle size真的要回到那个刀耕火种的时代吗？有没有那种既可以让我用接近React和Vue的语法编写代码，同时又不包含框架runtime的办法。这恰恰就是Svelte要做的东西，它采用了Compiler-as-framework的理念，将框架的概念放在编译时而不是运行时。你编写的应用代码在用诸如Webpack和Rollup等工具打包的时候会被直接转换为JavaScript对DOM节点的原生操作，从而让bundle.js不包含框架的runtime。那么Svelte到底可以将bundle size减少多少呢？以下是RealWorld这个项目的统计：由上面的图表可以看出实现相同功能的应用，Svelte的bundle size大小是Vue的1/4，是React的1/20！单纯从这个数据来看，Svelte这个框架对bundle size的优化真的很大。 低效的Virtual DOM Diff什么？Virtual DOM不是一直都很高效的吗？其实Virtual DOM高效是一个误解。说Virtual DOM高效的一个理由就是它不会直接操作原生的DOM节点，因为这个很消耗性能。当组件状态变化时它会通过某些diff算法去计算出本次数据更新真实的视图变化，然后只改变“需要改变”的DOM节点。用过React的人可能都会体会到React并没有想象中那么高效，框架有时候会做很多无用功，这体现在很多组件会被“无缘无故”进行重渲染（re-render）。注意这里说的re-render和对原生DOM进行操作是两码事！所谓的re-render是你定义的class Component的render方法被重新执行，或者你的组件函数被重新执行。组件被重渲染是因为Vitual DOM的高效是建立在diff算法上的，而要有diff一定要将组件重渲染才能知道组件的新状态和旧状态有没有发生改变，从而才能计算出哪些DOM需要被更新。你可能会说React Fiber不是出来了吗，这个应该不是问题了吧？其实Fiber这个架构解决的问题是不让组件的重渲染和reconcile的过程阻塞主线程的执行，组件重渲染的问题依然存在，而且据反馈，React Hooks出来后组件的重渲染更加频繁了。正是因为框架本身很难避免无用的渲染，React才允许你使用一些诸如shouldComponentUpdate，PureComponent和useMemo的API去告诉框架哪些组件不需要被重渲染，可是这也就引入了很多模板代码（boilerplate）。如果大家想了解更多关于Virtual DOM存在的问题，可以看一下virtual dom is pure overhead这篇文章。 那么如何解决Vitual DOM算法低效的问题呢？最有效的解决方案就是不用Virtual DOM！其实作为一个框架要解决的问题是当数据发生改变的时候相应的DOM节点会被更新（reactive），Virtual DOM需要比较新老组件的状态才能达到这个目的，而更加高效的办法其实是数据变化的时候直接更新对应的DOM节点： 1if (changed.name) {2 text.data = name;3} 这就是Svelte采用的办法。Svelte会在代码编译的时候将每一个状态的改变转换为对应DOM节点的操作，从而在组件状态变化的时候快速高效地对DOM节点进行更新。根据js framework benchmark的统计，Svelte在对一些大列表操作的时候性能比React和Vue都要好。 什么是Svelte?Svelte是由RollupJs的作者Rich Harris编写的编译型框架，没了解过RollupJs的同学可以去它官网了解一下，它其实是一个类似于Webpack的打包工具。Svelte这个框架具有以下特点： 和React，Vue等现代Web框架的用法很相似，它可以允许开发者快速开发出具有流畅用户体验的Web应用。 不使用Virtual DOM，也不是一个runtime的库。 基于Compiler as framework的理念，会在编译的时候将你的应用转换为原生的DOM操作。 默认就支持类似于CSS modules的CSS scope功能，让你避免CSS样式冲突的困扰。 原生支持CSS animation。 极其容易的组件状态管理（state management），减少开发者的模板代码编写（boilerplate less）。 支持反应式定义（Reactive statement）。 极其容易的应用全局状态管理，框架本身自带全局状态，类似于React的Redux和Vue的Vuex。 支持context，避免组件的props drilling。 Svelte这个框架与Vue和React之间最大的区别是它除了管理组件的状态和追踪他们的渲染，还有很多其他有用的功能。例如它原生支持CSS scope和CSS animation。如果你用React或者Vue是需要引入第三方库来实现同样的功能的，而第三方依赖的引入会给开发者增加学习和维护的成本。 用Svelte搭建一个Bookshop应用接下来我们会从头开始搭建一个基于Svelte框架的简单书店应用bookshop，通过这个demo，希望大家可以理解Svelte的一些基本概念和掌握它的一些基本用法并能够使用Svelte去搭建更加复杂的应用。 应用功能Bookshop应用支持以下功能： 管理员录入新图书 展示书店图书列表 将图书加到购物车 展示购物车的数据信息 对学习者的技术要求 掌握html，css和javascript的基础用法 有过React或者Vue的相关开发经验最佳 项目的源代码可以在我的github仓库找到。 项目搭建首先在我们的本地开发环境新建一个项目文件夹： 1mkdir svelte-bookshop 接着用svelte官方的脚手架去初始化我们的应用： 1npx degit sveltejs/template svelte-bookshop2cd svelte-bookshop34yarn5yarn dev degit这个命令会将github上面的项目文件直接拷贝到某个本地文件夹，这里使用到的svelte/tempalte模板项目的github地址是这个。以上命令成功运行后，访问http://localhost:5000你会看到如下界面：界面很简单就是展示一个hello world，接着让我们看一下生成的项目目录结构：生成的代码主要包含以下文件目录结构： rollup.config.js，这个是rollup的配置文件，类似于webpack.config.js，里面指定了项目的入口文件是src/main.js。 src文件夹，这个文件夹用来存储我们的项目源代码，现在只有一个项目的主入口文件main.js和一个组件文件App.svelte。 public文件夹，这个文件夹是用来存储项目的静态文件（index.html, global.css和favicon.png）和rollup编译生成的静态文件（build文件夹底下的bundle.js和bundle.css以及它们各自的source map）。 接着让我们具体看一下src文件夹底下的各个文件内容 src/App.svelte1&lt;script&gt;2 export let name;3&lt;/script&gt;45&lt;main&gt;6 &lt;h1&gt;Hello {name}!&lt;/h1&gt;7 &lt;p&gt;Visit the &lt;a href=\"https://svelte.dev/tutorial\"&gt;Svelte tutorial&lt;/a&gt; to learn how to build Svelte apps.&lt;/p&gt;8&lt;/main&gt;910&lt;style&gt;11 main {12 text-align: center;13 padding: 1em;14 max-width: 240px;15 margin: 0 auto;16 }1718 h1 {19 color: #ff3e00;20 text-transform: uppercase;21 font-size: 4em;22 font-weight: 100;23 }2425 @media (min-width: 640px) {26 main {27 max-width: none;28 }29 }30&lt;/style&gt; 这个文件定义了一个叫做App的Svelte组件，这里要注意App.svelte文件内并没有定义组件的名称，组件的名称是由它的文件名确定的。Svelte组件的文件名都是以.svelte结尾的，一个组件文件通常会包含以下三部分内容： &lt;script&gt;标签，和组件相关的任何JavaScript代码都可以放在这里，例如组件的状态定义或者一些异步Ajax请求。在这个App.svelte文件里面没有定义局部的组件状态，而是定义并export了一个name变量。对于Svelte框架，export一个变量就是将这个变量指定为当前组件的一个外部参数 - props。这种做法和React里面的将props作为组件的第一个参数的区别很大，可能大家一开始有点不习惯，不过后面习惯了，你可能也会爱上这种写法的。 &lt;style&gt;标签，和组件相关的CSS代码会放在这里。注意这里的CSS是局部生效的（scope），也就是说App.svelte中的h1标签的样式只会对App组件内的h1标签生效，而对项目其他的包括这个组件的子节点的h1标签失效。具体可以用浏览器的调试工具看一下h1标签的实际样式就明白了: 由上图可以看出Svelte在生成代码的时候会用一些随机的哈希值将组件的样式和其它组件的样式区别开来。 组件的HTML标签。组件的HTML标签可以直接在文件中写出来，例如App组件的HTML部分是：1&lt;main&gt;2 &lt;h1&gt;Hello {name}!&lt;/h1&gt;3 &lt;p&gt;Visit the &lt;a href=\"https://svelte.dev/tutorial\"&gt;Svelte tutorial&lt;/a&gt; to learn how to build Svelte apps.&lt;/p&gt;4&lt;/main&gt; App组件最外层是一个main标签，main标签里面有一个h1标签和p标签，其中h1标签里面是一个Hello字符串加一个用花括号包裹的插入字符串（interpolation），在React JSX里面的写法应该是Hello ${name}，它们都表示这个位置的字符串就是name这个变量的内容。至于这个name变量就是我们在上面用export定义的外部参数。 总的来说Svelte会将所有和组件相关的JavaScript，CSS和HTML代码都放在同一个文件里面，这个做法有点像Vue，不过和Vue相比它的模板代码更少。 src/main.js1import App from './App.svelte';23const app = new App({4 target: document.body,5 props: {6 name: 'world'7 }8});910export default app; 这个文件内容很简单，就是将刚刚定义的App组件挂载到目标节点body上，而且为App组件提供了值为world的name参数。这段代码的作用和React中的ReactDOM.render函数一样。 接着让我们看一下生成的静态代码是什么样子的。 public/build/bundle.js先看生成的JavaScript主文件bundle.js，由于原文件比较大，我只截取了其中比较关键的一部分： 1/* src/App.svelte generated by Svelte v3.16.4 */23const file = \"src/App.svelte\";45function create_fragment(ctx) {6 let main;7 let h1;8 let t0;9 let t1;10 let t2;11 let t3;12 let p;13 let t4;14 let a;15 let t6;1617 const block = {18 c: function create() {19 main = element(\"main\");20 h1 = element(\"h1\");21 t0 = text(\"Hello \");22 t1 = text(/*name*/ ctx[0]);23 t2 = text(\"!\");24 t3 = space();25 p = element(\"p\");26 t4 = text(\"Visit the \");27 a = element(\"a\");28 a.textContent = \"Svelte tutorial\";29 t6 = text(\" to learn how to build Svelte apps.\");30 attr_dev(h1, \"class\", \"svelte-1tky8bj\");31 add_location(h1, file, 5, 1, 46);32 attr_dev(a, \"href\", \"https://svelte.dev/tutorial\");33 add_location(a, file, 6, 14, 83);34 add_location(p, file, 6, 1, 70);35 attr_dev(main, \"class\", \"svelte-1tky8bj\");36 add_location(main, file, 4, 0, 38);37 },38 l: function claim(nodes) {39 throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");40 },41 m: function mount(target, anchor) {42 insert_dev(target, main, anchor);43 append_dev(main, h1);44 append_dev(h1, t0);45 append_dev(h1, t1);46 append_dev(h1, t2);47 append_dev(main, t3);48 append_dev(main, p);49 append_dev(p, t4);50 append_dev(p, a);51 append_dev(p, t6);52 },53 p: function update(ctx, dirty) {54 if (dirty[0] &amp; /*name*/ 1) set_data_dev(t1, /*name*/ ctx[0]);55 },56 i: noop,57 o: noop,58 d: function destroy(detaching) {59 if (detaching) detach_dev(main);60 }61 };6263 dispatch_dev(\"SvelteRegisterBlock\", {64 block,65 id: create_fragment.name,66 type: \"component\",67 source: \"\",68 ctx69 });7071 return block;72} 这段代码对应的就是我们刚刚定义的App组件，create_fragment方法会接受一个上下文对象ctx参数并返回一个代表组件的block对象。 block这个对象主要包含以下四个重要的方法c（create），m（mount），p（update）和d（destroy）。 c（create）1function create() {2 main = element(\"main\");3 h1 = element(\"h1\");4 t0 = text(\"Hello \");5 t1 = text(/*name*/ ctx[0]);6 t2 = text(\"!\");7 t3 = space();8 p = element(\"p\");9 t4 = text(\"Visit the \");10 a = element(\"a\");11 a.textContent = \"Svelte tutorial\";12 t6 = text(\" to learn how to build Svelte apps.\");13 attr_dev(h1, \"class\", \"svelte-1tky8bj\");14 add_location(h1, file, 5, 1, 46);15 attr_dev(a, \"href\", \"https://svelte.dev/tutorial\");16 add_location(a, file, 6, 14, 83);17 add_location(p, file, 6, 1, 70);18 attr_dev(main, \"class\", \"svelte-1tky8bj\");19 add_location(main, file, 4, 0, 38);20} 这个函数的功能是生成（create）和App组件相关的一些原生DOM节点，并为它们添加一些元数据（meta data）。 m（mount）1function mount(target, anchor) {2 insert_dev(target, main, anchor);3 append_dev(main, h1);4 append_dev(h1, t0);5 append_dev(h1, t1);6 append_dev(h1, t2);7 append_dev(main, t3);8 append_dev(main, p);9 append_dev(p, t4);10 append_dev(p, a);11 append_dev(p, t6);12} 这个函数的功能是挂载c函数生成的那些DOM节点。 p（update）1function update(ctx, dirty) {2 if (dirty[0] &amp; /*name*/ 1) set_data_dev(t1, /*name*/ ctx[0]);3} p函数会在ctx上下文更新的时候去更新对应DOM节点的属性。大概就是当上下文变化的时候，检查一下name这个变量有没有变化，如果发生变化则更新DOM节点。 d（destroy）1function destroy(detaching) {2 if (detaching) detach_dev(main);3} d函数是用来删除App组件的。 看完Svelte生成的代码后，我想你对我在文章开头说的Compiler-as-framework等概念应该有了更加深刻的认识，Svelte和React（Vue也类似）不一样的是，React应用在打包完之后，还保留了如React.createElement，setState等框架函数的调用代码，而Svelte编译完之后，框架代码会被转化为操作原生DOM节点的代码。 大概了解了项目的组织结构后，让我们开始正式搭建书店bookshop应用。 组件定义HTML markup首先让我们创建一个展示书本具体信息的卡片组件，在src文件夹底下新建一个BookCard.svelte文件，里面定义一下卡片组件的HTML markup： 1// src/BookCard.svelte2&lt;div&gt;3 &lt;h1&gt;title&lt;/h1&gt;4 &lt;div&gt;price&lt;/div&gt;5 &lt;div&gt;description&lt;/div&gt;6 &lt;button&gt;添加到购物车&lt;/button&gt;7&lt;/div&gt; 然后在App.svelte组件里面使用BookCard组件: 1// src/App.svelte2&lt;script&gt;3 import BookCard from \"./BookCard.svelte\";4&lt;/script&gt;56&lt;style&gt;7 ...8&lt;/style&gt;910&lt;main&gt;11 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;12 &lt;section&gt;13 &lt;BookCard /&gt;14 &lt;/section&gt;15&lt;/main&gt; 使用自定义的组件的方法很简单：先在script标签里面导入新定义的组件BookCard，然后将该组件写在App组件的HTML markup里面，语法和JSX一样的。这时候再查看页面的内容： CSSBookCard组件虽然出来了，我们得定义一些CSS让它变得更好看一点： 1// src/BookCard.svelte2&lt;style&gt;3 .card {4 text-align: left;5 border-radius: 5px;6 box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);7 padding: 10px;8 }910 h1 {11 font-size: 20px;12 }1314 h2 {15 font-size: 15px;16 color: #999;17 }1819 button {20 background-color: #ff3e00;21 color: white;22 border-radius: 5px;23 cursor: pointer;24 border: none;25 }26&lt;/style&gt;2728&lt;div class=\"card\"&gt;29 &lt;h1&gt;title&lt;/h1&gt;30 &lt;h2&gt;price&lt;/h2&gt;31 &lt;p&gt;description&lt;/p&gt;32 &lt;button&gt;添加到购物车&lt;/button&gt;33&lt;/div&gt; 给组件定义样式的方法就是新建一个style标签然后把该组件相关的样式写在这个标签内，注意这里的样式只会对组件内的元素有效，不会影响到其他组件的样式的。加完样式后，界面应该会变成这个样子： props定义书本的具体信息应该是由传入的props指定的。Svelte组件的props要用export来指明，指明的props变量可以直接被组件使用： 1// src/BookCard.svelte2&lt;script&gt;3 export let title;4 export let price;5 export let description;6&lt;/script&gt;78&lt;style&gt;9...10&lt;/style&gt;1112&lt;div class=\"card\"&gt;13 &lt;h1&gt;title&lt;/h1&gt;14 &lt;h2&gt;price&lt;/h2&gt;15 &lt;p&gt;description&lt;/p&gt;16 &lt;button&gt;添加到购物车&lt;/button&gt;17&lt;/div&gt; 变量使用定义和引入的变量可以在组件的HTML markup中直接使用，具体用法是在Markup中用花括号（curly braces）引用该变量，具体代码时： 1// src/BookCard.svelte2&lt;script&gt;3 export let title;4 export let price;5 export let description;6&lt;/script&gt;78&lt;style&gt;9...10&lt;/style&gt;1112&lt;div class=\"card\"&gt;13 &lt;h1&gt;{title}&lt;/h1&gt;14 &lt;h2&gt;${price}&lt;/h2&gt;15 &lt;p&gt;{description}&lt;/p&gt;16 &lt;button&gt;添加到购物车&lt;/button&gt;17&lt;/div&gt; 组件参数传递然后在父级组件App中，将BookCard需要的参数传给该组件： 1// src/App.svelte2&lt;script&gt;3 ...4 let title = \"JavaScript高级编程\";5 let price = 99.0;6 let description = \"一起来学习JavaScript啊\";7&lt;/script&gt;89&lt;style&gt;10 ...11&lt;/style&gt;1213&lt;main&gt;14 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;15 &lt;section&gt;16 &lt;BookCard title={title} price={price} description={description} /&gt;17 &lt;/section&gt;18&lt;/main&gt; 这时候书本卡片的内容应该是传入的参数了：对于组件参数传递，Svelte还提供了以下更加方便的写法： 1// src/App.svelte2&lt;main&gt;3 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;4 &lt;section&gt;5 &lt;BookCard {title} {price} {description} /&gt;6 &lt;/section&gt;7&lt;/main&gt; 录入书本信息作为一个书店，管理员应该可以录入新的图书，所以我们给App组件添加一个简单的表单来让用户录入数据： 1// src/App.svelte2&lt;script&gt;3 ...4&lt;/script&gt;56&lt;style&gt;7 ....8&lt;/style&gt;910&lt;main&gt;11 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;12 &lt;section&gt;13 &lt;h2&gt;Add new book&lt;/h2&gt;14 &lt;label for=\"title\"&gt;Title&lt;/label&gt;15 &lt;input type=\"text\" id=\"title\" value={title} /&gt;16 &lt;label for=\"price\"&gt;Price&lt;/label&gt;17 &lt;input type=\"number\" id=\"price\" value={price} /&gt;18 &lt;label for=\"description\"&gt;Description&lt;/label&gt;19 &lt;textarea rows=\"3\" id=\"description\" value={description} /&gt;20 &lt;/section&gt;21 &lt;section&gt;22 &lt;BookCard {title} {price} {description} /&gt;23 &lt;/section&gt;24&lt;/main&gt; 我们为App组件新建了一些input标签，并指定这些input标签的值为我们之前定义的变量，这时候我们试着改变输入框的内容：虽然输入框的初始值是变量对应的值，可是变量的值并不会随着输入框的值的改变而改变，也就是它们的值没有”绑定起来“，要想实现双向数据绑定，我们可以给输入框添加一个监听事件。 事件绑定我们可以使用on关键字加事件名称给DOM添加事件监听器，以下代码将会监听input输入框的input事件： 1&lt;script&gt;2 ...3 let title = \"JavaScript高级编程\";4 ...56 function handleTitleChange(event) {7 title = event.target.value;8 }9&lt;/script&gt;1011&lt;style&gt;12 ...13&lt;/style&gt;1415&lt;main&gt;16 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;17 &lt;section&gt;18 &lt;h2&gt;Add new book&lt;/h2&gt;19 &lt;label for=\"title\"&gt;Title&lt;/label&gt;20 &lt;input type=\"text\" id=\"title\" value={title} on:input={handleTitleChange} /&gt;21 ...22 &lt;/section&gt;23&lt;/main&gt; 这时候我们再改变input的值，会发现卡片里面的内容也发生了改变，说明我们成功改变了title变量的值： 自动数据双向绑定可是如果每一个input标签都要手动添加一个事件监听的话我们的代码会有很多模板代码，为了解决这个问题，Svelte允许我们直接用bind关键字加要绑定的属性进行双向数据绑定： 1// src/App.svelte2&lt;script&gt;3 ...4 let title = \"JavaScript高级编程\";5 let price = 99.0;6 let description = \"一起来学习JavaScript啊\";7&lt;/script&gt;89&lt;style&gt;10 ...11&lt;/style&gt;1213&lt;main&gt;14 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;15 &lt;section&gt;16 &lt;h2&gt;Add new book&lt;/h2&gt;17 &lt;label for=\"title\"&gt;Title&lt;/label&gt;18 &lt;input type=\"text\" id=\"title\" bind:value={title} /&gt;19 &lt;label for=\"price\"&gt;Price&lt;/label&gt;20 &lt;input type=\"number\" id=\"price\" bind:value={price} /&gt;21 &lt;label for=\"description\"&gt;Description&lt;/label&gt;22 &lt;textarea rows=\"3\" id=\"description\" bind:value={description} /&gt;23 &lt;/section&gt;24 ...25&lt;/main&gt; 这时候我们就可以把各个变量的初始值去掉： 1// src/App.svelte2&lt;script&gt;3 let title = \"\";4 let price = 0;5 let description = \"\";6&lt;/script&gt; 这时候我们页面的输入框和所有变量都”绑定“起来了： 展示书本列表我们的书店应该不止一本书，要用一个数组把所有的书本存起来： 1// src/App.svelte2&lt;script&gt;3 ...4 let books = [];5 ...6&lt;/script&gt; 接着我们再为刚刚新增的表单添加一个提交按钮，用户填完书本的信息后点击提交会新建一个book对象，新建的book对象会被加到books列表中去： 1&lt;script&gt;2 ...3 let books = [];45 function handleAddBook() {6 books = books.concat({ title, price, description });7 title = \"\";8 price = 0;9 description = \"\";10 }11 ...12&lt;/script&gt;1314&lt;style&gt;15 ...16 button {17 background-color: #ff3e00;18 color: white;19 border-radius: 5px;20 cursor: pointer;21 border: none;22 }23 ...24&lt;/style&gt;2526&lt;main&gt;27 &lt;h1&gt;Welcome to my online bookstore!&lt;/h1&gt;28 &lt;section&gt;29 &lt;h2&gt;Add new book&lt;/h2&gt;30 &lt;label for=\"title\"&gt;Title&lt;/label&gt;31 &lt;input type=\"text\" id=\"title\" bind:value={title} /&gt;32 &lt;label for=\"price\"&gt;Price&lt;/label&gt;33 &lt;input type=\"number\" id=\"price\" bind:value={price} /&gt;34 &lt;label for=\"description\"&gt;Description&lt;/label&gt;35 &lt;textarea rows=\"3\" id=\"description\" bind:value={description} /&gt;36 &lt;div&gt;37 &lt;button on:click={handleAddBook}&gt;add book&lt;/button&gt;38 &lt;/div&gt;39 &lt;/section&gt;40 ...41&lt;/main&gt; 展示列表数据我们可以使用each语法块去展示books列表的数据： 1// src/App.svelte2&lt;script&gt;3 ....45 let books = [];67 function handleAddBook() {8 books = books.concat({ title, price, description });9 title = \"\";10 price = 0;11 description = \"\";12 }13&lt;/script&gt;1415&lt;main&gt;16 ...17 &lt;section&gt;18 {#each books as book}19 &lt;BookCard20 title={book.title}21 price={book.price}22 description={book.description} /&gt;23 {/each}24 &lt;/section&gt;25&lt;/main&gt; 你也可以直接在each块定义的时候解构出被递归对象里面的内容，上面的代码变为： 1// src/App.svelte2 ...3 &lt;section&gt;4 {#each books as { title, price, description }}5 &lt;BookCard {title} {price} {description} /&gt;6 {/each}7 &lt;/section&gt;8 ... 代码更改完后，你的页面就可以录入新书并展示书的列表了： 购物车功能首先我们要为BookCard这个组件的按钮添加一个点击事件：用户点击书本卡片按钮的时候这本书会被加到购物车中。要实现这个效果我们可以为BookCard按钮定义一个handleAddBook的参数，这个参数由外面组件来提供，handleAddBook函数会在用户点击BookCard按钮的时候被调用并将该书添加购物车中。代码如下： 1// src/BookCard.svelte2&lt;script&gt;3 ...4 export let handleAddToCart;5&lt;/script&gt;67&lt;style&gt;8 ...9&lt;/style&gt;1011&lt;div class=\"card\"&gt;12 &lt;h1&gt;{title}&lt;/h1&gt;13 &lt;h2&gt;${price}&lt;/h2&gt;14 &lt;p&gt;{description}&lt;/p&gt;15 &lt;button on:click={() =&gt; handleAddToCart(title)}&gt;添加到购物车&lt;/button&gt;16&lt;/div&gt; 1// src/App.svelte2&lt;script&gt;3 ...4 let booksInCart = [];56 function handleAddToCart(title) {7 let bookNeededToBeAdded = books.find(book =&gt; book.title == title);8 booksInCart = booksInCart.concat(bookNeededToBeAdded);9 }10&lt;/script&gt;1112&lt;style&gt;13 ...14&lt;/style&gt;1516&lt;main&gt;17 ...18 &lt;section&gt;19 &lt;h2&gt;购物车&lt;/h2&gt;20 {#each booksInCart as { title, price }}21 &lt;div&gt;名称: {title}, 价钱: {price}&lt;/div&gt;22 {/each}23 &lt;/section&gt;24 &lt;section&gt;25 &lt;h2&gt;书单&lt;/h2&gt;26 {#each books as { title, price, description }}27 &lt;BookCard {title} {price} {description} {handleAddToCart} /&gt;28 {/each}29 &lt;/section&gt;30&lt;/main&gt; 这时候我们就可以看到我们的购物车了： 条件判断Svelte可以用if语法块根据不同条件展示不同的内容，我们可以在购物车为空的时候给用户展示一个空的状态： 1// src/App.svelte2...3&lt;section&gt;4 &lt;h2&gt;购物车&lt;/h2&gt;5 {#if booksInCart.length === 0}6 &lt;p&gt;购物车空的哦~&lt;/p&gt;7 {:else}8 {#each booksInCart as { title, price }}9 &lt;div&gt;名称: {title}, 价钱: {price}&lt;/div&gt;10 {/each}11 {/if}12&lt;/section&gt;13... 这时候界面变为： 展示购物车统计信息我们再为书店添加一个帮用户统计购物车的书本的功能，可以展示现在购物车里面的书本总数和总金额，代码如下: 1// src/App.svelte2&lt;script&gt;3 ...4 let booksInCart = [];56 let booksNumInCart = booksInCart.length;7 let totalCheckoutPrice = booksInCart.reduce(8 (sum, book) =&gt; sum + book.price,9 010 );11 ...12&lt;/script&gt;1314...15&lt;section&gt;16 &lt;h2&gt;购物车&lt;/h2&gt;17 &lt;div&gt;书本总数：{booksNumInCart}&lt;/div&gt;18 &lt;div&gt;订单金额：{totalCheckoutPrice}&lt;/div&gt;19 ...20&lt;/section&gt;21... 这时候我们操作界面却发现购物车的数据变化时统计数据竟然没有变化：数据没有变化的原因是我们每次添加书本到购物车的时候没有手动地去改变booksNumInCart和totalCheckoutPrice的值。不过如果需要在购物车数据发生变化的时候手动维护统计数据的话，代码会变得很丑陋。 反应式定义对于这种情况，Svelte提供了反应式定义（Reactive assignment）的方法来表示这种联动的数据，具体做法就是用$符号定义变量而不是let，以下是代码： 1&lt;script&gt;2 ...3 let booksInCart = [];45 $: booksNumInCart = booksInCart.length;6 $: totalCheckoutPrice = booksInCart.reduce(7 (sum, book) =&gt; sum + book.price,8 09 );10 ...11&lt;/script&gt; 这样当booksInCart这个数据发生改变的时候，booksNumInCart和totalCheckoutPrice这个两个变量就会自动被重新计算。这时候我们再对界面进行操作的话，会发现统计数据会随着购物车的数据变化而自动发生改变： 总结我们的简易书店系统（bookshop）大概就实现了这些功能，现在来总结一下在开发项目的时候覆盖到的Svelte框架基础知识： 组件定义 - component definition 变量使用 - using variables props定义和参数传递 - props definition and passing 事件监听 - event listening 数据绑定 - data binding 条件判断 - if condition 列表数据展示 - each block 其实Svelte框架还有很多我没有提到的有用的功能特性，例如： 事件传递 - event forwarding 生命周期函数 - life-cycle functions 全局状态管理 - stores 上下文管理 - context CSS 动画 - css animation … 由于文章篇幅的限制我在这里没有覆盖Svelte所有的属性，大家兴趣可以看一下svelte的官方教程。 我个人对Svelte框架的一些看法个人觉得由于Virtual DOM的各种问题，Compiler as framework这个思路应该是前端框架发展的一个趋势。Svelte目前实现的功能虽然已经非常不错了，可是就目前来说我觉得它还有以下问题： Scalability - 可扩展性。React和Vue等框架自带的runtime虽然会增加首屏加载的bundle.js，可是当项目变得越来越大的时候，框架的runtime在bundle.js里面占据的比例也会越来越小，相反由于Svelte生成的代码的封装性没有React和Vue的好，它在大型项目中会不会堆积很多重复的代码呢？这个时候我们就得考虑一下是不是存在一个Svelte生成的代码大于React和Vue生成的代码的阈值了。这个问题现在还没有具体的答案，只能等后人实践的时候给出答案了，大家有兴趣可以看一下作者在github上面的讨论。 Ecosystem - 生态。作为一个最近才火起来的框架，Svelte的生态还远远不及已经普及那么多年的React和Vue，这也是我觉得就目前来说Svelte还撼动不了React和Vue的地位的原因。不过Svelte会不会因为它的先进性而迎来生态大爆发呢？我们可以拭目以待。 不过有一点可以肯定的是，Svelte由于在一些不复杂的项目中生成的代码远远比React，Vue和Angular小的优势会在一些性能不那么好的嵌入式操作系统中大放异彩。 学习Svelte有用的链接 作者的Rethinking reactivity演讲 Svelte官网 Svelte github仓库","link":"/2019/12/17/Svelte-3-%E5%88%9D%E5%AD%A6%E8%80%85%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"ECMAScript","slug":"ECMAScript","link":"/tags/ECMAScript/"},{"name":"2019","slug":"2019","link":"/tags/2019/"},{"name":"Svelte","slug":"Svelte","link":"/tags/Svelte/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}